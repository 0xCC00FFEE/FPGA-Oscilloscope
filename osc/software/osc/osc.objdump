
osc.elf:     file format elf32-littlenios2
osc.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x001481b8

Program Header:
    LOAD off    0x00001000 vaddr 0x00148000 paddr 0x00148000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00148020 paddr 0x00148020 align 2**12
         filesz 0x000050d8 memsz 0x000050d8 flags r-x
    LOAD off    0x000060f8 vaddr 0x0014d0f8 paddr 0x0014daac align 2**12
         filesz 0x000009b4 memsz 0x000009b4 flags rw-
    LOAD off    0x00007460 vaddr 0x0014e460 paddr 0x0014e460 align 2**12
         filesz 0x00000000 memsz 0x00000918 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00148000  00148000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000198  00148020  00148020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000047d4  001481b8  001481b8  000011b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000076c  0014c98c  0014c98c  0000598c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000009b4  0014d0f8  0014daac  000060f8  2**4
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000918  0014e460  0014e460  00007460  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00006aac  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000528  00000000  00000000  00006ad0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000060c3  00000000  00000000  00006ff8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001e92  00000000  00000000  0000d0bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00002366  00000000  00000000  0000ef4d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000c78  00000000  00000000  000112b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001728  00000000  00000000  00011f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000193c  00000000  00000000  00013654  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000010  00000000  00000000  00014f90  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000000d0  00000000  00000000  00014fa0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  00017de2  2**0
                  CONTENTS, READONLY
 17 .cpu          00000004  00000000  00000000  00017de5  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  00017de9  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  00017dea  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  00017deb  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  00017def  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  00017df3  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000004  00000000  00000000  00017df7  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000004  00000000  00000000  00017dfb  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000004  00000000  00000000  00017dff  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000004  00000000  00000000  00017e03  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000036  00000000  00000000  00017e07  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     0008f0ae  00000000  00000000  00017e3d  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00148000 l    d  .entry	00000000 .entry
00148020 l    d  .exceptions	00000000 .exceptions
001481b8 l    d  .text	00000000 .text
0014c98c l    d  .rodata	00000000 .rodata
0014d0f8 l    d  .rwdata	00000000 .rwdata
0014e460 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../osc_bsp//obj/HAL/src/crt0.o
001481f0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00148094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 char57.c
00000000 l    df *ABS*	00000000 keyproc.c
00000000 l    df *ABS*	00000000 lcdout.c
00000000 l    df *ABS*	00000000 mainloop.c
00000000 l    df *ABS*	00000000 menu.c
00000000 l    df *ABS*	00000000 menuact.c
00000000 l    df *ABS*	00000000 stubfncs.c
00000000 l    df *ABS*	00000000 testcode.c
00000000 l    df *ABS*	00000000 tracutil.c
00000000 l    df *ABS*	00000000 obj/default/keyint.o
000fffff l       *ABS*	00000000 SWITCH_ALL
00000008 l       *ABS*	00000000 PIO_IRQ_MASK
0000000c l       *ABS*	00000000 PIO_EDGE_CAP
00000010 l       *ABS*	00000000 PIO_OUTSET
00000014 l       *ABS*	00000000 PIO_OUTCLR
0014d110 l       .rwdata	00000000 adc_speed
0014d116 l       .rwdata	00000000 trig_level
0014d114 l       .rwdata	00000000 trig_delay
0014ad30 l     F .text	00000000 key_handler
0014ad18 l       .text	00000000 key_int_installer_done
0014d100 l       .rwdata	00000000 key_press
0014ad74 l       .text	00000000 loop_keys
0014ad88 l       .text	00000000 key_lookup
0014b264 l       .text	00000000 key_map
0014d101 l       .rwdata	00000000 key_value
0014aeb0 l       .text	00000000 inc_speed
0014ae14 l       .text	00000000 dec_speed
0014afe8 l       .text	00000000 inc_level
0014af54 l       .text	00000000 dec_level
0014b120 l       .text	00000000 inc_delay
0014b090 l       .text	00000000 dec_delay
0014add4 l       .text	00000000 key_lookup_cont
0014adfc l       .text	00000000 key_handler_done
0014af48 l       .text	00000000 set_speed_2
0014ae34 l       .text	00000000 dec_speed_cont
0014af40 l       .text	00000000 set_speed_1
0014aec4 l       .text	00000000 inc_speed_cont
0014b084 l       .text	00000000 set_level_2
0014af6c l       .text	00000000 dec_level_cont
0014b07c l       .text	00000000 set_level_1
0014b000 l       .text	00000000 inc_level_cont
0014b1c0 l       .text	00000000 set_delay_2
0014b0a4 l       .text	00000000 dec_delay_cont
0014b1b4 l       .text	00000000 set_delay_1
0014b138 l       .text	00000000 inc_delay_cont
0014b1e8 l       .text	00000000 key_available_done
0014b24c l       .text	00000000 getkey_done
00000000 l    df *ABS*	00000000 obj/default/testadc.o
000fffff l       *ABS*	00000000 SWITCH_ALL
00000008 l       *ABS*	00000000 PIO_IRQ_MASK
0000000c l       *ABS*	00000000 PIO_EDGE_CAP
00000010 l       *ABS*	00000000 PIO_OUTSET
00000014 l       *ABS*	00000000 PIO_OUTCLR
0014b398 l       .text	00000000 adc_int_installer_done
0014b40c l       .text	00000000 adc_int_handler_clear_front
0014d120 l       .rwdata	00000000 sample_buffer_A
0014b48c l       .text	00000000 adc_int_handler_loop
0014d120 l       .rwdata	00000000 sample_complete
0014b530 l       .text	00000000 adc_int_handler_done
0014b580 l       .text	00000000 draw_trace_loop
0014b5a8 l       .text	00000000 draw_trace_col_loop
0014b618 l       .text	00000000 draw_grid_pt
0014b628 l       .text	00000000 draw_trace_pt
0014b5c8 l       .text	00000000 draw_trace_col_loop_continue
0014b5e8 l       .text	00000000 draw_trace_done
0014b670 l       .text	00000000 draw_grid_horiz
0014b6ec l       .text	00000000 draw_pixel
0014b6ac l       .text	00000000 draw_grid_vert
0014b6bc l       .text	00000000 draw_grid_done
0014b73c l       .text	00000000 draw_pixel_done
0014b780 l       .text	00000000 loop_clr_x
0014b7d0 l       .text	00000000 clear_display_loop
0014b7dc l       .text	00000000 clear_display_done
0014b844 l       .text	00000000 plot_pixel_done
0014b88c l       .text	00000000 set_sample_rate_done
0014b8e8 l       .text	00000000 set_trigger_slope_pos
0014b8f8 l       .text	00000000 set_trigger_done
0014b930 l       .text	00000000 set_delay_done
0014ba08 l       .text	00000000 start_sample_done
0014ba54 l       .text	00000000 sample_null
0014ba58 l       .text	00000000 sample_done_done
0014d300 l       .rwdata	00000000 sample_buffer_Ao
00000000 l    df *ABS*	00000000 obj/default/testdisp.o
0014ba80 l       .text	00000000 disp
0014baa8 l       .text	00000000 draw_top
0014bab4 l       .text	00000000 draw_bot
0014ba8c l       .text	00000000 disp_cont
0014baf0 l       .text	00000000 draw_border
0014bb98 l       .text	00000000 disp_reset
0014bac0 l       .text	00000000 draw_red
0014bacc l       .text	00000000 draw_yellow
0014bad8 l       .text	00000000 draw_green
0014bae4 l       .text	00000000 draw_blue
0014bafc l       .text	00000000 draw_border_top
0014bb0c l       .text	00000000 dbt_loop
0014bb20 l       .text	00000000 draw_border_bot
0014bb38 l       .text	00000000 dbb_loop
0014bb4c l       .text	00000000 draw_border_left
0014bb58 l       .text	00000000 dbl_loop
0014bb6c l       .text	00000000 draw_border_right
0014bb84 l       .text	00000000 dbr_loop
0014bba4 l       .text	00000000 test_disp_done
00000000 l    df *ABS*	00000000 obj/default/testvram.o
0014bc04 l     F .text	00000000 write_all
0014bc30 l     F .text	00000000 read_all
0014bbe4 l       .text	00000000 test_vram_fail
0014bbec l       .text	00000000 test_vram_done
0014bc0c l       .text	00000000 write_all_loop
0014bc2c l       .text	00000000 write_all_done
0014bc24 l       .text	00000000 write_all_reset_cnt
0014bc38 l       .text	00000000 read_all_loop
0014bc5c l       .text	00000000 read_all_done
0014bc54 l       .text	00000000 read_all_reset_cnt
00000000 l    df *ABS*	00000000 lib2-divmod.c
0014bc60 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
0014c1c0 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 alt_close.c
0014c35c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0014c494 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
0014d688 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
0014c2ac g     F .text	0000005c alt_main
0014eae8 g     O .bss	00000100 alt_irq
001496b8 g     F .text	00000048 trg_delay_down
0014daac g       *ABS*	00000000 __flash_rwdata_start
00149184 g     F .text	00000084 display_scale
0014e480 g     O .bss	00000004 cur_scale
00149e5c g     F .text	00000028 trace_rearm
0014ba20 g     F .text	00000000 sample_done
00148f10 g     F .text	00000020 get_trigger_mode
0014cd44 g     O .rodata	00000070 menu
00148e84 g     F .text	00000020 no_menu_action
0014b910 g     F .text	00000000 set_delay
00000000  w      *UND*	00000000 __errno
00148000 g     F .entry	0000000c __reset
00148020 g       *ABS*	00000000 __flash_exceptions_start
001481f4 g     F .text	00000024 no_action
0014e4b0 g     O .bss	00000004 errno
0014e468 g     O .bss	00000004 trigger_mode
001482f8 g     F .text	00000030 menu_right
001493d4 g     F .text	00000048 set_trg_level
0014e4a8 g     O .bss	00000004 alt_argv
00148950 g     F .text	00000064 init_menu
00155a88 g       *ABS*	00000000 _gp
00149dc4 g     F .text	00000020 is_sampling
00120000 g       *ABS*	00000000 __alt_mem_RAM_ctrl
001482c8 g     F .text	00000030 menu_left
0014d508 g     O .rwdata	00000180 alt_fd_list
0014bdb8 g     F .text	00000140 memcpy
0014946c g     F .text	00000054 trg_level_up
0014c98c g       *ABS*	00000000 __DTOR_END__
00148ed0 g     F .text	00000040 set_trigger_mode
0014b7f4 g     F .text	00000000 plot_pixel
00000000  w      *UND*	00000000 malloc
0014bd80 g     F .text	00000008 __udivsi3
0014a670 g     F .text	00000120 restore_trace
00149a50 g     F .text	00000198 cvt_num_field
0014e484 g     O .bss	00000004 trace_status
0014a598 g     F .text	000000d8 set_save_area
0014b948 g     F .text	00000000 start_sample
001490bc g     F .text	00000064 scale_down
0014da9c g     O .rwdata	00000004 alt_max_fd
0014b1c8 g     F .text	00000000 key_available
0014e460 g     O .bss	00000004 menu_entry
00130000 g       *ABS*	00000000 __alt_mem_ROM_ctrl
0014936c g     F .text	00000068 display_sweep
00149eb0 g     F .text	00000404 set_display_scale
0014b548 g     F .text	00000000 draw_trace
0014a790 g     F .text	00000048 do_trace
0014daa4 g     O .rwdata	00000004 _global_impure_ptr
0014ed78 g       *ABS*	00000000 __bss_end
0014c0d0 g     F .text	000000f0 alt_iic_isr_register
00149d28 g     F .text	00000064 init_trace
0014c084 g     F .text	0000004c alt_ic_irq_enabled
00149678 g     F .text	00000040 set_trg_delay
00148298 g     F .text	00000030 menu_down
0014e4a0 g     O .bss	00000004 alt_irq_active
00149be8 g     F .text	00000140 get_test_sample
001480ec g     F .exceptions	000000cc alt_irq_handler
0014d4e0 g     O .rwdata	00000028 alt_dev_null
00148328 g     F .text	000000a8 clear_region
0014c98c g     O .rodata	00000380 char_patterns
0014c478 g     F .text	0000001c alt_dcache_flush_all
00148b70 g     F .text	0000006c previous_entry
0014daac g       *ABS*	00000000 __ram_rwdata_end
0014da94 g     O .rwdata	00000008 alt_dev_list
00149d8c g     F .text	00000038 set_mode
0014b638 g     F .text	00000000 draw_grid
00148db4 g     F .text	000000d0 display_entry
0014d0f8 g       *ABS*	00000000 __ram_rodata_end
0014e488 g     O .bss	00000004 saved_end_y
0014bd88 g     F .text	00000008 __umodsi3
00148ff8 g     F .text	00000084 display_mode
0014e464 g     O .bss	00000004 menu_display
0014ed78 g       *ABS*	00000000 end
00148ea4 g     F .text	0000002c no_display
001494c0 g     F .text	000000a4 display_trg_level
001492e8 g     F .text	00000084 sweep_up
00148aa4 g     F .text	0000005c reset_menu
001489b4 g     F .text	00000038 clear_menu
00149700 g     F .text	0000004c trg_delay_up
0014c98c g       *ABS*	00000000 __CTOR_LIST__
00150000 g       *ABS*	00000000 __alt_stack_pointer
0014ac98 g     F .text	00000000 key_int_installer
0014c7b0 g     F .text	000001a0 __call_exitprocs
001481b8 g     F .text	0000003c _start
0014e46c g     O .bss	00000004 level
0014e48c g     O .bss	00000004 saved_pos_y
001495ac g     F .text	00000054 trg_slope_toggle
0014c33c g     F .text	00000020 alt_sys_init
0014c680 g     F .text	00000130 __register_exitproc
0014bd90 g     F .text	00000028 __mulsi3
0014d0f8 g       *ABS*	00000000 __ram_rwdata_start
0014c98c g       *ABS*	00000000 __ram_rodata_start
0014e490 g     O .bss	00000004 sample_size
0014ce3c g     O .rodata	00000088 sweep_rates
0014b7a4 g     F .text	00000000 clear_display
0014e494 g     O .bss	00000004 saved_end_x
0014b3b0 g     F .text	00000000 adc_int_handler
0014ed78 g       *ABS*	00000000 __alt_stack_base
0014a484 g     F .text	00000114 restore_menu_trace
00149e84 g     F .text	0000002c set_trace_size
001486a0 g     F .text	00000098 plot_string
0014e460 g       *ABS*	00000000 __bss_start
0014e498 g     O .bss	00000004 saved_pos_x
00148738 g     F .text	0000013c main
0014e4ac g     O .bss	00000004 alt_envp
0014974c g     F .text	000000d4 adjust_trg_delay
0014a7d8 g     F .text	000004c0 plot_trace
0014ebe8 g     O .bss	00000190 _atexit0
00149268 g     F .text	00000080 sweep_down
0014daa0 g     O .rwdata	00000004 alt_errno
0014e470 g     O .bss	00000004 sweep
0014b754 g     F .text	00000000 clear_display_x
00148f30 g     F .text	00000064 mode_down
0014b278 g     F .text	00000000 adc_int_installer
0014b85c g     F .text	00000000 set_sample_rate
0014bcd4 g     F .text	00000050 __divsi3
0014b8a4 g     F .text	00000000 set_trigger
0014c98c g       *ABS*	00000000 __CTOR_END__
00148000 g       *ABS*	00000000 __alt_mem_ONCHIP_mem
00148a6c g     F .text	00000038 refresh_menu
0014c98c g       *ABS*	00000000 __flash_rodata_start
0014c98c g       *ABS*	00000000 __DTOR_LIST__
00148268 g     F .text	00000030 menu_up
00148cc8 g     F .text	000000ec menu_entry_right
0014e474 g     O .bss	00000004 delay
0014c308 g     F .text	00000034 alt_irq_init
0014c594 g     F .text	00000080 alt_release_fd
0014c634 g     F .text	00000014 atexit
00149e1c g     F .text	00000040 trace_done
0014daa8 g     O .rwdata	00000004 _impure_ptr
0014e4a4 g     O .bss	00000004 alt_argc
00149564 g     F .text	00000048 set_trg_slope
0014941c g     F .text	00000050 trg_level_down
0014c51c g     F .text	0000005c _do_dtors
0014b200 g     F .text	00000000 getkey
00148528 g     F .text	00000178 plot_char
0014e4b4 g     O .bss	000002a0 saved_menu
00148020 g       .exceptions	00000000 alt_irq_entry
00148bdc g     F .text	000000ec menu_entry_left
0014da8c g     O .rwdata	00000008 alt_fs_list
0014a2b4 g     F .text	000001d0 clear_saved_areas
001483d0 g     F .text	000000ac plot_hline
00148020 g       *ABS*	00000000 __ram_exceptions_start
0014907c g     F .text	00000040 set_scale
0014bef8 g     F .text	00000050 alt_ic_isr_register
0014e754 g     O .bss	00000176 saved_axis_y
0014bba8 g     F .text	00000000 test_vram
0014daac g       *ABS*	00000000 _edata
0014ed78 g       *ABS*	00000000 _end
00148f94 g     F .text	00000064 mode_up
001481b8 g       *ABS*	00000000 __ram_exceptions_end
0014bfe4 g     F .text	000000a0 alt_ic_irq_disable
0014e8ca g     O .bss	0000012c saved_axis_x
0014c614 g     F .text	00000020 altera_nios2_qsys_irq_init
0014c648 g     F .text	00000038 exit
00149820 g     F .text	00000230 display_trg_delay
0014bd24 g     F .text	0000005c __modsi3
0014ba70 g     F .text	00000000 test_disp
00150000 g       *ABS*	00000000 __alt_data_end
00148020 g     F .exceptions	00000000 alt_exception
00149600 g     F .text	00000078 display_trg_slope
0014e9f6 g     O .bss	000000f0 saved_area
0014e49c g     O .bss	00000004 sampling
0014c950 g     F .text	0000003c _exit
00080000 g       *ABS*	00000000 __alt_mem_VRAM_ctrl
0014e478 g     O .bss	00000004 scale
00148874 g     F .text	000000dc key_lookup
0014c578 g     F .text	0000001c alt_icache_flush_all
0014da88 g     O .rwdata	00000004 alt_priority_mask
0014bf48 g     F .text	0000009c alt_ic_irq_enable
0014847c g     F .text	000000ac plot_vline
001489ec g     F .text	00000080 display_menu
0014c4c0 g     F .text	0000005c _do_ctors
00148b00 g     F .text	00000070 next_entry
0014c3ac g     F .text	000000cc close
00149de4 g     F .text	00000038 trace_rdy
0014e47c g     O .bss	00000004 slope
0014c22c g     F .text	00000080 alt_load
00149208 g     F .text	00000060 set_sweep
00149120 g     F .text	00000064 scale_up
00148218 g     F .text	00000050 menu_key
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00148000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  148000:	00400534 	movhi	at,20
    ori r1, r1, %lo(_start)
  148004:	08606e14 	ori	at,at,33208
    jmp r1
  148008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00148020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  148020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  148024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  148028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  14802c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  148030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  148034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  148038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  14803c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  148040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  148044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  148048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  14804c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  148050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  148054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  148058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  14805c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  148060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  148064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  148068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  14806c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  148070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  148074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  148078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  14807c:	10000326 	beq	r2,zero,14808c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  148080:	20000226 	beq	r4,zero,14808c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  148084:	01480ec0 	call	1480ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  148088:	00000306 	br	148098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  14808c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  148090:	e8bfff17 	ldw	r2,-4(ea)

00148094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  148094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  148098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  14809c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1480a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1480a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1480a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1480ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1480b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1480b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1480b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1480bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1480c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1480c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1480c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1480cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1480d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1480d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1480d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1480dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1480e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1480e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1480e8:	ef80083a 	eret

001480ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1480ec:	defff904 	addi	sp,sp,-28
  1480f0:	dfc00615 	stw	ra,24(sp)
  1480f4:	df000515 	stw	fp,20(sp)
  1480f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  1480fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  148100:	0005313a 	rdctl	r2,ipending
  148104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  148108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  14810c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  148110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  148114:	00800044 	movi	r2,1
  148118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  14811c:	e0fffb17 	ldw	r3,-20(fp)
  148120:	e0bffc17 	ldw	r2,-16(fp)
  148124:	1884703a 	and	r2,r3,r2
  148128:	10001726 	beq	r2,zero,148188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  14812c:	00c00574 	movhi	r3,21
  148130:	18faba04 	addi	r3,r3,-5400
  148134:	e0bffd17 	ldw	r2,-12(fp)
  148138:	100490fa 	slli	r2,r2,3
  14813c:	1885883a 	add	r2,r3,r2
  148140:	10c00017 	ldw	r3,0(r2)
  148144:	01000574 	movhi	r4,21
  148148:	213aba04 	addi	r4,r4,-5400
  14814c:	e0bffd17 	ldw	r2,-12(fp)
  148150:	100490fa 	slli	r2,r2,3
  148154:	2085883a 	add	r2,r4,r2
  148158:	10800104 	addi	r2,r2,4
  14815c:	10800017 	ldw	r2,0(r2)
  148160:	1009883a 	mov	r4,r2
  148164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  148168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  14816c:	0005313a 	rdctl	r2,ipending
  148170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  148174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  148178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  14817c:	e0bffb17 	ldw	r2,-20(fp)
  148180:	103fe31e 	bne	r2,zero,148110 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  148184:	00000706 	br	1481a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  148188:	e0bffc17 	ldw	r2,-16(fp)
  14818c:	1085883a 	add	r2,r2,r2
  148190:	e0bffc15 	stw	r2,-16(fp)
      i++;
  148194:	e0bffd17 	ldw	r2,-12(fp)
  148198:	10800044 	addi	r2,r2,1
  14819c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  1481a0:	003fde06 	br	14811c <alt_irq_handler+0x30>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  1481a4:	e037883a 	mov	sp,fp
  1481a8:	dfc00117 	ldw	ra,4(sp)
  1481ac:	df000017 	ldw	fp,0(sp)
  1481b0:	dec00204 	addi	sp,sp,8
  1481b4:	f800283a 	ret

Disassembly of section .text:

001481b8 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  1481b8:	06c00574 	movhi	sp,21
    ori sp, sp, %lo(__alt_stack_pointer)
  1481bc:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  1481c0:	06800574 	movhi	gp,21
    ori gp, gp, %lo(_gp)
  1481c4:	d696a214 	ori	gp,gp,23176
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  1481c8:	00800534 	movhi	r2,20
    ori r2, r2, %lo(__bss_start)
  1481cc:	10b91814 	ori	r2,r2,58464

    movhi r3, %hi(__bss_end)
  1481d0:	00c00534 	movhi	r3,20
    ori r3, r3, %lo(__bss_end)
  1481d4:	18fb5e14 	ori	r3,r3,60792

    beq r2, r3, 1f
  1481d8:	10c00326 	beq	r2,r3,1481e8 <_start+0x30>

0:
    stw zero, (r2)
  1481dc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  1481e0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  1481e4:	10fffd36 	bltu	r2,r3,1481dc <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  1481e8:	014c22c0 	call	14c22c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  1481ec:	014c2ac0 	call	14c2ac <alt_main>

001481f0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  1481f0:	003fff06 	br	1481f0 <alt_after_alt_main>

001481f4 <no_action>:
   Last Modified:    Mar. 8, 1994

*/

enum status  no_action(enum status cur_state)
{
  1481f4:	defffe04 	addi	sp,sp,-8
  1481f8:	df000115 	stw	fp,4(sp)
  1481fc:	df000104 	addi	fp,sp,4
  148200:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* return the current state */
    return  cur_state;
  148204:	e0bfff17 	ldw	r2,-4(fp)

}
  148208:	e037883a 	mov	sp,fp
  14820c:	df000017 	ldw	fp,0(sp)
  148210:	dec00104 	addi	sp,sp,4
  148214:	f800283a 	ret

00148218 <menu_key>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_key(enum status cur_state)
{
  148218:	defffd04 	addi	sp,sp,-12
  14821c:	dfc00215 	stw	ra,8(sp)
  148220:	df000115 	stw	fp,4(sp)
  148224:	df000104 	addi	fp,sp,4
  148228:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* check if need to turn the menu on or off */
    if (cur_state == MENU_ON)
  14822c:	e0bfff17 	ldw	r2,-4(fp)
  148230:	1000021e 	bne	r2,zero,14823c <menu_key+0x24>
        /* currently the menu is on, turn it off */
	clear_menu();
  148234:	01489b40 	call	1489b4 <clear_menu>
  148238:	00000106 	br	148240 <menu_key+0x28>
    else
        /* currently the menu is off, turn it on */
	display_menu();
  14823c:	01489ec0 	call	1489ec <display_menu>


    /* all done, return the "opposite" of the current state */
    if (cur_state == MENU_ON)
  148240:	e0bfff17 	ldw	r2,-4(fp)
  148244:	1000021e 	bne	r2,zero,148250 <menu_key+0x38>
        /* state was MENU_ON, change it to MENU_OFF */
        return  MENU_OFF;
  148248:	00800044 	movi	r2,1
  14824c:	00000106 	br	148254 <menu_key+0x3c>
    else
        /* state was MENU_OFF, change it to MENU_ON */
        return  MENU_ON;
  148250:	0005883a 	mov	r2,zero

}
  148254:	e037883a 	mov	sp,fp
  148258:	dfc00117 	ldw	ra,4(sp)
  14825c:	df000017 	ldw	fp,0(sp)
  148260:	dec00204 	addi	sp,sp,8
  148264:	f800283a 	ret

00148268 <menu_up>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_up(enum status cur_state)
{
  148268:	defffd04 	addi	sp,sp,-12
  14826c:	dfc00215 	stw	ra,8(sp)
  148270:	df000115 	stw	fp,4(sp)
  148274:	df000104 	addi	fp,sp,4
  148278:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the previous menu entry */
    previous_entry();
  14827c:	0148b700 	call	148b70 <previous_entry>


    /* return the current state */
    return  cur_state;
  148280:	e0bfff17 	ldw	r2,-4(fp)

}
  148284:	e037883a 	mov	sp,fp
  148288:	dfc00117 	ldw	ra,4(sp)
  14828c:	df000017 	ldw	fp,0(sp)
  148290:	dec00204 	addi	sp,sp,8
  148294:	f800283a 	ret

00148298 <menu_down>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_down(enum status cur_state)
{
  148298:	defffd04 	addi	sp,sp,-12
  14829c:	dfc00215 	stw	ra,8(sp)
  1482a0:	df000115 	stw	fp,4(sp)
  1482a4:	df000104 	addi	fp,sp,4
  1482a8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the next menu entry */
    next_entry();
  1482ac:	0148b000 	call	148b00 <next_entry>


    /* return the current state */
    return  cur_state;
  1482b0:	e0bfff17 	ldw	r2,-4(fp)

}
  1482b4:	e037883a 	mov	sp,fp
  1482b8:	dfc00117 	ldw	ra,4(sp)
  1482bc:	df000017 	ldw	fp,0(sp)
  1482c0:	dec00204 	addi	sp,sp,8
  1482c4:	f800283a 	ret

001482c8 <menu_left>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_left(enum status cur_state)
{
  1482c8:	defffd04 	addi	sp,sp,-12
  1482cc:	dfc00215 	stw	ra,8(sp)
  1482d0:	df000115 	stw	fp,4(sp)
  1482d4:	df000104 	addi	fp,sp,4
  1482d8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Left> key function for the current menu entry */
    menu_entry_left();
  1482dc:	0148bdc0 	call	148bdc <menu_entry_left>


    /* return the current state */
    return  cur_state;
  1482e0:	e0bfff17 	ldw	r2,-4(fp)

}
  1482e4:	e037883a 	mov	sp,fp
  1482e8:	dfc00117 	ldw	ra,4(sp)
  1482ec:	df000017 	ldw	fp,0(sp)
  1482f0:	dec00204 	addi	sp,sp,8
  1482f4:	f800283a 	ret

001482f8 <menu_right>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_right(enum status cur_state)
{
  1482f8:	defffd04 	addi	sp,sp,-12
  1482fc:	dfc00215 	stw	ra,8(sp)
  148300:	df000115 	stw	fp,4(sp)
  148304:	df000104 	addi	fp,sp,4
  148308:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Right> key function for the current menu entry */
    menu_entry_right();
  14830c:	0148cc80 	call	148cc8 <menu_entry_right>


    /* return the current state */
    return  cur_state;
  148310:	e0bfff17 	ldw	r2,-4(fp)

}
  148314:	e037883a 	mov	sp,fp
  148318:	dfc00117 	ldw	ra,4(sp)
  14831c:	df000017 	ldw	fp,0(sp)
  148320:	dec00204 	addi	sp,sp,8
  148324:	f800283a 	ret

00148328 <clear_region>:
   Last Modified:    Mar. 8, 1994

*/

void  clear_region(int x_ul, int y_ul, int x_size, int y_size)
{
  148328:	defff804 	addi	sp,sp,-32
  14832c:	dfc00715 	stw	ra,28(sp)
  148330:	df000615 	stw	fp,24(sp)
  148334:	df000604 	addi	fp,sp,24
  148338:	e13ffc15 	stw	r4,-16(fp)
  14833c:	e17ffd15 	stw	r5,-12(fp)
  148340:	e1bffe15 	stw	r6,-8(fp)
  148344:	e1ffff15 	stw	r7,-4(fp)
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  148348:	e0bffc17 	ldw	r2,-16(fp)
  14834c:	e0bffa15 	stw	r2,-24(fp)
  148350:	00001406 	br	1483a4 <clear_region+0x7c>
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  148354:	e0bffd17 	ldw	r2,-12(fp)
  148358:	e0bffb15 	stw	r2,-20(fp)
  14835c:	00000906 	br	148384 <clear_region+0x5c>

	    /* clear this pixel */
	    plot_pixel(x, y, PIXEL_BLUE);
  148360:	e0fffa17 	ldw	r3,-24(fp)
  148364:	e0bffb17 	ldw	r2,-20(fp)
  148368:	1809883a 	mov	r4,r3
  14836c:	100b883a 	mov	r5,r2
  148370:	01801f04 	movi	r6,124
  148374:	014b7f40 	call	14b7f4 <plot_pixel>



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  148378:	e0bffb17 	ldw	r2,-20(fp)
  14837c:	10800044 	addi	r2,r2,1
  148380:	e0bffb15 	stw	r2,-20(fp)
  148384:	e0fffd17 	ldw	r3,-12(fp)
  148388:	e0bfff17 	ldw	r2,-4(fp)
  14838c:	1885883a 	add	r2,r3,r2
  148390:	e0fffb17 	ldw	r3,-20(fp)
  148394:	18bff216 	blt	r3,r2,148360 <clear_region+0x38>
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  148398:	e0bffa17 	ldw	r2,-24(fp)
  14839c:	10800044 	addi	r2,r2,1
  1483a0:	e0bffa15 	stw	r2,-24(fp)
  1483a4:	e0fffc17 	ldw	r3,-16(fp)
  1483a8:	e0bffe17 	ldw	r2,-8(fp)
  1483ac:	1885883a 	add	r2,r3,r2
  1483b0:	e0fffa17 	ldw	r3,-24(fp)
  1483b4:	18bfe716 	blt	r3,r2,148354 <clear_region+0x2c>
        }
    }


    /* done clearing the display region - return */
    return;
  1483b8:	0001883a 	nop

}
  1483bc:	e037883a 	mov	sp,fp
  1483c0:	dfc00117 	ldw	ra,4(sp)
  1483c4:	df000017 	ldw	fp,0(sp)
  1483c8:	dec00204 	addi	sp,sp,8
  1483cc:	f800283a 	ret

001483d0 <plot_hline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_hline(int start_x, int start_y, int length)
{
  1483d0:	defff804 	addi	sp,sp,-32
  1483d4:	dfc00715 	stw	ra,28(sp)
  1483d8:	df000615 	stw	fp,24(sp)
  1483dc:	df000604 	addi	fp,sp,24
  1483e0:	e13ffd15 	stw	r4,-12(fp)
  1483e4:	e17ffe15 	stw	r5,-8(fp)
  1483e8:	e1bfff15 	stw	r6,-4(fp)
    int  end_x;		/* ending x position to plot */



    /* check if a line to the "right" or "left" */
    if (length > 0)  {
  1483ec:	e0bfff17 	ldw	r2,-4(fp)
  1483f0:	0080070e 	bge	zero,r2,148410 <plot_hline+0x40>

        /* line to the "right" - start at start_x, end at start_x + length */
	init_x = start_x;
  1483f4:	e0bffd17 	ldw	r2,-12(fp)
  1483f8:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x + length;
  1483fc:	e0fffd17 	ldw	r3,-12(fp)
  148400:	e0bfff17 	ldw	r2,-4(fp)
  148404:	1885883a 	add	r2,r3,r2
  148408:	e0bffc15 	stw	r2,-16(fp)
  14840c:	00000606 	br	148428 <plot_hline+0x58>
    }
    else  {

        /* line to the "left" - start at start_x + length, end at start_x */
	init_x = start_x + length;
  148410:	e0fffd17 	ldw	r3,-12(fp)
  148414:	e0bfff17 	ldw	r2,-4(fp)
  148418:	1885883a 	add	r2,r3,r2
  14841c:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x;
  148420:	e0bffd17 	ldw	r2,-12(fp)
  148424:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  148428:	e0bffb17 	ldw	r2,-20(fp)
  14842c:	e0bffa15 	stw	r2,-24(fp)
  148430:	00000906 	br	148458 <plot_hline+0x88>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_RED);
  148434:	e0fffa17 	ldw	r3,-24(fp)
  148438:	e0bffe17 	ldw	r2,-8(fp)
  14843c:	1809883a 	mov	r4,r3
  148440:	100b883a 	mov	r5,r2
  148444:	0187c004 	movi	r6,7936
  148448:	014b7f40 	call	14b7f4 <plot_pixel>
	end_x = start_x;
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  14844c:	e0bffa17 	ldw	r2,-24(fp)
  148450:	10800044 	addi	r2,r2,1
  148454:	e0bffa15 	stw	r2,-24(fp)
  148458:	e0fffa17 	ldw	r3,-24(fp)
  14845c:	e0bffc17 	ldw	r2,-16(fp)
  148460:	18bff416 	blt	r3,r2,148434 <plot_hline+0x64>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_RED);


    /* done plotting the line - return */
    return;
  148464:	0001883a 	nop

}
  148468:	e037883a 	mov	sp,fp
  14846c:	dfc00117 	ldw	ra,4(sp)
  148470:	df000017 	ldw	fp,0(sp)
  148474:	dec00204 	addi	sp,sp,8
  148478:	f800283a 	ret

0014847c <plot_vline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_vline(int start_x, int start_y, int length)
{
  14847c:	defff804 	addi	sp,sp,-32
  148480:	dfc00715 	stw	ra,28(sp)
  148484:	df000615 	stw	fp,24(sp)
  148488:	df000604 	addi	fp,sp,24
  14848c:	e13ffd15 	stw	r4,-12(fp)
  148490:	e17ffe15 	stw	r5,-8(fp)
  148494:	e1bfff15 	stw	r6,-4(fp)
    int  end_y;		/* ending y position to plot */



    /* check if an "up" or "down" line */
    if (length > 0)  {
  148498:	e0bfff17 	ldw	r2,-4(fp)
  14849c:	0080070e 	bge	zero,r2,1484bc <plot_vline+0x40>

        /* line going "down" - start at start_y, end at start_y + length */
	init_y = start_y;
  1484a0:	e0bffe17 	ldw	r2,-8(fp)
  1484a4:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y + length;
  1484a8:	e0fffe17 	ldw	r3,-8(fp)
  1484ac:	e0bfff17 	ldw	r2,-4(fp)
  1484b0:	1885883a 	add	r2,r3,r2
  1484b4:	e0bffc15 	stw	r2,-16(fp)
  1484b8:	00000606 	br	1484d4 <plot_vline+0x58>
    }
    else  {

        /* line going "up" - start at start_y + length, end at start_y */
	init_y = start_y + length;
  1484bc:	e0fffe17 	ldw	r3,-8(fp)
  1484c0:	e0bfff17 	ldw	r2,-4(fp)
  1484c4:	1885883a 	add	r2,r3,r2
  1484c8:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y;
  1484cc:	e0bffe17 	ldw	r2,-8(fp)
  1484d0:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  1484d4:	e0bffb17 	ldw	r2,-20(fp)
  1484d8:	e0bffa15 	stw	r2,-24(fp)
  1484dc:	00000906 	br	148504 <plot_vline+0x88>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_RED);
  1484e0:	e0fffd17 	ldw	r3,-12(fp)
  1484e4:	e0bffa17 	ldw	r2,-24(fp)
  1484e8:	1809883a 	mov	r4,r3
  1484ec:	100b883a 	mov	r5,r2
  1484f0:	0187c004 	movi	r6,7936
  1484f4:	014b7f40 	call	14b7f4 <plot_pixel>
	end_y = start_y;
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  1484f8:	e0bffa17 	ldw	r2,-24(fp)
  1484fc:	10800044 	addi	r2,r2,1
  148500:	e0bffa15 	stw	r2,-24(fp)
  148504:	e0fffa17 	ldw	r3,-24(fp)
  148508:	e0bffc17 	ldw	r2,-16(fp)
  14850c:	18bff416 	blt	r3,r2,1484e0 <plot_vline+0x64>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_RED);


    /* done plotting the line - return */
    return;
  148510:	0001883a 	nop

}
  148514:	e037883a 	mov	sp,fp
  148518:	dfc00117 	ldw	ra,4(sp)
  14851c:	df000017 	ldw	fp,0(sp)
  148520:	dec00204 	addi	sp,sp,8
  148524:	f800283a 	ret

00148528 <plot_char>:
   Last Modified:    May 27, 2008

*/

void  plot_char(int pos_x, int pos_y, char c, enum char_style style)
{
  148528:	defff504 	addi	sp,sp,-44
  14852c:	dfc00a15 	stw	ra,40(sp)
  148530:	df000915 	stw	fp,36(sp)
  148534:	df000904 	addi	fp,sp,36
  148538:	e13ffc15 	stw	r4,-16(fp)
  14853c:	e17ffd15 	stw	r5,-12(fp)
  148540:	3005883a 	mov	r2,r6
  148544:	e1ffff15 	stw	r7,-4(fp)
  148548:	e0bffe05 	stb	r2,-8(fp)
    int  y;		/* y pixel position for the character */



    /* setup the pixel positions for the character */
    x = pos_x * HORIZ_SIZE;
  14854c:	e13ffc17 	ldw	r4,-16(fp)
  148550:	01400184 	movi	r5,6
  148554:	014bd900 	call	14bd90 <__mulsi3>
  148558:	e0bffb15 	stw	r2,-20(fp)
    y = pos_y * VERT_SIZE;
  14855c:	e0bffd17 	ldw	r2,-12(fp)
  148560:	100490fa 	slli	r2,r2,3
  148564:	e0bffa15 	stw	r2,-24(fp)


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  148568:	e03ff915 	stw	zero,-28(fp)
  14856c:	00004306 	br	14867c <plot_char+0x154>

        /* get the character bits for this row from the character table */
	if (row == (VERT_SIZE - 1))
  148570:	e0bff917 	ldw	r2,-28(fp)
  148574:	108001d8 	cmpnei	r2,r2,7
  148578:	1000021e 	bne	r2,zero,148584 <plot_char+0x5c>
	    /* last row - blank it */
	    bits = 0;
  14857c:	e03ff715 	stw	zero,-36(fp)
  148580:	00000d06 	br	1485b8 <plot_char+0x90>
	else
	    /* in middle of character, get the row from the bit patterns */
            bits = char_patterns[(c * (VERT_SIZE - 1)) + row];
  148584:	e0bffe07 	ldb	r2,-8(fp)
  148588:	1009883a 	mov	r4,r2
  14858c:	014001c4 	movi	r5,7
  148590:	014bd900 	call	14bd90 <__mulsi3>
  148594:	1007883a 	mov	r3,r2
  148598:	e0bff917 	ldw	r2,-28(fp)
  14859c:	1885883a 	add	r2,r3,r2
  1485a0:	00c00574 	movhi	r3,21
  1485a4:	18f26304 	addi	r3,r3,-13940
  1485a8:	1885883a 	add	r2,r3,r2
  1485ac:	10800003 	ldbu	r2,0(r2)
  1485b0:	10803fcc 	andi	r2,r2,255
  1485b4:	e0bff715 	stw	r2,-36(fp)

	/* take care of "normal/reverse video" */
	if (style == REVERSE)
  1485b8:	e0bfff17 	ldw	r2,-4(fp)
  1485bc:	10800058 	cmpnei	r2,r2,1
  1485c0:	1000031e 	bne	r2,zero,1485d0 <plot_char+0xa8>
	    /* invert the bits for "reverse video" */
	    bits = ~bits;
  1485c4:	e0bff717 	ldw	r2,-36(fp)
  1485c8:	0084303a 	nor	r2,zero,r2
  1485cc:	e0bff715 	stw	r2,-36(fp)

        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);
  1485d0:	e0bff717 	ldw	r2,-36(fp)
  1485d4:	1085883a 	add	r2,r2,r2
  1485d8:	1085883a 	add	r2,r2,r2
  1485dc:	e0bff715 	stw	r2,-36(fp)


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  1485e0:	e03ff815 	stw	zero,-32(fp)
  1485e4:	00001c06 	br	148658 <plot_char+0x130>

            /* output this pixel in the appropriate color */
	    if ((bits & 0x80) == 0)
  1485e8:	e0bff717 	ldw	r2,-36(fp)
  1485ec:	1080200c 	andi	r2,r2,128
  1485f0:	10000a1e 	bne	r2,zero,14861c <plot_char+0xf4>
	        /* blank pixel - output in PIXEL_WHITE */
		plot_pixel(x + col, y, PIXEL_BLACK);
  1485f4:	e0fffb17 	ldw	r3,-20(fp)
  1485f8:	e0bff817 	ldw	r2,-32(fp)
  1485fc:	1885883a 	add	r2,r3,r2
  148600:	1007883a 	mov	r3,r2
  148604:	e0bffa17 	ldw	r2,-24(fp)
  148608:	1809883a 	mov	r4,r3
  14860c:	100b883a 	mov	r5,r2
  148610:	000d883a 	mov	r6,zero
  148614:	014b7f40 	call	14b7f4 <plot_pixel>
  148618:	00000906 	br	148640 <plot_char+0x118>
	    else
	        /* black pixel - output in PIXEL_BLACK */
		plot_pixel(x + col, y, PIXEL_GREEN);
  14861c:	e0fffb17 	ldw	r3,-20(fp)
  148620:	e0bff817 	ldw	r2,-32(fp)
  148624:	1885883a 	add	r2,r3,r2
  148628:	1007883a 	mov	r3,r2
  14862c:	e0bffa17 	ldw	r2,-24(fp)
  148630:	1809883a 	mov	r4,r3
  148634:	100b883a 	mov	r5,r2
  148638:	01b800d4 	movui	r6,57347
  14863c:	014b7f40 	call	14b7f4 <plot_pixel>

	    /* shift the next bit into position */
	    bits <<= 1;
  148640:	e0bff717 	ldw	r2,-36(fp)
  148644:	1085883a 	add	r2,r2,r2
  148648:	e0bff715 	stw	r2,-36(fp)
        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  14864c:	e0bff817 	ldw	r2,-32(fp)
  148650:	10800044 	addi	r2,r2,1
  148654:	e0bff815 	stw	r2,-32(fp)
  148658:	e0bff817 	ldw	r2,-32(fp)
  14865c:	10800190 	cmplti	r2,r2,6
  148660:	103fe11e 	bne	r2,zero,1485e8 <plot_char+0xc0>
	    bits <<= 1;
        }


	/* next row - update the y position */
	y++;
  148664:	e0bffa17 	ldw	r2,-24(fp)
  148668:	10800044 	addi	r2,r2,1
  14866c:	e0bffa15 	stw	r2,-24(fp)
    x = pos_x * HORIZ_SIZE;
    y = pos_y * VERT_SIZE;


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  148670:	e0bff917 	ldw	r2,-28(fp)
  148674:	10800044 	addi	r2,r2,1
  148678:	e0bff915 	stw	r2,-28(fp)
  14867c:	e0bff917 	ldw	r2,-28(fp)
  148680:	10800210 	cmplti	r2,r2,8
  148684:	103fba1e 	bne	r2,zero,148570 <plot_char+0x48>
	y++;
    }


    /* all done, return */
    return;
  148688:	0001883a 	nop

}
  14868c:	e037883a 	mov	sp,fp
  148690:	dfc00117 	ldw	ra,4(sp)
  148694:	df000017 	ldw	fp,0(sp)
  148698:	dec00204 	addi	sp,sp,8
  14869c:	f800283a 	ret

001486a0 <plot_string>:
   Last Modified:    Mar. 17, 1997

*/

void  plot_string(int pos_x, int pos_y, const char *s, enum char_style style)
{
  1486a0:	defffa04 	addi	sp,sp,-24
  1486a4:	dfc00515 	stw	ra,20(sp)
  1486a8:	df000415 	stw	fp,16(sp)
  1486ac:	df000404 	addi	fp,sp,16
  1486b0:	e13ffc15 	stw	r4,-16(fp)
  1486b4:	e17ffd15 	stw	r5,-12(fp)
  1486b8:	e1bffe15 	stw	r6,-8(fp)
  1486bc:	e1ffff15 	stw	r7,-4(fp)
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  1486c0:	00001106 	br	148708 <plot_string+0x68>

        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);
  1486c4:	e0fffc17 	ldw	r3,-16(fp)
  1486c8:	e0bffc17 	ldw	r2,-16(fp)
  1486cc:	10800044 	addi	r2,r2,1
  1486d0:	e0bffc15 	stw	r2,-16(fp)
  1486d4:	e0bffe17 	ldw	r2,-8(fp)
  1486d8:	10800003 	ldbu	r2,0(r2)
  1486dc:	10803fcc 	andi	r2,r2,255
  1486e0:	1080201c 	xori	r2,r2,128
  1486e4:	10bfe004 	addi	r2,r2,-128
  1486e8:	e13ffe17 	ldw	r4,-8(fp)
  1486ec:	21000044 	addi	r4,r4,1
  1486f0:	e13ffe15 	stw	r4,-8(fp)
  1486f4:	1809883a 	mov	r4,r3
  1486f8:	e17ffd17 	ldw	r5,-12(fp)
  1486fc:	100d883a 	mov	r6,r2
  148700:	e1ffff17 	ldw	r7,-4(fp)
  148704:	01485280 	call	148528 <plot_char>
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  148708:	e0bffe17 	ldw	r2,-8(fp)
  14870c:	10800003 	ldbu	r2,0(r2)
  148710:	10803fcc 	andi	r2,r2,255
  148714:	1080201c 	xori	r2,r2,128
  148718:	10bfe004 	addi	r2,r2,-128
  14871c:	103fe91e 	bne	r2,zero,1486c4 <plot_string+0x24>
        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);


    /* all done, return */
    return;
  148720:	0001883a 	nop

}
  148724:	e037883a 	mov	sp,fp
  148728:	dfc00117 	ldw	ra,4(sp)
  14872c:	df000017 	ldw	fp,0(sp)
  148730:	dec00204 	addi	sp,sp,8
  148734:	f800283a 	ret

00148738 <main>:

   Author:           Glen George
   Last Modified:    May 27, 2008
*/

int  main() {
  148738:	deffef04 	addi	sp,sp,-68
  14873c:	dfc01015 	stw	ra,64(sp)
  148740:	df000f15 	stw	fp,60(sp)
  148744:	df000f04 	addi	fp,sp,60
    	srampt++;
    	c++;
    	if(c >= 100) c = 0;
    }*/

	key_int_installer();
  148748:	014ac980 	call	14ac98 <key_int_installer>
	adc_int_installer();
  14874c:	014b2780 	call	14b278 <adc_int_installer>
	}*/

	/* variables */
    enum keycode        key;		    /* an input key */

    enum status         state = MENU_ON;    /* current program state */
  148750:	e03ff115 	stw	zero,-60(fp)

    unsigned char      *sample;		    /* a captured trace */

    /* key processing functions (one for each system state type and key) */
    enum status  (* const process_key[NUM_KEYCODES][NUM_STATES])(enum status) =
  148754:	00800574 	movhi	r2,21
  148758:	10a08604 	addi	r2,r2,-32232
  14875c:	e0bff415 	stw	r2,-48(fp)
  148760:	00800574 	movhi	r2,21
  148764:	10a08604 	addi	r2,r2,-32232
  148768:	e0bff515 	stw	r2,-44(fp)
  14876c:	00800574 	movhi	r2,21
  148770:	10a09a04 	addi	r2,r2,-32152
  148774:	e0bff615 	stw	r2,-40(fp)
  148778:	00800574 	movhi	r2,21
  14877c:	10a07d04 	addi	r2,r2,-32268
  148780:	e0bff715 	stw	r2,-36(fp)
  148784:	00800574 	movhi	r2,21
  148788:	10a0a604 	addi	r2,r2,-32104
  14878c:	e0bff815 	stw	r2,-32(fp)
  148790:	00800574 	movhi	r2,21
  148794:	10a07d04 	addi	r2,r2,-32268
  148798:	e0bff915 	stw	r2,-28(fp)
  14879c:	00800574 	movhi	r2,21
  1487a0:	10a0b204 	addi	r2,r2,-32056
  1487a4:	e0bffa15 	stw	r2,-24(fp)
  1487a8:	00800574 	movhi	r2,21
  1487ac:	10a07d04 	addi	r2,r2,-32268
  1487b0:	e0bffb15 	stw	r2,-20(fp)
  1487b4:	00800574 	movhi	r2,21
  1487b8:	10a0be04 	addi	r2,r2,-32008
  1487bc:	e0bffc15 	stw	r2,-16(fp)
  1487c0:	00800574 	movhi	r2,21
  1487c4:	10a07d04 	addi	r2,r2,-32268
  1487c8:	e0bffd15 	stw	r2,-12(fp)
  1487cc:	00800574 	movhi	r2,21
  1487d0:	10a07d04 	addi	r2,r2,-32268
  1487d4:	e0bffe15 	stw	r2,-8(fp)
  1487d8:	00800574 	movhi	r2,21
  1487dc:	10a07d04 	addi	r2,r2,-32268
  1487e0:	e0bfff15 	stw	r2,-4(fp)
        {  no_action,   no_action   } }; /* illegal key */



    /* first initialize everything */
    clear_display();		/* clear the display */
  1487e4:	014b7a40 	call	14b7a4 <clear_display>

    init_trace();		/* initialize the trace routines */
  1487e8:	0149d280 	call	149d28 <init_trace>
    init_menu();		/* initialize the menu system */
  1487ec:	01489500 	call	148950 <init_menu>
  1487f0:	00000106 	br	1487f8 <main+0xc0>
			key = key_lookup();

			//execute processing routine for that key
			state = process_key[key][state](state);
		}
    }
  1487f4:	0001883a 	nop
    // infinite loop processing input
	//int x = 0;
    while(TRUE)  {
    	//x += 1;
		// if ready to do a trace, do it
		if (trace_rdy()) do_trace();
  1487f8:	0149de40 	call	149de4 <trace_rdy>
  1487fc:	10000126 	beq	r2,zero,148804 <main+0xcc>
  148800:	014a7900 	call	14a790 <do_trace>

		//check if have a trace to display
		if (is_sampling() && ((sample = sample_done()) != NULL))  {
  148804:	0149dc40 	call	149dc4 <is_sampling>
  148808:	10000726 	beq	r2,zero,148828 <main+0xf0>
  14880c:	014ba200 	call	14ba20 <sample_done>
  148810:	e0bff215 	stw	r2,-56(fp)
  148814:	e0bff217 	ldw	r2,-56(fp)
  148818:	10000326 	beq	r2,zero,148828 <main+0xf0>

			//have a trace - output it
			plot_trace(sample);
  14881c:	e13ff217 	ldw	r4,-56(fp)
  148820:	014a7d80 	call	14a7d8 <plot_trace>
			//done processing this trace
			trace_done();
  148824:	0149e1c0 	call	149e1c <trace_done>
		}

		//now check for keypad input
		if (key_available())  {
  148828:	014b1c80 	call	14b1c8 <key_available>
  14882c:	10803fcc 	andi	r2,r2,255
  148830:	103ff026 	beq	r2,zero,1487f4 <main+0xbc>

			//have keypad input - get the key
			key = key_lookup();
  148834:	01488740 	call	148874 <key_lookup>
  148838:	e0bff315 	stw	r2,-52(fp)

			//execute processing routine for that key
			state = process_key[key][state](state);
  14883c:	e0bff317 	ldw	r2,-52(fp)
  148840:	1087883a 	add	r3,r2,r2
  148844:	e0bff117 	ldw	r2,-60(fp)
  148848:	1885883a 	add	r2,r3,r2
  14884c:	1085883a 	add	r2,r2,r2
  148850:	1085883a 	add	r2,r2,r2
  148854:	e0fff104 	addi	r3,fp,-60
  148858:	1885883a 	add	r2,r3,r2
  14885c:	10800304 	addi	r2,r2,12
  148860:	10800017 	ldw	r2,0(r2)
  148864:	e13ff117 	ldw	r4,-60(fp)
  148868:	103ee83a 	callr	r2
  14886c:	e0bff115 	stw	r2,-60(fp)
		}
    }
  148870:	003fe006 	br	1487f4 <main+0xbc>

00148874 <key_lookup>:
   Last Modified:    Mar. 17, 1997

*/

enum keycode  	key_lookup()
{
  148874:	defff104 	addi	sp,sp,-60
  148878:	dfc00e15 	stw	ra,56(sp)
  14887c:	df000d15 	stw	fp,52(sp)
  148880:	df000d04 	addi	fp,sp,52
    /* variables */

    const enum keycode  keycodes[] = /* array of keycodes */
  148884:	e03ff515 	stw	zero,-44(fp)
  148888:	00800044 	movi	r2,1
  14888c:	e0bff615 	stw	r2,-40(fp)
  148890:	00800084 	movi	r2,2
  148894:	e0bff715 	stw	r2,-36(fp)
  148898:	008000c4 	movi	r2,3
  14889c:	e0bff815 	stw	r2,-32(fp)
  1488a0:	00800104 	movi	r2,4
  1488a4:	e0bff915 	stw	r2,-28(fp)
  1488a8:	00800144 	movi	r2,5
  1488ac:	e0bffa15 	stw	r2,-24(fp)
           KEYCODE_LEFT,      /* <Left>     */
           KEYCODE_RIGHT,     /* <Right>    */
           KEYCODE_ILLEGAL    /* other keys */
        }; 

    const int  keys[] =   /* array of key values */
  1488b0:	e03ffb15 	stw	zero,-20(fp)
  1488b4:	00800044 	movi	r2,1
  1488b8:	e0bffc15 	stw	r2,-16(fp)
  1488bc:	00800084 	movi	r2,2
  1488c0:	e0bffd15 	stw	r2,-12(fp)
  1488c4:	008000c4 	movi	r2,3
  1488c8:	e0bffe15 	stw	r2,-8(fp)
  1488cc:	00800104 	movi	r2,4
  1488d0:	e0bfff15 	stw	r2,-4(fp)
    int  i;           	/* general loop index */



    /* get a key */
    key = getkey();
  1488d4:	014b2000 	call	14b200 <getkey>
  1488d8:	e0bff415 	stw	r2,-48(fp)


    /* lookup key in keys array */
    for (i = 0; ((i < (sizeof(keys)/sizeof(int))) && (key != keys[i])); i++);
  1488dc:	e03ff315 	stw	zero,-52(fp)
  1488e0:	00000306 	br	1488f0 <key_lookup+0x7c>
  1488e4:	e0bff317 	ldw	r2,-52(fp)
  1488e8:	10800044 	addi	r2,r2,1
  1488ec:	e0bff315 	stw	r2,-52(fp)
  1488f0:	e0bff317 	ldw	r2,-52(fp)
  1488f4:	10800168 	cmpgeui	r2,r2,5
  1488f8:	1000091e 	bne	r2,zero,148920 <key_lookup+0xac>
  1488fc:	e0bff317 	ldw	r2,-52(fp)
  148900:	1085883a 	add	r2,r2,r2
  148904:	1085883a 	add	r2,r2,r2
  148908:	e0fff304 	addi	r3,fp,-52
  14890c:	1885883a 	add	r2,r3,r2
  148910:	10800804 	addi	r2,r2,32
  148914:	10c00017 	ldw	r3,0(r2)
  148918:	e0bff417 	ldw	r2,-48(fp)
  14891c:	18bff11e 	bne	r3,r2,1488e4 <key_lookup+0x70>


    /* return the appropriate key type */
    return  keycodes[i];
  148920:	e0bff317 	ldw	r2,-52(fp)
  148924:	1085883a 	add	r2,r2,r2
  148928:	1085883a 	add	r2,r2,r2
  14892c:	e0fff304 	addi	r3,fp,-52
  148930:	1885883a 	add	r2,r3,r2
  148934:	10800204 	addi	r2,r2,8
  148938:	10800017 	ldw	r2,0(r2)

}
  14893c:	e037883a 	mov	sp,fp
  148940:	dfc00117 	ldw	ra,4(sp)
  148944:	df000017 	ldw	fp,0(sp)
  148948:	dec00204 	addi	sp,sp,8
  14894c:	f800283a 	ret

00148950 <init_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  init_menu(void)
{
  148950:	defffe04 	addi	sp,sp,-8
  148954:	dfc00115 	stw	ra,4(sp)
  148958:	df000015 	stw	fp,0(sp)
  14895c:	d839883a 	mov	fp,sp
      /* none */



    /* set the menu parameters */
    menu_entry = 0;		/* first menu entry */
  148960:	d0227615 	stw	zero,-30248(gp)
    menu_display = FALSE;	/* menu is not currently displayed (but it will be shortly) */
  148964:	d0227715 	stw	zero,-30244(gp)


    /* set the scope (option) parameters */
    set_trigger_mode(NORMAL_TRIGGER);	/* normal triggering */
  148968:	0009883a 	mov	r4,zero
  14896c:	0148ed00 	call	148ed0 <set_trigger_mode>
    set_scale(SCALE_AXES);		/* scale is axes */
  148970:	01000044 	movi	r4,1
  148974:	014907c0 	call	14907c <set_scale>
    set_sweep(0);			/* first sweep rate */
  148978:	0009883a 	mov	r4,zero
  14897c:	01492080 	call	149208 <set_sweep>
    set_trg_level((MIN_TRG_LEVEL_SET + MAX_TRG_LEVEL_SET) / 2);	/* middle trigger level */
  148980:	01000fc4 	movi	r4,63
  148984:	01493d40 	call	1493d4 <set_trg_level>
    set_trg_slope(SLOPE_POSITIVE);	/* positive slope */
  148988:	0009883a 	mov	r4,zero
  14898c:	01495640 	call	149564 <set_trg_slope>
    set_trg_delay(MIN_DELAY);		/* minimum delay */
  148990:	0009883a 	mov	r4,zero
  148994:	01496780 	call	149678 <set_trg_delay>


    /* now display the menu */
    display_menu();
  148998:	01489ec0 	call	1489ec <display_menu>


    /* done initializing, return */
    return;
  14899c:	0001883a 	nop

}
  1489a0:	e037883a 	mov	sp,fp
  1489a4:	dfc00117 	ldw	ra,4(sp)
  1489a8:	df000017 	ldw	fp,0(sp)
  1489ac:	dec00204 	addi	sp,sp,8
  1489b0:	f800283a 	ret

001489b4 <clear_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  clear_menu(void)
{
  1489b4:	defffe04 	addi	sp,sp,-8
  1489b8:	dfc00115 	stw	ra,4(sp)
  1489bc:	df000015 	stw	fp,0(sp)
  1489c0:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  1489c4:	d0a27717 	ldw	r2,-30244(gp)
  1489c8:	10000126 	beq	r2,zero,1489d0 <clear_menu+0x1c>

        /* menu is being displayed - turn it off and restore the trace in that area */
	restore_menu_trace();
  1489cc:	014a4840 	call	14a484 <restore_menu_trace>
    }


    /* no longer displaying the menu */
    menu_display = FALSE;
  1489d0:	d0227715 	stw	zero,-30244(gp)


    /* all done, return */
    return;
  1489d4:	0001883a 	nop

}
  1489d8:	e037883a 	mov	sp,fp
  1489dc:	dfc00117 	ldw	ra,4(sp)
  1489e0:	df000017 	ldw	fp,0(sp)
  1489e4:	dec00204 	addi	sp,sp,8
  1489e8:	f800283a 	ret

001489ec <display_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  display_menu(void)
{
  1489ec:	defffd04 	addi	sp,sp,-12
  1489f0:	dfc00215 	stw	ra,8(sp)
  1489f4:	df000115 	stw	fp,4(sp)
  1489f8:	df000104 	addi	fp,sp,4
    int  i;		/* loop index */



    /* check if the menu is currently being displayed */
    if (!menu_display)  {
  1489fc:	d0a27717 	ldw	r2,-30244(gp)
  148a00:	1000121e 	bne	r2,zero,148a4c <display_menu+0x60>

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  148a04:	e03fff15 	stw	zero,-4(fp)
  148a08:	00000d06 	br	148a40 <display_menu+0x54>

	    /* display this entry - check if it should be highlighted */
	    if (i == menu_entry)
  148a0c:	d0a27617 	ldw	r2,-30248(gp)
  148a10:	e0ffff17 	ldw	r3,-4(fp)
  148a14:	1880041e 	bne	r3,r2,148a28 <display_menu+0x3c>
	        /* currently selected entry - highlight it */
	        display_entry(i, TRUE);
  148a18:	e13fff17 	ldw	r4,-4(fp)
  148a1c:	01400044 	movi	r5,1
  148a20:	0148db40 	call	148db4 <display_entry>
  148a24:	00000306 	br	148a34 <display_menu+0x48>
	    else
	        /* not the currently selected entry - "normal video" */
	        display_entry(i, FALSE);
  148a28:	e13fff17 	ldw	r4,-4(fp)
  148a2c:	000b883a 	mov	r5,zero
  148a30:	0148db40 	call	148db4 <display_entry>
    /* check if the menu is currently being displayed */
    if (!menu_display)  {

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  148a34:	e0bfff17 	ldw	r2,-4(fp)
  148a38:	10800044 	addi	r2,r2,1
  148a3c:	e0bfff15 	stw	r2,-4(fp)
  148a40:	e0bfff17 	ldw	r2,-4(fp)
  148a44:	108001f0 	cmpltui	r2,r2,7
  148a48:	103ff01e 	bne	r2,zero,148a0c <display_menu+0x20>
        }
    }


    /* now are displaying the menu */
    menu_display = TRUE;
  148a4c:	00800044 	movi	r2,1
  148a50:	d0a27715 	stw	r2,-30244(gp)


    /* all done, return */
    return;
  148a54:	0001883a 	nop

}
  148a58:	e037883a 	mov	sp,fp
  148a5c:	dfc00117 	ldw	ra,4(sp)
  148a60:	df000017 	ldw	fp,0(sp)
  148a64:	dec00204 	addi	sp,sp,8
  148a68:	f800283a 	ret

00148a6c <refresh_menu>:
   Last Modified:    Mar. 8, 1994

*/

void  refresh_menu(void)
{
  148a6c:	defffe04 	addi	sp,sp,-8
  148a70:	dfc00115 	stw	ra,4(sp)
  148a74:	df000015 	stw	fp,0(sp)
  148a78:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  148a7c:	d0a27717 	ldw	r2,-30244(gp)
  148a80:	10000226 	beq	r2,zero,148a8c <refresh_menu+0x20>

    	/* menu is currently being displayed - need to refresh it */
	/* do this by turning off the display, then forcing it back on */
	menu_display = FALSE;
  148a84:	d0227715 	stw	zero,-30244(gp)
	display_menu();
  148a88:	01489ec0 	call	1489ec <display_menu>
    }


    /* refreshed the menu if it was displayed, now return */
    return;
  148a8c:	0001883a 	nop

}
  148a90:	e037883a 	mov	sp,fp
  148a94:	dfc00117 	ldw	ra,4(sp)
  148a98:	df000017 	ldw	fp,0(sp)
  148a9c:	dec00204 	addi	sp,sp,8
  148aa0:	f800283a 	ret

00148aa4 <reset_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  reset_menu(void)
{
  148aa4:	defffe04 	addi	sp,sp,-8
  148aa8:	dfc00115 	stw	ra,4(sp)
  148aac:	df000015 	stw	fp,0(sp)
  148ab0:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  148ab4:	d0a27717 	ldw	r2,-30244(gp)
  148ab8:	10000426 	beq	r2,zero,148acc <reset_menu+0x28>

        /* menu is being displayed */
	/* remove highlight from currently selected entry */
	display_entry(menu_entry, FALSE);
  148abc:	d0a27617 	ldw	r2,-30248(gp)
  148ac0:	1009883a 	mov	r4,r2
  148ac4:	000b883a 	mov	r5,zero
  148ac8:	0148db40 	call	148db4 <display_entry>
    }


    /* reset the currently selected entry */
    menu_entry = 0;
  148acc:	d0227615 	stw	zero,-30248(gp)


    /* finally, highlight the first entry if the menu is being displayed */
    if (menu_display)
  148ad0:	d0a27717 	ldw	r2,-30244(gp)
  148ad4:	10000426 	beq	r2,zero,148ae8 <reset_menu+0x44>
	display_entry(menu_entry, TRUE);
  148ad8:	d0a27617 	ldw	r2,-30248(gp)
  148adc:	1009883a 	mov	r4,r2
  148ae0:	01400044 	movi	r5,1
  148ae4:	0148db40 	call	148db4 <display_entry>



    /* all done, return */
    return;
  148ae8:	0001883a 	nop

}
  148aec:	e037883a 	mov	sp,fp
  148af0:	dfc00117 	ldw	ra,4(sp)
  148af4:	df000017 	ldw	fp,0(sp)
  148af8:	dec00204 	addi	sp,sp,8
  148afc:	f800283a 	ret

00148b00 <next_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  next_entry(void)
{
  148b00:	defffe04 	addi	sp,sp,-8
  148b04:	dfc00115 	stw	ra,4(sp)
  148b08:	df000015 	stw	fp,0(sp)
  148b0c:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at end of the menu */
    if (menu_entry < (NO_MENU_ENTRIES - 1))  {
  148b10:	d0a27617 	ldw	r2,-30248(gp)
  148b14:	108001a8 	cmpgeui	r2,r2,6
  148b18:	10000f1e 	bne	r2,zero,148b58 <next_entry+0x58>

        /* not at the end of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  148b1c:	d0a27717 	ldw	r2,-30244(gp)
  148b20:	10000426 	beq	r2,zero,148b34 <next_entry+0x34>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  148b24:	d0a27617 	ldw	r2,-30248(gp)
  148b28:	1009883a 	mov	r4,r2
  148b2c:	000b883a 	mov	r5,zero
  148b30:	0148db40 	call	148db4 <display_entry>

	/* update the menu entry to the next one */
	menu_entry++;
  148b34:	d0a27617 	ldw	r2,-30248(gp)
  148b38:	10800044 	addi	r2,r2,1
  148b3c:	d0a27615 	stw	r2,-30248(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  148b40:	d0a27717 	ldw	r2,-30244(gp)
  148b44:	10000426 	beq	r2,zero,148b58 <next_entry+0x58>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  148b48:	d0a27617 	ldw	r2,-30248(gp)
  148b4c:	1009883a 	mov	r4,r2
  148b50:	01400044 	movi	r5,1
  148b54:	0148db40 	call	148db4 <display_entry>
    }


    /* all done, return */
    return;
  148b58:	0001883a 	nop

}
  148b5c:	e037883a 	mov	sp,fp
  148b60:	dfc00117 	ldw	ra,4(sp)
  148b64:	df000017 	ldw	fp,0(sp)
  148b68:	dec00204 	addi	sp,sp,8
  148b6c:	f800283a 	ret

00148b70 <previous_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  previous_entry(void)
{
  148b70:	defffe04 	addi	sp,sp,-8
  148b74:	dfc00115 	stw	ra,4(sp)
  148b78:	df000015 	stw	fp,0(sp)
  148b7c:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at the start of the menu */
    if (menu_entry > 0)  {
  148b80:	d0a27617 	ldw	r2,-30248(gp)
  148b84:	00800f0e 	bge	zero,r2,148bc4 <previous_entry+0x54>

        /* not at the start of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  148b88:	d0a27717 	ldw	r2,-30244(gp)
  148b8c:	10000426 	beq	r2,zero,148ba0 <previous_entry+0x30>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  148b90:	d0a27617 	ldw	r2,-30248(gp)
  148b94:	1009883a 	mov	r4,r2
  148b98:	000b883a 	mov	r5,zero
  148b9c:	0148db40 	call	148db4 <display_entry>

	/* update the menu entry to the previous one */
	menu_entry--;
  148ba0:	d0a27617 	ldw	r2,-30248(gp)
  148ba4:	10bfffc4 	addi	r2,r2,-1
  148ba8:	d0a27615 	stw	r2,-30248(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  148bac:	d0a27717 	ldw	r2,-30244(gp)
  148bb0:	10000426 	beq	r2,zero,148bc4 <previous_entry+0x54>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  148bb4:	d0a27617 	ldw	r2,-30248(gp)
  148bb8:	1009883a 	mov	r4,r2
  148bbc:	01400044 	movi	r5,1
  148bc0:	0148db40 	call	148db4 <display_entry>

    }


    /* all done, return */
    return;
  148bc4:	0001883a 	nop

}
  148bc8:	e037883a 	mov	sp,fp
  148bcc:	dfc00117 	ldw	ra,4(sp)
  148bd0:	df000017 	ldw	fp,0(sp)
  148bd4:	dec00204 	addi	sp,sp,8
  148bd8:	f800283a 	ret

00148bdc <menu_entry_left>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_left(void)
{
  148bdc:	defff704 	addi	sp,sp,-36
  148be0:	dfc00815 	stw	ra,32(sp)
  148be4:	df000715 	stw	fp,28(sp)
  148be8:	df000704 	addi	fp,sp,28
    /* variables */

    /* key processing functions */
    void  (* const process[])(void) =
  148bec:	00800574 	movhi	r2,21
  148bf0:	10a3cc04 	addi	r2,r2,-28880
  148bf4:	e0bff915 	stw	r2,-28(fp)
  148bf8:	00800574 	movhi	r2,21
  148bfc:	10a42f04 	addi	r2,r2,-28484
  148c00:	e0bffa15 	stw	r2,-24(fp)
  148c04:	00800574 	movhi	r2,21
  148c08:	10a49a04 	addi	r2,r2,-28056
  148c0c:	e0bffb15 	stw	r2,-20(fp)
  148c10:	00800574 	movhi	r2,21
  148c14:	10a79704 	addi	r2,r2,-24996
  148c18:	e0bffc15 	stw	r2,-16(fp)
  148c1c:	00800574 	movhi	r2,21
  148c20:	10a50704 	addi	r2,r2,-27620
  148c24:	e0bffd15 	stw	r2,-12(fp)
  148c28:	00800574 	movhi	r2,21
  148c2c:	10a56b04 	addi	r2,r2,-27220
  148c30:	e0bffe15 	stw	r2,-8(fp)
  148c34:	00800574 	movhi	r2,21
  148c38:	10a5ae04 	addi	r2,r2,-26952
  148c3c:	e0bfff15 	stw	r2,-4(fp)
       /*  Level           Slope             Delay                        */



    /* invoke the appropriate <Left> key function */
    process[menu_entry]();
  148c40:	d0a27617 	ldw	r2,-30248(gp)
  148c44:	1085883a 	add	r2,r2,r2
  148c48:	1085883a 	add	r2,r2,r2
  148c4c:	e0fff904 	addi	r3,fp,-28
  148c50:	1885883a 	add	r2,r3,r2
  148c54:	10800017 	ldw	r2,0(r2)
  148c58:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  148c5c:	d0a27717 	ldw	r2,-30244(gp)
  148c60:	10001426 	beq	r2,zero,148cb4 <menu_entry_left+0xd8>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  148c64:	d0a27617 	ldw	r2,-30248(gp)
  148c68:	00c00574 	movhi	r3,21
  148c6c:	18f35104 	addi	r3,r3,-12988
  148c70:	1004913a 	slli	r2,r2,4
  148c74:	1885883a 	add	r2,r3,r2
  148c78:	10800304 	addi	r2,r2,12
  148c7c:	11c00017 	ldw	r7,0(r2)
  148c80:	d0a27617 	ldw	r2,-30248(gp)
  148c84:	00c00574 	movhi	r3,21
  148c88:	18f35104 	addi	r3,r3,-12988
  148c8c:	1004913a 	slli	r2,r2,4
  148c90:	1885883a 	add	r2,r3,r2
  148c94:	10800204 	addi	r2,r2,8
  148c98:	10800017 	ldw	r2,0(r2)
  148c9c:	10c00fc4 	addi	r3,r2,63
  148ca0:	d0a27617 	ldw	r2,-30248(gp)
  148ca4:	1809883a 	mov	r4,r3
  148ca8:	100b883a 	mov	r5,r2
  148cac:	000d883a 	mov	r6,zero
  148cb0:	383ee83a 	callr	r7


    /* all done, return */
    return;

}
  148cb4:	e037883a 	mov	sp,fp
  148cb8:	dfc00117 	ldw	ra,4(sp)
  148cbc:	df000017 	ldw	fp,0(sp)
  148cc0:	dec00204 	addi	sp,sp,8
  148cc4:	f800283a 	ret

00148cc8 <menu_entry_right>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_right(void)
{
  148cc8:	defff704 	addi	sp,sp,-36
  148ccc:	dfc00815 	stw	ra,32(sp)
  148cd0:	df000715 	stw	fp,28(sp)
  148cd4:	df000704 	addi	fp,sp,28
    /* variables */

    /* key processing functions */
    void  (* const process[])(void) =
  148cd8:	00800574 	movhi	r2,21
  148cdc:	10a3e504 	addi	r2,r2,-28780
  148ce0:	e0bff915 	stw	r2,-28(fp)
  148ce4:	00800574 	movhi	r2,21
  148ce8:	10a44804 	addi	r2,r2,-28384
  148cec:	e0bffa15 	stw	r2,-24(fp)
  148cf0:	00800574 	movhi	r2,21
  148cf4:	10a4ba04 	addi	r2,r2,-27928
  148cf8:	e0bffb15 	stw	r2,-20(fp)
  148cfc:	00800574 	movhi	r2,21
  148d00:	10a79704 	addi	r2,r2,-24996
  148d04:	e0bffc15 	stw	r2,-16(fp)
  148d08:	00800574 	movhi	r2,21
  148d0c:	10a51b04 	addi	r2,r2,-27540
  148d10:	e0bffd15 	stw	r2,-12(fp)
  148d14:	00800574 	movhi	r2,21
  148d18:	10a56b04 	addi	r2,r2,-27220
  148d1c:	e0bffe15 	stw	r2,-8(fp)
  148d20:	00800574 	movhi	r2,21
  148d24:	10a5c004 	addi	r2,r2,-26880
  148d28:	e0bfff15 	stw	r2,-4(fp)
       /*  Level         Slope             Delay                        */



    /* invoke the appropriate <Right> key function */
    process[menu_entry]();
  148d2c:	d0a27617 	ldw	r2,-30248(gp)
  148d30:	1085883a 	add	r2,r2,r2
  148d34:	1085883a 	add	r2,r2,r2
  148d38:	e0fff904 	addi	r3,fp,-28
  148d3c:	1885883a 	add	r2,r3,r2
  148d40:	10800017 	ldw	r2,0(r2)
  148d44:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  148d48:	d0a27717 	ldw	r2,-30244(gp)
  148d4c:	10001426 	beq	r2,zero,148da0 <menu_entry_right+0xd8>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  148d50:	d0a27617 	ldw	r2,-30248(gp)
  148d54:	00c00574 	movhi	r3,21
  148d58:	18f35104 	addi	r3,r3,-12988
  148d5c:	1004913a 	slli	r2,r2,4
  148d60:	1885883a 	add	r2,r3,r2
  148d64:	10800304 	addi	r2,r2,12
  148d68:	11c00017 	ldw	r7,0(r2)
  148d6c:	d0a27617 	ldw	r2,-30248(gp)
  148d70:	00c00574 	movhi	r3,21
  148d74:	18f35104 	addi	r3,r3,-12988
  148d78:	1004913a 	slli	r2,r2,4
  148d7c:	1885883a 	add	r2,r3,r2
  148d80:	10800204 	addi	r2,r2,8
  148d84:	10800017 	ldw	r2,0(r2)
  148d88:	10c00fc4 	addi	r3,r2,63
  148d8c:	d0a27617 	ldw	r2,-30248(gp)
  148d90:	1809883a 	mov	r4,r3
  148d94:	100b883a 	mov	r5,r2
  148d98:	000d883a 	mov	r6,zero
  148d9c:	383ee83a 	callr	r7


    /* all done, return */
    return;

}
  148da0:	e037883a 	mov	sp,fp
  148da4:	dfc00117 	ldw	ra,4(sp)
  148da8:	df000017 	ldw	fp,0(sp)
  148dac:	dec00204 	addi	sp,sp,8
  148db0:	f800283a 	ret

00148db4 <display_entry>:
   Last Modified:    Aug. 13, 2004

*/

void  display_entry(int entry, int selected)
{
  148db4:	defffc04 	addi	sp,sp,-16
  148db8:	dfc00315 	stw	ra,12(sp)
  148dbc:	df000215 	stw	fp,8(sp)
  148dc0:	df000204 	addi	fp,sp,8
  148dc4:	e13ffe15 	stw	r4,-8(fp)
  148dc8:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* output the menu entry with the appropriate color */
    plot_string((MENU_X + menu[entry].h_off), (MENU_Y + entry), menu[entry].s,
  148dcc:	00c00574 	movhi	r3,21
  148dd0:	18f35104 	addi	r3,r3,-12988
  148dd4:	e0bffe17 	ldw	r2,-8(fp)
  148dd8:	1004913a 	slli	r2,r2,4
  148ddc:	1885883a 	add	r2,r3,r2
  148de0:	10800104 	addi	r2,r2,4
  148de4:	10800017 	ldw	r2,0(r2)
  148de8:	11000fc4 	addi	r4,r2,63
  148dec:	00c00574 	movhi	r3,21
  148df0:	18f35104 	addi	r3,r3,-12988
  148df4:	e0bffe17 	ldw	r2,-8(fp)
  148df8:	1004913a 	slli	r2,r2,4
  148dfc:	1885883a 	add	r2,r3,r2
  148e00:	10c00017 	ldw	r3,0(r2)
  148e04:	e0bfff17 	ldw	r2,-4(fp)
  148e08:	1004c03a 	cmpne	r2,r2,zero
  148e0c:	10803fcc 	andi	r2,r2,255
  148e10:	e17ffe17 	ldw	r5,-8(fp)
  148e14:	180d883a 	mov	r6,r3
  148e18:	100f883a 	mov	r7,r2
  148e1c:	01486a00 	call	1486a0 <plot_string>
    		(selected ? SELECTED : NORMAL));
    /* also output the menu option with the appropriate color */
    menu[entry].display((MENU_X + menu[entry].opt_off), (MENU_Y + entry),
  148e20:	00c00574 	movhi	r3,21
  148e24:	18f35104 	addi	r3,r3,-12988
  148e28:	e0bffe17 	ldw	r2,-8(fp)
  148e2c:	1004913a 	slli	r2,r2,4
  148e30:	1885883a 	add	r2,r3,r2
  148e34:	10800304 	addi	r2,r2,12
  148e38:	10c00017 	ldw	r3,0(r2)
  148e3c:	01000574 	movhi	r4,21
  148e40:	21335104 	addi	r4,r4,-12988
  148e44:	e0bffe17 	ldw	r2,-8(fp)
  148e48:	1004913a 	slli	r2,r2,4
  148e4c:	2085883a 	add	r2,r4,r2
  148e50:	10800204 	addi	r2,r2,8
  148e54:	10800017 	ldw	r2,0(r2)
  148e58:	10800fc4 	addi	r2,r2,63
  148e5c:	1009883a 	mov	r4,r2
  148e60:	e17ffe17 	ldw	r5,-8(fp)
  148e64:	000d883a 	mov	r6,zero
  148e68:	183ee83a 	callr	r3
    			(selected ? OPTION_SELECTED : OPTION_NORMAL));


    /* all done outputting this menu entry - return */
    return;
  148e6c:	0001883a 	nop

}
  148e70:	e037883a 	mov	sp,fp
  148e74:	dfc00117 	ldw	ra,4(sp)
  148e78:	df000017 	ldw	fp,0(sp)
  148e7c:	dec00204 	addi	sp,sp,8
  148e80:	f800283a 	ret

00148e84 <no_menu_action>:
   Last Modified:    Mar. 8, 1994

*/

void  no_menu_action()
{
  148e84:	deffff04 	addi	sp,sp,-4
  148e88:	df000015 	stw	fp,0(sp)
  148e8c:	d839883a 	mov	fp,sp
      /* none */



    /* nothing to do - return */
    return;
  148e90:	0001883a 	nop

}
  148e94:	e037883a 	mov	sp,fp
  148e98:	df000017 	ldw	fp,0(sp)
  148e9c:	dec00104 	addi	sp,sp,4
  148ea0:	f800283a 	ret

00148ea4 <no_display>:
   Last Modified:    Mar. 8, 1994

*/

void  no_display(int x_pos, int y_pos, int style)
{
  148ea4:	defffc04 	addi	sp,sp,-16
  148ea8:	df000315 	stw	fp,12(sp)
  148eac:	df000304 	addi	fp,sp,12
  148eb0:	e13ffd15 	stw	r4,-12(fp)
  148eb4:	e17ffe15 	stw	r5,-8(fp)
  148eb8:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* nothing to do - return */
    return;
  148ebc:	0001883a 	nop

}
  148ec0:	e037883a 	mov	sp,fp
  148ec4:	df000017 	ldw	fp,0(sp)
  148ec8:	dec00104 	addi	sp,sp,4
  148ecc:	f800283a 	ret

00148ed0 <set_trigger_mode>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trigger_mode(enum trigger_type m)
{
  148ed0:	defffd04 	addi	sp,sp,-12
  148ed4:	dfc00215 	stw	ra,8(sp)
  148ed8:	df000115 	stw	fp,4(sp)
  148edc:	df000104 	addi	fp,sp,4
  148ee0:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger mode */
    trigger_mode = m;
  148ee4:	e0bfff17 	ldw	r2,-4(fp)
  148ee8:	d0a27815 	stw	r2,-30240(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  148eec:	d0a27817 	ldw	r2,-30240(gp)
  148ef0:	1009883a 	mov	r4,r2
  148ef4:	0149d8c0 	call	149d8c <set_mode>


    /* all done setting the trigger mode - return */
    return;
  148ef8:	0001883a 	nop

}
  148efc:	e037883a 	mov	sp,fp
  148f00:	dfc00117 	ldw	ra,4(sp)
  148f04:	df000017 	ldw	fp,0(sp)
  148f08:	dec00204 	addi	sp,sp,8
  148f0c:	f800283a 	ret

00148f10 <get_trigger_mode>:
   Last Modified:    May 9, 2006

*/

enum trigger_type  get_trigger_mode()
{
  148f10:	deffff04 	addi	sp,sp,-4
  148f14:	df000015 	stw	fp,0(sp)
  148f18:	d839883a 	mov	fp,sp
      /* none */



    /* return the current trigger mode */
    return  trigger_mode;
  148f1c:	d0a27817 	ldw	r2,-30240(gp)

}
  148f20:	e037883a 	mov	sp,fp
  148f24:	df000017 	ldw	fp,0(sp)
  148f28:	dec00104 	addi	sp,sp,4
  148f2c:	f800283a 	ret

00148f30 <mode_down>:
   Last Modified:    May 9, 2006

*/

void  mode_down()
{
  148f30:	defffe04 	addi	sp,sp,-8
  148f34:	dfc00115 	stw	ra,4(sp)
  148f38:	df000015 	stw	fp,0(sp)
  148f3c:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "next" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  148f40:	d0a27817 	ldw	r2,-30240(gp)
  148f44:	1000031e 	bne	r2,zero,148f54 <mode_down+0x24>
        trigger_mode = AUTO_TRIGGER;
  148f48:	00800044 	movi	r2,1
  148f4c:	d0a27815 	stw	r2,-30240(gp)
  148f50:	00000706 	br	148f70 <mode_down+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  148f54:	d0a27817 	ldw	r2,-30240(gp)
  148f58:	10800058 	cmpnei	r2,r2,1
  148f5c:	1000031e 	bne	r2,zero,148f6c <mode_down+0x3c>
        trigger_mode = ONESHOT_TRIGGER;
  148f60:	00800084 	movi	r2,2
  148f64:	d0a27815 	stw	r2,-30240(gp)
  148f68:	00000106 	br	148f70 <mode_down+0x40>
    else
        trigger_mode = NORMAL_TRIGGER;
  148f6c:	d0227815 	stw	zero,-30240(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  148f70:	d0a27817 	ldw	r2,-30240(gp)
  148f74:	1009883a 	mov	r4,r2
  148f78:	0149d8c0 	call	149d8c <set_mode>


    /* all done with the trigger mode - return */
    return;
  148f7c:	0001883a 	nop

}
  148f80:	e037883a 	mov	sp,fp
  148f84:	dfc00117 	ldw	ra,4(sp)
  148f88:	df000017 	ldw	fp,0(sp)
  148f8c:	dec00204 	addi	sp,sp,8
  148f90:	f800283a 	ret

00148f94 <mode_up>:
   Last Modified:    May 9, 2006

*/

void  mode_up()
{
  148f94:	defffe04 	addi	sp,sp,-8
  148f98:	dfc00115 	stw	ra,4(sp)
  148f9c:	df000015 	stw	fp,0(sp)
  148fa0:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "previous" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  148fa4:	d0a27817 	ldw	r2,-30240(gp)
  148fa8:	1000031e 	bne	r2,zero,148fb8 <mode_up+0x24>
        trigger_mode = ONESHOT_TRIGGER;
  148fac:	00800084 	movi	r2,2
  148fb0:	d0a27815 	stw	r2,-30240(gp)
  148fb4:	00000706 	br	148fd4 <mode_up+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  148fb8:	d0a27817 	ldw	r2,-30240(gp)
  148fbc:	10800058 	cmpnei	r2,r2,1
  148fc0:	1000021e 	bne	r2,zero,148fcc <mode_up+0x38>
        trigger_mode = NORMAL_TRIGGER;
  148fc4:	d0227815 	stw	zero,-30240(gp)
  148fc8:	00000206 	br	148fd4 <mode_up+0x40>
    else
        trigger_mode = AUTO_TRIGGER;
  148fcc:	00800044 	movi	r2,1
  148fd0:	d0a27815 	stw	r2,-30240(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  148fd4:	d0a27817 	ldw	r2,-30240(gp)
  148fd8:	1009883a 	mov	r4,r2
  148fdc:	0149d8c0 	call	149d8c <set_mode>


    /* all done with the trigger mode - return */
    return;
  148fe0:	0001883a 	nop

}
  148fe4:	e037883a 	mov	sp,fp
  148fe8:	dfc00117 	ldw	ra,4(sp)
  148fec:	df000017 	ldw	fp,0(sp)
  148ff0:	dec00204 	addi	sp,sp,8
  148ff4:	f800283a 	ret

00148ff8 <display_mode>:
   Last Modified:    May 9, 2006

*/

void  display_mode(int x_pos, int y_pos, int style)
{
  148ff8:	defff804 	addi	sp,sp,-32
  148ffc:	dfc00715 	stw	ra,28(sp)
  149000:	df000615 	stw	fp,24(sp)
  149004:	df000604 	addi	fp,sp,24
  149008:	e13ffd15 	stw	r4,-12(fp)
  14900c:	e17ffe15 	stw	r5,-8(fp)
  149010:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* the mode strings (must match enumerated type) */
    const char * const  modes[] =  {  " Normal   ",
  149014:	00800574 	movhi	r2,21
  149018:	10b3b104 	addi	r2,r2,-12604
  14901c:	e0bffa15 	stw	r2,-24(fp)
  149020:	00800574 	movhi	r2,21
  149024:	10b3b404 	addi	r2,r2,-12592
  149028:	e0bffb15 	stw	r2,-20(fp)
  14902c:	00800574 	movhi	r2,21
  149030:	10b3b704 	addi	r2,r2,-12580
  149034:	e0bffc15 	stw	r2,-16(fp)
                                             " One-Shot "  };



    /* display the trigger mode */
    plot_string(x_pos, y_pos, modes[trigger_mode], style);
  149038:	d0a27817 	ldw	r2,-30240(gp)
  14903c:	1085883a 	add	r2,r2,r2
  149040:	1085883a 	add	r2,r2,r2
  149044:	e0fffa04 	addi	r3,fp,-24
  149048:	1885883a 	add	r2,r3,r2
  14904c:	10c00017 	ldw	r3,0(r2)
  149050:	e0bfff17 	ldw	r2,-4(fp)
  149054:	e13ffd17 	ldw	r4,-12(fp)
  149058:	e17ffe17 	ldw	r5,-8(fp)
  14905c:	180d883a 	mov	r6,r3
  149060:	100f883a 	mov	r7,r2
  149064:	01486a00 	call	1486a0 <plot_string>


    /* all done displaying the trigger mode - return */
    return;

}
  149068:	e037883a 	mov	sp,fp
  14906c:	dfc00117 	ldw	ra,4(sp)
  149070:	df000017 	ldw	fp,0(sp)
  149074:	dec00204 	addi	sp,sp,8
  149078:	f800283a 	ret

0014907c <set_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  set_scale(enum scale_type s)
{
  14907c:	defffd04 	addi	sp,sp,-12
  149080:	dfc00215 	stw	ra,8(sp)
  149084:	df000115 	stw	fp,4(sp)
  149088:	df000104 	addi	fp,sp,4
  14908c:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the scale type */
    scale = s;
  149090:	e0bfff17 	ldw	r2,-4(fp)
  149094:	d0a27c15 	stw	r2,-30224(gp)

    /* output the scale appropriately */
    set_display_scale(scale);
  149098:	d0a27c17 	ldw	r2,-30224(gp)
  14909c:	1009883a 	mov	r4,r2
  1490a0:	0149eb00 	call	149eb0 <set_display_scale>


    /* all done setting the scale type - return */
    return;
  1490a4:	0001883a 	nop

}
  1490a8:	e037883a 	mov	sp,fp
  1490ac:	dfc00117 	ldw	ra,4(sp)
  1490b0:	df000017 	ldw	fp,0(sp)
  1490b4:	dec00204 	addi	sp,sp,8
  1490b8:	f800283a 	ret

001490bc <scale_down>:
   Last Modified:    May 9, 2006

*/

void  scale_down()
{
  1490bc:	defffe04 	addi	sp,sp,-8
  1490c0:	dfc00115 	stw	ra,4(sp)
  1490c4:	df000015 	stw	fp,0(sp)
  1490c8:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "next" scale type */
    if (scale == SCALE_NONE)
  1490cc:	d0a27c17 	ldw	r2,-30224(gp)
  1490d0:	1000031e 	bne	r2,zero,1490e0 <scale_down+0x24>
        scale = SCALE_AXES;
  1490d4:	00800044 	movi	r2,1
  1490d8:	d0a27c15 	stw	r2,-30224(gp)
  1490dc:	00000706 	br	1490fc <scale_down+0x40>
    else if (scale == SCALE_AXES)
  1490e0:	d0a27c17 	ldw	r2,-30224(gp)
  1490e4:	10800058 	cmpnei	r2,r2,1
  1490e8:	1000031e 	bne	r2,zero,1490f8 <scale_down+0x3c>
        scale = SCALE_GRID;
  1490ec:	00800084 	movi	r2,2
  1490f0:	d0a27c15 	stw	r2,-30224(gp)
  1490f4:	00000106 	br	1490fc <scale_down+0x40>
    else
        scale = SCALE_NONE;
  1490f8:	d0227c15 	stw	zero,-30224(gp)

    /* set the scale type */
    set_display_scale(scale);
  1490fc:	d0a27c17 	ldw	r2,-30224(gp)
  149100:	1009883a 	mov	r4,r2
  149104:	0149eb00 	call	149eb0 <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  149108:	0001883a 	nop

}
  14910c:	e037883a 	mov	sp,fp
  149110:	dfc00117 	ldw	ra,4(sp)
  149114:	df000017 	ldw	fp,0(sp)
  149118:	dec00204 	addi	sp,sp,8
  14911c:	f800283a 	ret

00149120 <scale_up>:
   Last Modified:    May 9, 2006

*/

void  scale_up()
{
  149120:	defffe04 	addi	sp,sp,-8
  149124:	dfc00115 	stw	ra,4(sp)
  149128:	df000015 	stw	fp,0(sp)
  14912c:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "previous" scale type */
    if (scale == SCALE_NONE)
  149130:	d0a27c17 	ldw	r2,-30224(gp)
  149134:	1000031e 	bne	r2,zero,149144 <scale_up+0x24>
        scale = SCALE_GRID;
  149138:	00800084 	movi	r2,2
  14913c:	d0a27c15 	stw	r2,-30224(gp)
  149140:	00000706 	br	149160 <scale_up+0x40>
    else if (scale == SCALE_AXES)
  149144:	d0a27c17 	ldw	r2,-30224(gp)
  149148:	10800058 	cmpnei	r2,r2,1
  14914c:	1000021e 	bne	r2,zero,149158 <scale_up+0x38>
        scale = SCALE_NONE;
  149150:	d0227c15 	stw	zero,-30224(gp)
  149154:	00000206 	br	149160 <scale_up+0x40>
    else
        scale = SCALE_AXES;
  149158:	00800044 	movi	r2,1
  14915c:	d0a27c15 	stw	r2,-30224(gp)

    /* set the scale type */
    set_display_scale(scale);
  149160:	d0a27c17 	ldw	r2,-30224(gp)
  149164:	1009883a 	mov	r4,r2
  149168:	0149eb00 	call	149eb0 <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  14916c:	0001883a 	nop

}
  149170:	e037883a 	mov	sp,fp
  149174:	dfc00117 	ldw	ra,4(sp)
  149178:	df000017 	ldw	fp,0(sp)
  14917c:	dec00204 	addi	sp,sp,8
  149180:	f800283a 	ret

00149184 <display_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  display_scale(int x_pos, int y_pos, int style)
{
  149184:	defff804 	addi	sp,sp,-32
  149188:	dfc00715 	stw	ra,28(sp)
  14918c:	df000615 	stw	fp,24(sp)
  149190:	df000604 	addi	fp,sp,24
  149194:	e13ffd15 	stw	r4,-12(fp)
  149198:	e17ffe15 	stw	r5,-8(fp)
  14919c:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* the scale type strings (must match enumerated type) */
    const char * const  scale_stat[] =  {  " None",
  1491a0:	00800574 	movhi	r2,21
  1491a4:	10b3ba04 	addi	r2,r2,-12568
  1491a8:	e0bffa15 	stw	r2,-24(fp)
  1491ac:	00800574 	movhi	r2,21
  1491b0:	10b3bc04 	addi	r2,r2,-12560
  1491b4:	e0bffb15 	stw	r2,-20(fp)
  1491b8:	00800574 	movhi	r2,21
  1491bc:	10b3be04 	addi	r2,r2,-12552
  1491c0:	e0bffc15 	stw	r2,-16(fp)
                                                  " Grid"  };



    /* display the scale status */
    plot_string(x_pos, y_pos, scale_stat[scale], style);
  1491c4:	d0a27c17 	ldw	r2,-30224(gp)
  1491c8:	1085883a 	add	r2,r2,r2
  1491cc:	1085883a 	add	r2,r2,r2
  1491d0:	e0fffa04 	addi	r3,fp,-24
  1491d4:	1885883a 	add	r2,r3,r2
  1491d8:	10c00017 	ldw	r3,0(r2)
  1491dc:	e0bfff17 	ldw	r2,-4(fp)
  1491e0:	e13ffd17 	ldw	r4,-12(fp)
  1491e4:	e17ffe17 	ldw	r5,-8(fp)
  1491e8:	180d883a 	mov	r6,r3
  1491ec:	100f883a 	mov	r7,r2
  1491f0:	01486a00 	call	1486a0 <plot_string>


    /* all done displaying the scale status - return */
    return;

}
  1491f4:	e037883a 	mov	sp,fp
  1491f8:	dfc00117 	ldw	ra,4(sp)
  1491fc:	df000017 	ldw	fp,0(sp)
  149200:	dec00204 	addi	sp,sp,8
  149204:	f800283a 	ret

00149208 <set_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  set_sweep(int s)
{
  149208:	defffc04 	addi	sp,sp,-16
  14920c:	dfc00315 	stw	ra,12(sp)
  149210:	df000215 	stw	fp,8(sp)
  149214:	df000204 	addi	fp,sp,8
  149218:	e13fff15 	stw	r4,-4(fp)
    int  sample_size;		/* sample size for this sweep rate */



    /* set the new sweep rate */
    sweep = s;
  14921c:	e0bfff17 	ldw	r2,-4(fp)
  149220:	d0a27a15 	stw	r2,-30232(gp)

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  149224:	d0a27a17 	ldw	r2,-30232(gp)
  149228:	00c00574 	movhi	r3,21
  14922c:	18f38f04 	addi	r3,r3,-12740
  149230:	100490fa 	slli	r2,r2,3
  149234:	1885883a 	add	r2,r3,r2
  149238:	10800017 	ldw	r2,0(r2)
  14923c:	1009883a 	mov	r4,r2
  149240:	014b85c0 	call	14b85c <set_sample_rate>
  149244:	e0bffe15 	stw	r2,-8(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  149248:	e13ffe17 	ldw	r4,-8(fp)
  14924c:	0149e840 	call	149e84 <set_trace_size>


    /* all done initializing the sweep rate - return */
    return;
  149250:	0001883a 	nop

}
  149254:	e037883a 	mov	sp,fp
  149258:	dfc00117 	ldw	ra,4(sp)
  14925c:	df000017 	ldw	fp,0(sp)
  149260:	dec00204 	addi	sp,sp,8
  149264:	f800283a 	ret

00149268 <sweep_down>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_down()
{
  149268:	defffd04 	addi	sp,sp,-12
  14926c:	dfc00215 	stw	ra,8(sp)
  149270:	df000115 	stw	fp,4(sp)
  149274:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* decrease the sweep rate, if not already the minimum */
    if (sweep > 0)  {
  149278:	d0a27a17 	ldw	r2,-30232(gp)
  14927c:	0080090e 	bge	zero,r2,1492a4 <sweep_down+0x3c>
        /* not at minimum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep - 1));
  149280:	d0e27a17 	ldw	r3,-30232(gp)
  149284:	d0a27a17 	ldw	r2,-30232(gp)
  149288:	10bfffc4 	addi	r2,r2,-1
  14928c:	1809883a 	mov	r4,r3
  149290:	100b883a 	mov	r5,r2
  149294:	014974c0 	call	14974c <adjust_trg_delay>
	/* now set new sweep rate */
        sweep--;
  149298:	d0a27a17 	ldw	r2,-30232(gp)
  14929c:	10bfffc4 	addi	r2,r2,-1
  1492a0:	d0a27a15 	stw	r2,-30232(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  1492a4:	d0a27a17 	ldw	r2,-30232(gp)
  1492a8:	00c00574 	movhi	r3,21
  1492ac:	18f38f04 	addi	r3,r3,-12740
  1492b0:	100490fa 	slli	r2,r2,3
  1492b4:	1885883a 	add	r2,r3,r2
  1492b8:	10800017 	ldw	r2,0(r2)
  1492bc:	1009883a 	mov	r4,r2
  1492c0:	014b85c0 	call	14b85c <set_sample_rate>
  1492c4:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  1492c8:	e13fff17 	ldw	r4,-4(fp)
  1492cc:	0149e840 	call	149e84 <set_trace_size>


    /* all done with lowering the sweep rate - return */
    return;
  1492d0:	0001883a 	nop

}
  1492d4:	e037883a 	mov	sp,fp
  1492d8:	dfc00117 	ldw	ra,4(sp)
  1492dc:	df000017 	ldw	fp,0(sp)
  1492e0:	dec00204 	addi	sp,sp,8
  1492e4:	f800283a 	ret

001492e8 <sweep_up>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_up()
{
  1492e8:	defffd04 	addi	sp,sp,-12
  1492ec:	dfc00215 	stw	ra,8(sp)
  1492f0:	df000115 	stw	fp,4(sp)
  1492f4:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* increase the sweep rate, if not already the maximum */
    if (sweep < (NO_SWEEP_RATES - 1))  {
  1492f8:	d0a27a17 	ldw	r2,-30232(gp)
  1492fc:	10800428 	cmpgeui	r2,r2,16
  149300:	1000091e 	bne	r2,zero,149328 <sweep_up+0x40>
        /* not at maximum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep + 1));
  149304:	d0e27a17 	ldw	r3,-30232(gp)
  149308:	d0a27a17 	ldw	r2,-30232(gp)
  14930c:	10800044 	addi	r2,r2,1
  149310:	1809883a 	mov	r4,r3
  149314:	100b883a 	mov	r5,r2
  149318:	014974c0 	call	14974c <adjust_trg_delay>
	/* now set new sweep rate */
        sweep++;
  14931c:	d0a27a17 	ldw	r2,-30232(gp)
  149320:	10800044 	addi	r2,r2,1
  149324:	d0a27a15 	stw	r2,-30232(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  149328:	d0a27a17 	ldw	r2,-30232(gp)
  14932c:	00c00574 	movhi	r3,21
  149330:	18f38f04 	addi	r3,r3,-12740
  149334:	100490fa 	slli	r2,r2,3
  149338:	1885883a 	add	r2,r3,r2
  14933c:	10800017 	ldw	r2,0(r2)
  149340:	1009883a 	mov	r4,r2
  149344:	014b85c0 	call	14b85c <set_sample_rate>
  149348:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  14934c:	e13fff17 	ldw	r4,-4(fp)
  149350:	0149e840 	call	149e84 <set_trace_size>


    /* all done with raising the sweep rate - return */
    return;
  149354:	0001883a 	nop

}
  149358:	e037883a 	mov	sp,fp
  14935c:	dfc00117 	ldw	ra,4(sp)
  149360:	df000017 	ldw	fp,0(sp)
  149364:	dec00204 	addi	sp,sp,8
  149368:	f800283a 	ret

0014936c <display_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  display_sweep(int x_pos, int y_pos, int style)
{
  14936c:	defffb04 	addi	sp,sp,-20
  149370:	dfc00415 	stw	ra,16(sp)
  149374:	df000315 	stw	fp,12(sp)
  149378:	df000304 	addi	fp,sp,12
  14937c:	e13ffd15 	stw	r4,-12(fp)
  149380:	e17ffe15 	stw	r5,-8(fp)
  149384:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* display the sweep rate */
    plot_string(x_pos, y_pos, sweep_rates[sweep].s, style);
  149388:	d0a27a17 	ldw	r2,-30232(gp)
  14938c:	00c00574 	movhi	r3,21
  149390:	18f38f04 	addi	r3,r3,-12740
  149394:	100490fa 	slli	r2,r2,3
  149398:	1885883a 	add	r2,r3,r2
  14939c:	10800104 	addi	r2,r2,4
  1493a0:	10c00017 	ldw	r3,0(r2)
  1493a4:	e0bfff17 	ldw	r2,-4(fp)
  1493a8:	e13ffd17 	ldw	r4,-12(fp)
  1493ac:	e17ffe17 	ldw	r5,-8(fp)
  1493b0:	180d883a 	mov	r6,r3
  1493b4:	100f883a 	mov	r7,r2
  1493b8:	01486a00 	call	1486a0 <plot_string>


    /* all done displaying the sweep rate - return */
    return;
  1493bc:	0001883a 	nop

}
  1493c0:	e037883a 	mov	sp,fp
  1493c4:	dfc00117 	ldw	ra,4(sp)
  1493c8:	df000017 	ldw	fp,0(sp)
  1493cc:	dec00204 	addi	sp,sp,8
  1493d0:	f800283a 	ret

001493d4 <set_trg_level>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_level(int l)
{
  1493d4:	defffd04 	addi	sp,sp,-12
  1493d8:	dfc00215 	stw	ra,8(sp)
  1493dc:	df000115 	stw	fp,4(sp)
  1493e0:	df000104 	addi	fp,sp,4
  1493e4:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger level */
    level = l;
  1493e8:	e0bfff17 	ldw	r2,-4(fp)
  1493ec:	d0a27915 	stw	r2,-30236(gp)

    /* set the trigger level in hardware too */
    set_trigger(level, slope);
  1493f0:	d0e27917 	ldw	r3,-30236(gp)
  1493f4:	d0a27d17 	ldw	r2,-30220(gp)
  1493f8:	1809883a 	mov	r4,r3
  1493fc:	100b883a 	mov	r5,r2
  149400:	014b8a40 	call	14b8a4 <set_trigger>


    /* all done initializing the trigger level - return */
    return;
  149404:	0001883a 	nop

}
  149408:	e037883a 	mov	sp,fp
  14940c:	dfc00117 	ldw	ra,4(sp)
  149410:	df000017 	ldw	fp,0(sp)
  149414:	dec00204 	addi	sp,sp,8
  149418:	f800283a 	ret

0014941c <trg_level_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_down()
{
  14941c:	defffe04 	addi	sp,sp,-8
  149420:	dfc00115 	stw	ra,4(sp)
  149424:	df000015 	stw	fp,0(sp)
  149428:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger level, if not already the minimum */
    if (level > MIN_TRG_LEVEL_SET)
  14942c:	d0a27917 	ldw	r2,-30236(gp)
  149430:	0080030e 	bge	zero,r2,149440 <trg_level_down+0x24>
        level--;
  149434:	d0a27917 	ldw	r2,-30236(gp)
  149438:	10bfffc4 	addi	r2,r2,-1
  14943c:	d0a27915 	stw	r2,-30236(gp)

    /* set the trigger level for the hardware */
    set_trigger(level, slope);
  149440:	d0e27917 	ldw	r3,-30236(gp)
  149444:	d0a27d17 	ldw	r2,-30220(gp)
  149448:	1809883a 	mov	r4,r3
  14944c:	100b883a 	mov	r5,r2
  149450:	014b8a40 	call	14b8a4 <set_trigger>


    /* all done with lowering the trigger level - return */
    return;
  149454:	0001883a 	nop

}
  149458:	e037883a 	mov	sp,fp
  14945c:	dfc00117 	ldw	ra,4(sp)
  149460:	df000017 	ldw	fp,0(sp)
  149464:	dec00204 	addi	sp,sp,8
  149468:	f800283a 	ret

0014946c <trg_level_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_up()
{
  14946c:	defffe04 	addi	sp,sp,-8
  149470:	dfc00115 	stw	ra,4(sp)
  149474:	df000015 	stw	fp,0(sp)
  149478:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger level, if not already the maximum */
    if (level < MAX_TRG_LEVEL_SET)
  14947c:	d0a27917 	ldw	r2,-30236(gp)
  149480:	10801fc8 	cmpgei	r2,r2,127
  149484:	1000031e 	bne	r2,zero,149494 <trg_level_up+0x28>
        level++;
  149488:	d0a27917 	ldw	r2,-30236(gp)
  14948c:	10800044 	addi	r2,r2,1
  149490:	d0a27915 	stw	r2,-30236(gp)

    /* tell the hardware the new trigger level */
    set_trigger(level, slope);
  149494:	d0e27917 	ldw	r3,-30236(gp)
  149498:	d0a27d17 	ldw	r2,-30220(gp)
  14949c:	1809883a 	mov	r4,r3
  1494a0:	100b883a 	mov	r5,r2
  1494a4:	014b8a40 	call	14b8a4 <set_trigger>


    /* all done raising the trigger level - return */
    return;
  1494a8:	0001883a 	nop

}
  1494ac:	e037883a 	mov	sp,fp
  1494b0:	dfc00117 	ldw	ra,4(sp)
  1494b4:	df000017 	ldw	fp,0(sp)
  1494b8:	dec00204 	addi	sp,sp,8
  1494bc:	f800283a 	ret

001494c0 <display_trg_level>:
   Last Modified:    Mar. 10, 1995

*/

void  display_trg_level(int x_pos, int y_pos, int style)
{
  1494c0:	defff704 	addi	sp,sp,-36
  1494c4:	dfc00815 	stw	ra,32(sp)
  1494c8:	df000715 	stw	fp,28(sp)
  1494cc:	df000704 	addi	fp,sp,28
  1494d0:	e13ffd15 	stw	r4,-12(fp)
  1494d4:	e17ffe15 	stw	r5,-8(fp)
  1494d8:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      level_str[] = "        "; /* string containing the trigger level */
  1494dc:	00880834 	movhi	r2,8224
  1494e0:	10880804 	addi	r2,r2,8224
  1494e4:	e0bffa15 	stw	r2,-24(fp)
  1494e8:	00880834 	movhi	r2,8224
  1494ec:	10880804 	addi	r2,r2,8224
  1494f0:	e0bffb15 	stw	r2,-20(fp)
  1494f4:	e03ffc05 	stb	zero,-16(fp)
    long int  l;			/* trigger level in mV */



    /* compute the trigger level in millivolts */
    l = ((long int) MAX_LEVEL - MIN_LEVEL) * level / (MAX_TRG_LEVEL_SET - MIN_TRG_LEVEL_SET) + MIN_LEVEL;
  1494f8:	d0a27917 	ldw	r2,-30236(gp)
  1494fc:	1009883a 	mov	r4,r2
  149500:	0144e204 	movi	r5,5000
  149504:	014bd900 	call	14bd90 <__mulsi3>
  149508:	1009883a 	mov	r4,r2
  14950c:	01401fc4 	movi	r5,127
  149510:	014bcd40 	call	14bcd4 <__divsi3>
  149514:	e0bff915 	stw	r2,-28(fp)

    /* convert the level to the string (leave first character blank) */
    cvt_num_field(l, &level_str[1]);
  149518:	e0bffa04 	addi	r2,fp,-24
  14951c:	10800044 	addi	r2,r2,1
  149520:	e13ff917 	ldw	r4,-28(fp)
  149524:	100b883a 	mov	r5,r2
  149528:	0149a500 	call	149a50 <cvt_num_field>

    /* add in the units */
    level_str[7] = 'V';
  14952c:	00801584 	movi	r2,86
  149530:	e0bffbc5 	stb	r2,-17(fp)


    /* now finally display the trigger level */
    plot_string(x_pos, y_pos, level_str, style);
  149534:	e0bfff17 	ldw	r2,-4(fp)
  149538:	e0fffa04 	addi	r3,fp,-24
  14953c:	e13ffd17 	ldw	r4,-12(fp)
  149540:	e17ffe17 	ldw	r5,-8(fp)
  149544:	180d883a 	mov	r6,r3
  149548:	100f883a 	mov	r7,r2
  14954c:	01486a00 	call	1486a0 <plot_string>


    /* all done displaying the trigger level - return */
    return;

}
  149550:	e037883a 	mov	sp,fp
  149554:	dfc00117 	ldw	ra,4(sp)
  149558:	df000017 	ldw	fp,0(sp)
  14955c:	dec00204 	addi	sp,sp,8
  149560:	f800283a 	ret

00149564 <set_trg_slope>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_slope(enum slope_type s)
{
  149564:	defffd04 	addi	sp,sp,-12
  149568:	dfc00215 	stw	ra,8(sp)
  14956c:	df000115 	stw	fp,4(sp)
  149570:	df000104 	addi	fp,sp,4
  149574:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the slope type */
    slope = s;
  149578:	e0bfff17 	ldw	r2,-4(fp)
  14957c:	d0a27d15 	stw	r2,-30220(gp)

    /* also tell the hardware what the slope is */
    set_trigger(level, slope);
  149580:	d0e27917 	ldw	r3,-30236(gp)
  149584:	d0a27d17 	ldw	r2,-30220(gp)
  149588:	1809883a 	mov	r4,r3
  14958c:	100b883a 	mov	r5,r2
  149590:	014b8a40 	call	14b8a4 <set_trigger>


    /* all done setting the trigger slope - return */
    return;
  149594:	0001883a 	nop

}
  149598:	e037883a 	mov	sp,fp
  14959c:	dfc00117 	ldw	ra,4(sp)
  1495a0:	df000017 	ldw	fp,0(sp)
  1495a4:	dec00204 	addi	sp,sp,8
  1495a8:	f800283a 	ret

001495ac <trg_slope_toggle>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_slope_toggle()
{
  1495ac:	defffe04 	addi	sp,sp,-8
  1495b0:	dfc00115 	stw	ra,4(sp)
  1495b4:	df000015 	stw	fp,0(sp)
  1495b8:	d839883a 	mov	fp,sp
      /* none */



    /* toggle the trigger slope */
    if (slope == SLOPE_POSITIVE)
  1495bc:	d0a27d17 	ldw	r2,-30220(gp)
  1495c0:	1000031e 	bne	r2,zero,1495d0 <trg_slope_toggle+0x24>
        slope = SLOPE_NEGATIVE;
  1495c4:	00800044 	movi	r2,1
  1495c8:	d0a27d15 	stw	r2,-30220(gp)
  1495cc:	00000106 	br	1495d4 <trg_slope_toggle+0x28>
    else
        slope = SLOPE_POSITIVE;
  1495d0:	d0227d15 	stw	zero,-30220(gp)

    /* set the new trigger slope */
    set_trigger(level, slope);
  1495d4:	d0e27917 	ldw	r3,-30236(gp)
  1495d8:	d0a27d17 	ldw	r2,-30220(gp)
  1495dc:	1809883a 	mov	r4,r3
  1495e0:	100b883a 	mov	r5,r2
  1495e4:	014b8a40 	call	14b8a4 <set_trigger>


    /* all done with the trigger slope - return */
    return;
  1495e8:	0001883a 	nop

}
  1495ec:	e037883a 	mov	sp,fp
  1495f0:	dfc00117 	ldw	ra,4(sp)
  1495f4:	df000017 	ldw	fp,0(sp)
  1495f8:	dec00204 	addi	sp,sp,8
  1495fc:	f800283a 	ret

00149600 <display_trg_slope>:
   Last Modified:    Mar. 13, 1994

*/

void  display_trg_slope(int x_pos, int y_pos, int style)
{
  149600:	defff904 	addi	sp,sp,-28
  149604:	dfc00615 	stw	ra,24(sp)
  149608:	df000515 	stw	fp,20(sp)
  14960c:	df000504 	addi	fp,sp,20
  149610:	e13ffd15 	stw	r4,-12(fp)
  149614:	e17ffe15 	stw	r5,-8(fp)
  149618:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* the trigger slope strings (must match enumerated type) */
    const char * const  slopes[] =  {  " +", " -"  };
  14961c:	00800574 	movhi	r2,21
  149620:	10b3c004 	addi	r2,r2,-12544
  149624:	e0bffb15 	stw	r2,-20(fp)
  149628:	00800574 	movhi	r2,21
  14962c:	10b3c104 	addi	r2,r2,-12540
  149630:	e0bffc15 	stw	r2,-16(fp)



    /* display the trigger slope */
    plot_string(x_pos, y_pos, slopes[slope], style);
  149634:	d0a27d17 	ldw	r2,-30220(gp)
  149638:	1085883a 	add	r2,r2,r2
  14963c:	1085883a 	add	r2,r2,r2
  149640:	e0fffb04 	addi	r3,fp,-20
  149644:	1885883a 	add	r2,r3,r2
  149648:	10c00017 	ldw	r3,0(r2)
  14964c:	e0bfff17 	ldw	r2,-4(fp)
  149650:	e13ffd17 	ldw	r4,-12(fp)
  149654:	e17ffe17 	ldw	r5,-8(fp)
  149658:	180d883a 	mov	r6,r3
  14965c:	100f883a 	mov	r7,r2
  149660:	01486a00 	call	1486a0 <plot_string>


    /* all done displaying the trigger slope - return */
    return;

}
  149664:	e037883a 	mov	sp,fp
  149668:	dfc00117 	ldw	ra,4(sp)
  14966c:	df000017 	ldw	fp,0(sp)
  149670:	dec00204 	addi	sp,sp,8
  149674:	f800283a 	ret

00149678 <set_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_delay(long int d)
{
  149678:	defffd04 	addi	sp,sp,-12
  14967c:	dfc00215 	stw	ra,8(sp)
  149680:	df000115 	stw	fp,4(sp)
  149684:	df000104 	addi	fp,sp,4
  149688:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger delay */
    delay = d;
  14968c:	e0bfff17 	ldw	r2,-4(fp)
  149690:	d0a27b15 	stw	r2,-30228(gp)

    /* set the trigger delay in hardware too */
    set_delay(delay);
  149694:	d0a27b17 	ldw	r2,-30228(gp)
  149698:	1009883a 	mov	r4,r2
  14969c:	014b9100 	call	14b910 <set_delay>


    /* all done initializing the trigger delay - return */
    return;
  1496a0:	0001883a 	nop

}
  1496a4:	e037883a 	mov	sp,fp
  1496a8:	dfc00117 	ldw	ra,4(sp)
  1496ac:	df000017 	ldw	fp,0(sp)
  1496b0:	dec00204 	addi	sp,sp,8
  1496b4:	f800283a 	ret

001496b8 <trg_delay_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_down()
{
  1496b8:	defffe04 	addi	sp,sp,-8
  1496bc:	dfc00115 	stw	ra,4(sp)
  1496c0:	df000015 	stw	fp,0(sp)
  1496c4:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger delay, if not already the minimum */
    if (delay > MIN_DELAY)
  1496c8:	d0a27b17 	ldw	r2,-30228(gp)
  1496cc:	0080030e 	bge	zero,r2,1496dc <trg_delay_down+0x24>
        delay--;
  1496d0:	d0a27b17 	ldw	r2,-30228(gp)
  1496d4:	10bfffc4 	addi	r2,r2,-1
  1496d8:	d0a27b15 	stw	r2,-30228(gp)

    /* set the trigger delay for the hardware */
    set_delay(delay);
  1496dc:	d0a27b17 	ldw	r2,-30228(gp)
  1496e0:	1009883a 	mov	r4,r2
  1496e4:	014b9100 	call	14b910 <set_delay>


    /* all done with lowering the trigger delay - return */
    return;
  1496e8:	0001883a 	nop

}
  1496ec:	e037883a 	mov	sp,fp
  1496f0:	dfc00117 	ldw	ra,4(sp)
  1496f4:	df000017 	ldw	fp,0(sp)
  1496f8:	dec00204 	addi	sp,sp,8
  1496fc:	f800283a 	ret

00149700 <trg_delay_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_up()
{
  149700:	defffe04 	addi	sp,sp,-8
  149704:	dfc00115 	stw	ra,4(sp)
  149708:	df000015 	stw	fp,0(sp)
  14970c:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger delay, if not already the maximum */
    if (delay < MAX_DELAY)
  149710:	d0a27b17 	ldw	r2,-30228(gp)
  149714:	00f0d3d4 	movui	r3,49999
  149718:	18800316 	blt	r3,r2,149728 <trg_delay_up+0x28>
        delay++;
  14971c:	d0a27b17 	ldw	r2,-30228(gp)
  149720:	10800044 	addi	r2,r2,1
  149724:	d0a27b15 	stw	r2,-30228(gp)

    /* tell the hardware the new trigger delay */
    set_delay(delay);
  149728:	d0a27b17 	ldw	r2,-30228(gp)
  14972c:	1009883a 	mov	r4,r2
  149730:	014b9100 	call	14b910 <set_delay>


    /* all done raising the trigger delay - return */
    return;
  149734:	0001883a 	nop

}
  149738:	e037883a 	mov	sp,fp
  14973c:	dfc00117 	ldw	ra,4(sp)
  149740:	df000017 	ldw	fp,0(sp)
  149744:	dec00204 	addi	sp,sp,8
  149748:	f800283a 	ret

0014974c <adjust_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  adjust_trg_delay(int old_sweep, int new_sweep)
{
  14974c:	defffc04 	addi	sp,sp,-16
  149750:	dfc00315 	stw	ra,12(sp)
  149754:	df000215 	stw	fp,8(sp)
  149758:	df000204 	addi	fp,sp,8
  14975c:	e13ffe15 	stw	r4,-8(fp)
  149760:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* multiply by 10 times the ratio of sweep rates */
    delay *= (10 * sweep_rates[new_sweep].sample_rate) / sweep_rates[old_sweep].sample_rate;
  149764:	00c00574 	movhi	r3,21
  149768:	18f38f04 	addi	r3,r3,-12740
  14976c:	e0bfff17 	ldw	r2,-4(fp)
  149770:	100490fa 	slli	r2,r2,3
  149774:	1885883a 	add	r2,r3,r2
  149778:	10800017 	ldw	r2,0(r2)
  14977c:	1009883a 	mov	r4,r2
  149780:	01400284 	movi	r5,10
  149784:	014bd900 	call	14bd90 <__mulsi3>
  149788:	1007883a 	mov	r3,r2
  14978c:	01000574 	movhi	r4,21
  149790:	21338f04 	addi	r4,r4,-12740
  149794:	e0bffe17 	ldw	r2,-8(fp)
  149798:	100490fa 	slli	r2,r2,3
  14979c:	2085883a 	add	r2,r4,r2
  1497a0:	10800017 	ldw	r2,0(r2)
  1497a4:	1809883a 	mov	r4,r3
  1497a8:	100b883a 	mov	r5,r2
  1497ac:	014bcd40 	call	14bcd4 <__divsi3>
  1497b0:	1007883a 	mov	r3,r2
  1497b4:	d0a27b17 	ldw	r2,-30228(gp)
  1497b8:	1809883a 	mov	r4,r3
  1497bc:	100b883a 	mov	r5,r2
  1497c0:	014bd900 	call	14bd90 <__mulsi3>
  1497c4:	d0a27b15 	stw	r2,-30228(gp)
    /* now divide the factor of 10 back out */
    delay /= 10;
  1497c8:	d0a27b17 	ldw	r2,-30228(gp)
  1497cc:	1009883a 	mov	r4,r2
  1497d0:	01400284 	movi	r5,10
  1497d4:	014bcd40 	call	14bcd4 <__divsi3>
  1497d8:	d0a27b15 	stw	r2,-30228(gp)

    /* make sure delay is not out of range */
    if (delay > MAX_DELAY)
  1497dc:	d0a27b17 	ldw	r2,-30228(gp)
  1497e0:	00f0d414 	movui	r3,50000
  1497e4:	1880020e 	bge	r3,r2,1497f0 <adjust_trg_delay+0xa4>
        /* delay is too large - set to maximum */
        delay = MAX_DELAY;
  1497e8:	00b0d414 	movui	r2,50000
  1497ec:	d0a27b15 	stw	r2,-30228(gp)
    if (delay < MIN_DELAY)
  1497f0:	d0a27b17 	ldw	r2,-30228(gp)
  1497f4:	1000010e 	bge	r2,zero,1497fc <adjust_trg_delay+0xb0>
        /* delay is too small - set to minimum */
	delay = MIN_DELAY;
  1497f8:	d0227b15 	stw	zero,-30228(gp)


    /* tell the hardware the new trigger delay */
    set_delay(delay);
  1497fc:	d0a27b17 	ldw	r2,-30228(gp)
  149800:	1009883a 	mov	r4,r2
  149804:	014b9100 	call	14b910 <set_delay>


    /* all done adjusting the trigger delay - return */
    return;
  149808:	0001883a 	nop

}
  14980c:	e037883a 	mov	sp,fp
  149810:	dfc00117 	ldw	ra,4(sp)
  149814:	df000017 	ldw	fp,0(sp)
  149818:	dec00204 	addi	sp,sp,8
  14981c:	f800283a 	ret

00149820 <display_trg_delay>:
   Last Modified:    May 3, 2006

*/

void  display_trg_delay(int x_pos, int y_pos, int style)
{
  149820:	defff604 	addi	sp,sp,-40
  149824:	dfc00915 	stw	ra,36(sp)
  149828:	df000815 	stw	fp,32(sp)
  14982c:	df000804 	addi	fp,sp,32
  149830:	e13ffd15 	stw	r4,-12(fp)
  149834:	e17ffe15 	stw	r5,-8(fp)
  149838:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      delay_str[] = "         "; /* string containing the trigger delay */
  14983c:	00880834 	movhi	r2,8224
  149840:	10880804 	addi	r2,r2,8224
  149844:	e0bffa15 	stw	r2,-24(fp)
  149848:	00880834 	movhi	r2,8224
  14984c:	10880804 	addi	r2,r2,8224
  149850:	e0bffb15 	stw	r2,-20(fp)
  149854:	00800804 	movi	r2,32
  149858:	e0bffc0d 	sth	r2,-16(fp)
    long int  d;                         /* delay in appropriate units */


    /* compute the delay in the appropriate units */
    /* have to watch out for overflow, so be careful */
    if (sweep_rates[sweep].sample_rate > 1000000L)  {
  14985c:	d0a27a17 	ldw	r2,-30232(gp)
  149860:	00c00574 	movhi	r3,21
  149864:	18f38f04 	addi	r3,r3,-12740
  149868:	100490fa 	slli	r2,r2,3
  14986c:	1885883a 	add	r2,r3,r2
  149870:	10800017 	ldw	r2,0(r2)
  149874:	00c003f4 	movhi	r3,15
  149878:	18d09004 	addi	r3,r3,16960
  14987c:	1880170e 	bge	r3,r2,1498dc <display_trg_delay+0xbc>
        /* have a fast sweep rate, could overflow */
        /* first compute in units of 100 ns */
        d = delay * (10000000L / sweep_rates[sweep].sample_rate);
  149880:	d0a27a17 	ldw	r2,-30232(gp)
  149884:	00c00574 	movhi	r3,21
  149888:	18f38f04 	addi	r3,r3,-12740
  14988c:	100490fa 	slli	r2,r2,3
  149890:	1885883a 	add	r2,r3,r2
  149894:	10800017 	ldw	r2,0(r2)
  149898:	01002674 	movhi	r4,153
  14989c:	2125a004 	addi	r4,r4,-27008
  1498a0:	100b883a 	mov	r5,r2
  1498a4:	014bcd40 	call	14bcd4 <__divsi3>
  1498a8:	1007883a 	mov	r3,r2
  1498ac:	d0a27b17 	ldw	r2,-30228(gp)
  1498b0:	1809883a 	mov	r4,r3
  1498b4:	100b883a 	mov	r5,r2
  1498b8:	014bd900 	call	14bd90 <__mulsi3>
  1498bc:	e0bff915 	stw	r2,-28(fp)
	/* now convert to nanoseconds */
	d *= 100L;
  1498c0:	e13ff917 	ldw	r4,-28(fp)
  1498c4:	01401904 	movi	r5,100
  1498c8:	014bd900 	call	14bd90 <__mulsi3>
  1498cc:	e0bff915 	stw	r2,-28(fp)
	/* need to divide by 1000 to get to microseconds */
	units_adj = 1000;
  1498d0:	0080fa04 	movi	r2,1000
  1498d4:	e0bff815 	stw	r2,-32(fp)
  1498d8:	00001206 	br	149924 <display_trg_delay+0x104>
    }
    else  {
        /* slow sweep rate, don't have to worry about overflow */
        d = delay * (1000000L / sweep_rates[sweep].sample_rate);
  1498dc:	d0a27a17 	ldw	r2,-30232(gp)
  1498e0:	00c00574 	movhi	r3,21
  1498e4:	18f38f04 	addi	r3,r3,-12740
  1498e8:	100490fa 	slli	r2,r2,3
  1498ec:	1885883a 	add	r2,r3,r2
  1498f0:	10800017 	ldw	r2,0(r2)
  1498f4:	010003f4 	movhi	r4,15
  1498f8:	21109004 	addi	r4,r4,16960
  1498fc:	100b883a 	mov	r5,r2
  149900:	014bcd40 	call	14bcd4 <__divsi3>
  149904:	1007883a 	mov	r3,r2
  149908:	d0a27b17 	ldw	r2,-30228(gp)
  14990c:	1809883a 	mov	r4,r3
  149910:	100b883a 	mov	r5,r2
  149914:	014bd900 	call	14bd90 <__mulsi3>
  149918:	e0bff915 	stw	r2,-28(fp)
	/* already in microseconds, so adjustment is 1 */
	units_adj = 1;
  14991c:	00800044 	movi	r2,1
  149920:	e0bff815 	stw	r2,-32(fp)
    }

    /* convert it to the string (leave first character blank) */
    cvt_num_field(d, &delay_str[1]);
  149924:	e0bffa04 	addi	r2,fp,-24
  149928:	10800044 	addi	r2,r2,1
  14992c:	e13ff917 	ldw	r4,-28(fp)
  149930:	100b883a 	mov	r5,r2
  149934:	0149a500 	call	149a50 <cvt_num_field>

    /* add in the units */
    if (((d / units_adj) < 1000) && ((d / units_adj) > -1000) && (units_adj == 1000)) {
  149938:	e13ff917 	ldw	r4,-28(fp)
  14993c:	e17ff817 	ldw	r5,-32(fp)
  149940:	014bcd40 	call	14bcd4 <__divsi3>
  149944:	1080fa08 	cmpgei	r2,r2,1000
  149948:	10000d1e 	bne	r2,zero,149980 <display_trg_delay+0x160>
  14994c:	e13ff917 	ldw	r4,-28(fp)
  149950:	e17ff817 	ldw	r5,-32(fp)
  149954:	014bcd40 	call	14bcd4 <__divsi3>
  149958:	10bf0650 	cmplti	r2,r2,-999
  14995c:	1000081e 	bne	r2,zero,149980 <display_trg_delay+0x160>
  149960:	e0bff817 	ldw	r2,-32(fp)
  149964:	1080fa18 	cmpnei	r2,r2,1000
  149968:	1000051e 	bne	r2,zero,149980 <display_trg_delay+0x160>
        /* delay is in microseconds */
	delay_str[7] = '\004';
  14996c:	00800104 	movi	r2,4
  149970:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  149974:	00801cc4 	movi	r2,115
  149978:	e0bffc05 	stb	r2,-16(fp)
  14997c:	00002806 	br	149a20 <display_trg_delay+0x200>
    }
    else if (((d / units_adj) < 1000000) && ((d / units_adj) > -1000000)) {
  149980:	e13ff917 	ldw	r4,-28(fp)
  149984:	e17ff817 	ldw	r5,-32(fp)
  149988:	014bcd40 	call	14bcd4 <__divsi3>
  14998c:	00c003f4 	movhi	r3,15
  149990:	18d08fc4 	addi	r3,r3,16959
  149994:	18800c16 	blt	r3,r2,1499c8 <display_trg_delay+0x1a8>
  149998:	e13ff917 	ldw	r4,-28(fp)
  14999c:	e17ff817 	ldw	r5,-32(fp)
  1499a0:	014bcd40 	call	14bcd4 <__divsi3>
  1499a4:	1007883a 	mov	r3,r2
  1499a8:	00bffc74 	movhi	r2,65521
  1499ac:	10af7044 	addi	r2,r2,-16959
  1499b0:	18800516 	blt	r3,r2,1499c8 <display_trg_delay+0x1a8>
        /* delay is in milliseconds */
	delay_str[7] = 'm';
  1499b4:	00801b44 	movi	r2,109
  1499b8:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  1499bc:	00801cc4 	movi	r2,115
  1499c0:	e0bffc05 	stb	r2,-16(fp)
  1499c4:	00001606 	br	149a20 <display_trg_delay+0x200>
    }
    else if (((d / units_adj) < 1000000000) && ((d / units_adj) > -1000000000))  {
  1499c8:	e13ff917 	ldw	r4,-28(fp)
  1499cc:	e17ff817 	ldw	r5,-32(fp)
  1499d0:	014bcd40 	call	14bcd4 <__divsi3>
  1499d4:	00cee6f4 	movhi	r3,15259
  1499d8:	18f27fc4 	addi	r3,r3,-13825
  1499dc:	18800c16 	blt	r3,r2,149a10 <display_trg_delay+0x1f0>
  1499e0:	e13ff917 	ldw	r4,-28(fp)
  1499e4:	e17ff817 	ldw	r5,-32(fp)
  1499e8:	014bcd40 	call	14bcd4 <__divsi3>
  1499ec:	1007883a 	mov	r3,r2
  1499f0:	00b11974 	movhi	r2,50277
  1499f4:	108d8044 	addi	r2,r2,13825
  1499f8:	18800516 	blt	r3,r2,149a10 <display_trg_delay+0x1f0>
        /* delay is in seconds */
	delay_str[7] = 's';
  1499fc:	00801cc4 	movi	r2,115
  149a00:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = ' ';
  149a04:	00800804 	movi	r2,32
  149a08:	e0bffc05 	stb	r2,-16(fp)
  149a0c:	00000406 	br	149a20 <display_trg_delay+0x200>
    }
    else  {
        /* delay is in kiloseconds */
	delay_str[7] = 'k';
  149a10:	00801ac4 	movi	r2,107
  149a14:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  149a18:	00801cc4 	movi	r2,115
  149a1c:	e0bffc05 	stb	r2,-16(fp)
    }


    /* now actually display the trigger delay */
    plot_string(x_pos, y_pos, delay_str, style);
  149a20:	e0bfff17 	ldw	r2,-4(fp)
  149a24:	e0fffa04 	addi	r3,fp,-24
  149a28:	e13ffd17 	ldw	r4,-12(fp)
  149a2c:	e17ffe17 	ldw	r5,-8(fp)
  149a30:	180d883a 	mov	r6,r3
  149a34:	100f883a 	mov	r7,r2
  149a38:	01486a00 	call	1486a0 <plot_string>


    /* all done displaying the trigger delay - return */
    return;

}
  149a3c:	e037883a 	mov	sp,fp
  149a40:	dfc00117 	ldw	ra,4(sp)
  149a44:	df000017 	ldw	fp,0(sp)
  149a48:	dec00204 	addi	sp,sp,8
  149a4c:	f800283a 	ret

00149a50 <cvt_num_field>:
   Last Modified:    Mar. 8, 1994

*/

void  cvt_num_field(long int n, char *s)
{
  149a50:	defff804 	addi	sp,sp,-32
  149a54:	dfc00715 	stw	ra,28(sp)
  149a58:	df000615 	stw	fp,24(sp)
  149a5c:	dc000515 	stw	r16,20(sp)
  149a60:	df000504 	addi	fp,sp,20
  149a64:	e13ffe15 	stw	r4,-8(fp)
  149a68:	e17fff15 	stw	r5,-4(fp)
    /* variables */
    int  dp = 3;		/* digits to right of decimal point */
  149a6c:	008000c4 	movi	r2,3
  149a70:	e0bffb15 	stw	r2,-20(fp)
    int  d;			/* digit weight (power of 10) */

    int  i = 0;			/* string index */
  149a74:	e03ffd15 	stw	zero,-12(fp)



    /* first get the sign (and make n positive for conversion) */
    if (n < 0)  {
  149a78:	e0bffe17 	ldw	r2,-8(fp)
  149a7c:	10000c0e 	bge	r2,zero,149ab0 <cvt_num_field+0x60>
        /* n is negative, set sign and convert to positive */
	s[i++] = '-';
  149a80:	e0bffd17 	ldw	r2,-12(fp)
  149a84:	e0ffff17 	ldw	r3,-4(fp)
  149a88:	1885883a 	add	r2,r3,r2
  149a8c:	00c00b44 	movi	r3,45
  149a90:	10c00005 	stb	r3,0(r2)
  149a94:	e0bffd17 	ldw	r2,-12(fp)
  149a98:	10800044 	addi	r2,r2,1
  149a9c:	e0bffd15 	stw	r2,-12(fp)
	n = -n;
  149aa0:	e0bffe17 	ldw	r2,-8(fp)
  149aa4:	0085c83a 	sub	r2,zero,r2
  149aa8:	e0bffe15 	stw	r2,-8(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  149aac:	00001106 	br	149af4 <cvt_num_field+0xa4>
	s[i++] = '-';
	n = -n;
    }
    else  {
        /* n is positive, set sign only */
	s[i++] = '+';
  149ab0:	e0bffd17 	ldw	r2,-12(fp)
  149ab4:	e0ffff17 	ldw	r3,-4(fp)
  149ab8:	1885883a 	add	r2,r3,r2
  149abc:	00c00ac4 	movi	r3,43
  149ac0:	10c00005 	stb	r3,0(r2)
  149ac4:	e0bffd17 	ldw	r2,-12(fp)
  149ac8:	10800044 	addi	r2,r2,1
  149acc:	e0bffd15 	stw	r2,-12(fp)
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  149ad0:	00000806 	br	149af4 <cvt_num_field+0xa4>
        /* have more than 4 digits - get rid of one */
	n /= 10;
  149ad4:	e0bffe17 	ldw	r2,-8(fp)
  149ad8:	1009883a 	mov	r4,r2
  149adc:	01400284 	movi	r5,10
  149ae0:	014bcd40 	call	14bcd4 <__divsi3>
  149ae4:	e0bffe15 	stw	r2,-8(fp)
	/* adjust the decimal point */
	dp--;
  149ae8:	e0bffb17 	ldw	r2,-20(fp)
  149aec:	10bfffc4 	addi	r2,r2,-1
  149af0:	e0bffb15 	stw	r2,-20(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  149af4:	e0bffe17 	ldw	r2,-8(fp)
  149af8:	1089c408 	cmpgei	r2,r2,10000
  149afc:	103ff51e 	bne	r2,zero,149ad4 <cvt_num_field+0x84>
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  149b00:	00000306 	br	149b10 <cvt_num_field+0xc0>
       dp += 3;
  149b04:	e0bffb17 	ldw	r2,-20(fp)
  149b08:	108000c4 	addi	r2,r2,3
  149b0c:	e0bffb15 	stw	r2,-20(fp)
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  149b10:	e0bffb17 	ldw	r2,-20(fp)
  149b14:	00bffb0e 	bge	zero,r2,149b04 <cvt_num_field+0xb4>
       dp += 3;


    /* adjust dp to be digits to the right of the decimal point */
    /* (assuming 4 digits) */
    dp = 4 - dp;
  149b18:	00c00104 	movi	r3,4
  149b1c:	e0bffb17 	ldw	r2,-20(fp)
  149b20:	1885c83a 	sub	r2,r3,r2
  149b24:	e0bffb15 	stw	r2,-20(fp)


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  149b28:	0080fa04 	movi	r2,1000
  149b2c:	e0bffc15 	stw	r2,-16(fp)
  149b30:	00002406 	br	149bc4 <cvt_num_field+0x174>

        /* check if need decimal the decimal point now */
	if (dp-- == 0)
  149b34:	e0bffb17 	ldw	r2,-20(fp)
  149b38:	1005003a 	cmpeq	r2,r2,zero
  149b3c:	e0fffb17 	ldw	r3,-20(fp)
  149b40:	18ffffc4 	addi	r3,r3,-1
  149b44:	e0fffb15 	stw	r3,-20(fp)
  149b48:	10803fcc 	andi	r2,r2,255
  149b4c:	10000826 	beq	r2,zero,149b70 <cvt_num_field+0x120>
	    /* time for decimal point */
	    s[i++] = '.';
  149b50:	e0bffd17 	ldw	r2,-12(fp)
  149b54:	e0ffff17 	ldw	r3,-4(fp)
  149b58:	1885883a 	add	r2,r3,r2
  149b5c:	00c00b84 	movi	r3,46
  149b60:	10c00005 	stb	r3,0(r2)
  149b64:	e0bffd17 	ldw	r2,-12(fp)
  149b68:	10800044 	addi	r2,r2,1
  149b6c:	e0bffd15 	stw	r2,-12(fp)

	/* get and convert this digit */
	s[i++] = (n / d) + '0';
  149b70:	e0bffd17 	ldw	r2,-12(fp)
  149b74:	e0ffff17 	ldw	r3,-4(fp)
  149b78:	18a1883a 	add	r16,r3,r2
  149b7c:	e13ffe17 	ldw	r4,-8(fp)
  149b80:	e17ffc17 	ldw	r5,-16(fp)
  149b84:	014bcd40 	call	14bcd4 <__divsi3>
  149b88:	10800c04 	addi	r2,r2,48
  149b8c:	80800005 	stb	r2,0(r16)
  149b90:	e0bffd17 	ldw	r2,-12(fp)
  149b94:	10800044 	addi	r2,r2,1
  149b98:	e0bffd15 	stw	r2,-12(fp)
	/* remove this digit from n */
	n %= d;
  149b9c:	e0bffe17 	ldw	r2,-8(fp)
  149ba0:	1009883a 	mov	r4,r2
  149ba4:	e17ffc17 	ldw	r5,-16(fp)
  149ba8:	014bd240 	call	14bd24 <__modsi3>
  149bac:	e0bffe15 	stw	r2,-8(fp)
    /* (assuming 4 digits) */
    dp = 4 - dp;


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  149bb0:	e0bffc17 	ldw	r2,-16(fp)
  149bb4:	1009883a 	mov	r4,r2
  149bb8:	01400284 	movi	r5,10
  149bbc:	014bcd40 	call	14bcd4 <__divsi3>
  149bc0:	e0bffc15 	stw	r2,-16(fp)
  149bc4:	e0bffc17 	ldw	r2,-16(fp)
  149bc8:	00bfda16 	blt	zero,r2,149b34 <cvt_num_field+0xe4>
	n %= d;
    }


    /* all done converting the number, return */
    return;
  149bcc:	0001883a 	nop

}
  149bd0:	e037883a 	mov	sp,fp
  149bd4:	dfc00217 	ldw	ra,8(sp)
  149bd8:	df000117 	ldw	fp,4(sp)
  149bdc:	dc000017 	ldw	r16,0(sp)
  149be0:	dec00304 	addi	sp,sp,12
  149be4:	f800283a 	ret

00149be8 <get_test_sample>:
   Last Modified:    May 3, 2006

*/

void  get_test_sample(long int sample_rate, int sample_size, unsigned char *sample)
{
  149be8:	deff8104 	addi	sp,sp,-508
  149bec:	dfc07e15 	stw	ra,504(sp)
  149bf0:	df007d15 	stw	fp,500(sp)
  149bf4:	df007d04 	addi	fp,sp,500
  149bf8:	e13ffd15 	stw	r4,-12(fp)
  149bfc:	e17ffe15 	stw	r5,-8(fp)
  149c00:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* a half-cycle of the ringing square wave */
    const unsigned char  waveform[] =
  149c04:	00800574 	movhi	r2,21
  149c08:	10b3c204 	addi	r2,r2,-12536
  149c0c:	e13f8504 	addi	r4,fp,-492
  149c10:	1007883a 	mov	r3,r2
  149c14:	00807804 	movi	r2,480
  149c18:	180b883a 	mov	r5,r3
  149c1c:	100d883a 	mov	r6,r2
  149c20:	014bdb80 	call	14bdb8 <memcpy>
	    63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
	    63,  63,  63,  63,  63,  63,  64,  64,  64,  64,  64,  64,  64,
	    64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64
	  };

    long int  sample_pt = 0;	/* current sample within the waveform */
  149c24:	e03f8315 	stw	zero,-500(fp)

    int       sample_sign = 1;	/* sample waveform sign */
  149c28:	00800044 	movi	r2,1
  149c2c:	e0bf8415 	stw	r2,-496(fp)



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  149c30:	00003106 	br	149cf8 <get_test_sample+0x110>

        /* get this sample point (value based on sign) */
	if (sample_sign > 0)
  149c34:	e0bf8417 	ldw	r2,-496(fp)
  149c38:	00800f0e 	bge	zero,r2,149c78 <get_test_sample+0x90>
	    *sample++ = waveform[sample_pt/20] + 127;
  149c3c:	e0bf8317 	ldw	r2,-500(fp)
  149c40:	1009883a 	mov	r4,r2
  149c44:	01400504 	movi	r5,20
  149c48:	014bcd40 	call	14bcd4 <__divsi3>
  149c4c:	e0ff8504 	addi	r3,fp,-492
  149c50:	1885883a 	add	r2,r3,r2
  149c54:	10800003 	ldbu	r2,0(r2)
  149c58:	10801fc4 	addi	r2,r2,127
  149c5c:	1007883a 	mov	r3,r2
  149c60:	e0bfff17 	ldw	r2,-4(fp)
  149c64:	10c00005 	stb	r3,0(r2)
  149c68:	e0bfff17 	ldw	r2,-4(fp)
  149c6c:	10800044 	addi	r2,r2,1
  149c70:	e0bfff15 	stw	r2,-4(fp)
  149c74:	00000f06 	br	149cb4 <get_test_sample+0xcc>
	else
	    *sample++ = 128 - waveform[sample_pt/20];
  149c78:	e0bf8317 	ldw	r2,-500(fp)
  149c7c:	1009883a 	mov	r4,r2
  149c80:	01400504 	movi	r5,20
  149c84:	014bcd40 	call	14bcd4 <__divsi3>
  149c88:	e0ff8504 	addi	r3,fp,-492
  149c8c:	1885883a 	add	r2,r3,r2
  149c90:	10800003 	ldbu	r2,0(r2)
  149c94:	00ffe004 	movi	r3,-128
  149c98:	1885c83a 	sub	r2,r3,r2
  149c9c:	1007883a 	mov	r3,r2
  149ca0:	e0bfff17 	ldw	r2,-4(fp)
  149ca4:	10c00005 	stb	r3,0(r2)
  149ca8:	e0bfff17 	ldw	r2,-4(fp)
  149cac:	10800044 	addi	r2,r2,1
  149cb0:	e0bfff15 	stw	r2,-4(fp)

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
  149cb4:	01002674 	movhi	r4,153
  149cb8:	2125a004 	addi	r4,r4,-27008
  149cbc:	e17ffd17 	ldw	r5,-12(fp)
  149cc0:	014bcd40 	call	14bcd4 <__divsi3>
  149cc4:	e0ff8317 	ldw	r3,-500(fp)
  149cc8:	1885883a 	add	r2,r3,r2
  149ccc:	e0bf8315 	stw	r2,-500(fp)
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  149cd0:	00000606 	br	149cec <get_test_sample+0x104>
	    /* keep sample_pt within the test waveform */
	    sample_pt -= (20 * NO_TEST_PTS);
  149cd4:	e0bf8317 	ldw	r2,-500(fp)
  149cd8:	10b6a004 	addi	r2,r2,-9600
  149cdc:	e0bf8315 	stw	r2,-500(fp)
	    /* each time through the waveform, invert it */
	    sample_sign = -sample_sign;
  149ce0:	e0bf8417 	ldw	r2,-496(fp)
  149ce4:	0085c83a 	sub	r2,zero,r2
  149ce8:	e0bf8415 	stw	r2,-496(fp)
	    *sample++ = 128 - waveform[sample_pt/20];

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  149cec:	e0bf8317 	ldw	r2,-500(fp)
  149cf0:	10896028 	cmpgeui	r2,r2,9600
  149cf4:	103ff71e 	bne	r2,zero,149cd4 <get_test_sample+0xec>
    int       sample_sign = 1;	/* sample waveform sign */



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  149cf8:	e0bffe17 	ldw	r2,-8(fp)
  149cfc:	0084803a 	cmplt	r2,zero,r2
  149d00:	e0fffe17 	ldw	r3,-8(fp)
  149d04:	18ffffc4 	addi	r3,r3,-1
  149d08:	e0fffe15 	stw	r3,-8(fp)
  149d0c:	10803fcc 	andi	r2,r2,255
  149d10:	103fc81e 	bne	r2,zero,149c34 <get_test_sample+0x4c>


    /* done getting the sample - return */
    return;

}
  149d14:	e037883a 	mov	sp,fp
  149d18:	dfc00117 	ldw	ra,4(sp)
  149d1c:	df000017 	ldw	fp,0(sp)
  149d20:	dec00204 	addi	sp,sp,8
  149d24:	f800283a 	ret

00149d28 <init_trace>:
   Last Modified:    May 9, 2006

*/

void  init_trace()
{
  149d28:	defffe04 	addi	sp,sp,-8
  149d2c:	dfc00115 	stw	ra,4(sp)
  149d30:	df000015 	stw	fp,0(sp)
  149d34:	d839883a 	mov	fp,sp


    /* initialize system status variables */

    /* ready for a trace */
    trace_status = TRUE;
  149d38:	00800044 	movi	r2,1
  149d3c:	d0a27f15 	stw	r2,-30212(gp)

    /* not currently sampling data */
    sampling = FALSE;
  149d40:	d0228515 	stw	zero,-30188(gp)

    /* turn off the displayed scale */
    cur_scale = SCALE_NONE;
  149d44:	d0227e15 	stw	zero,-30216(gp)

    /* sample size is the screen size */
    sample_size = SIZE_X;
  149d48:	00807804 	movi	r2,480
  149d4c:	d0a28215 	stw	r2,-30200(gp)


    /* clear save areas */
    clear_saved_areas();
  149d50:	014a2b40 	call	14a2b4 <clear_saved_areas>

    /* also clear the general saved area location variables (off-screen) */
    saved_pos_x = SIZE_X + 1;
  149d54:	00807844 	movi	r2,481
  149d58:	d0a28415 	stw	r2,-30192(gp)
    saved_pos_y = SIZE_Y + 1;
  149d5c:	00804444 	movi	r2,273
  149d60:	d0a28115 	stw	r2,-30204(gp)
    saved_end_x = SIZE_X + 1;
  149d64:	00807844 	movi	r2,481
  149d68:	d0a28315 	stw	r2,-30196(gp)
    saved_end_y = SIZE_Y + 1;
  149d6c:	00804444 	movi	r2,273
  149d70:	d0a28015 	stw	r2,-30208(gp)


    /* done initializing, return */
    return;
  149d74:	0001883a 	nop

}
  149d78:	e037883a 	mov	sp,fp
  149d7c:	dfc00117 	ldw	ra,4(sp)
  149d80:	df000017 	ldw	fp,0(sp)
  149d84:	dec00204 	addi	sp,sp,8
  149d88:	f800283a 	ret

00149d8c <set_mode>:
   Last Modified:    May 27, 2008

*/

void  set_mode(enum trigger_type trigger_mode)
{
  149d8c:	defffe04 	addi	sp,sp,-8
  149d90:	df000115 	stw	fp,4(sp)
  149d94:	df000104 	addi	fp,sp,4
  149d98:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* if not one-shot triggering - ready for trace too */
    trace_status = (trigger_mode != ONESHOT_TRIGGER);
  149d9c:	e0bfff17 	ldw	r2,-4(fp)
  149da0:	10800098 	cmpnei	r2,r2,2
  149da4:	10803fcc 	andi	r2,r2,255
  149da8:	d0a27f15 	stw	r2,-30212(gp)


    /* turn off the sampling flag so will start a new sample */
    sampling = FALSE;
  149dac:	d0228515 	stw	zero,-30188(gp)


    /* all done, return */
    return;
  149db0:	0001883a 	nop

}
  149db4:	e037883a 	mov	sp,fp
  149db8:	df000017 	ldw	fp,0(sp)
  149dbc:	dec00104 	addi	sp,sp,4
  149dc0:	f800283a 	ret

00149dc4 <is_sampling>:
   Last Modified:    May 27, 2008

*/

int  is_sampling()
{
  149dc4:	deffff04 	addi	sp,sp,-4
  149dc8:	df000015 	stw	fp,0(sp)
  149dcc:	d839883a 	mov	fp,sp
      /* none */



    /* currently sampling if sampling flag is set */
    return  sampling;
  149dd0:	d0a28517 	ldw	r2,-30188(gp)

}
  149dd4:	e037883a 	mov	sp,fp
  149dd8:	df000017 	ldw	fp,0(sp)
  149ddc:	dec00104 	addi	sp,sp,4
  149de0:	f800283a 	ret

00149de4 <trace_rdy>:
   Last Modified:    Mar. 13, 1994

*/

int  trace_rdy()
{
  149de4:	deffff04 	addi	sp,sp,-4
  149de8:	df000015 	stw	fp,0(sp)
  149dec:	d839883a 	mov	fp,sp
      /* none */



    /* ready for another trace if not sampling and trace is ready */
    return  (!sampling && trace_status);
  149df0:	d0a28517 	ldw	r2,-30188(gp)
  149df4:	1000041e 	bne	r2,zero,149e08 <trace_rdy+0x24>
  149df8:	d0a27f17 	ldw	r2,-30212(gp)
  149dfc:	10000226 	beq	r2,zero,149e08 <trace_rdy+0x24>
  149e00:	00800044 	movi	r2,1
  149e04:	00000106 	br	149e0c <trace_rdy+0x28>
  149e08:	0005883a 	mov	r2,zero

}
  149e0c:	e037883a 	mov	sp,fp
  149e10:	df000017 	ldw	fp,0(sp)
  149e14:	dec00104 	addi	sp,sp,4
  149e18:	f800283a 	ret

00149e1c <trace_done>:
   Last Modified:    May 9, 2006

*/

void  trace_done()
{
  149e1c:	defffe04 	addi	sp,sp,-8
  149e20:	dfc00115 	stw	ra,4(sp)
  149e24:	df000015 	stw	fp,0(sp)
  149e28:	d839883a 	mov	fp,sp
      /* none */



    /* done with a trace - if retriggering, ready for another one */
    if (get_trigger_mode() != ONESHOT_TRIGGER)
  149e2c:	0148f100 	call	148f10 <get_trigger_mode>
  149e30:	108000a0 	cmpeqi	r2,r2,2
  149e34:	1000021e 	bne	r2,zero,149e40 <trace_done+0x24>
        /* in a retriggering mode - set trace_status to TRUE (ready) */
	trace_status = TRUE;
  149e38:	00800044 	movi	r2,1
  149e3c:	d0a27f15 	stw	r2,-30212(gp)

    /* no longer sampling data */
    sampling = FALSE;
  149e40:	d0228515 	stw	zero,-30188(gp)


    /* done so return */
    return;
  149e44:	0001883a 	nop

}
  149e48:	e037883a 	mov	sp,fp
  149e4c:	dfc00117 	ldw	ra,4(sp)
  149e50:	df000017 	ldw	fp,0(sp)
  149e54:	dec00204 	addi	sp,sp,8
  149e58:	f800283a 	ret

00149e5c <trace_rearm>:
   Last Modified:    Mar. 8, 1994

*/

void  trace_rearm()
{
  149e5c:	deffff04 	addi	sp,sp,-4
  149e60:	df000015 	stw	fp,0(sp)
  149e64:	d839883a 	mov	fp,sp
      /* none */



    /* rearm the trace - set status to ready (TRUE) */
    trace_status = TRUE;
  149e68:	00800044 	movi	r2,1
  149e6c:	d0a27f15 	stw	r2,-30212(gp)


    /* all done - return */
    return;
  149e70:	0001883a 	nop

}
  149e74:	e037883a 	mov	sp,fp
  149e78:	df000017 	ldw	fp,0(sp)
  149e7c:	dec00104 	addi	sp,sp,4
  149e80:	f800283a 	ret

00149e84 <set_trace_size>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trace_size(int size)
{
  149e84:	defffe04 	addi	sp,sp,-8
  149e88:	df000115 	stw	fp,4(sp)
  149e8c:	df000104 	addi	fp,sp,4
  149e90:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the locally global sample size */
    sample_size = size;
  149e94:	e0bfff17 	ldw	r2,-4(fp)
  149e98:	d0a28215 	stw	r2,-30200(gp)


    /* all done, return */
    return;
  149e9c:	0001883a 	nop

}
  149ea0:	e037883a 	mov	sp,fp
  149ea4:	df000017 	ldw	fp,0(sp)
  149ea8:	dec00104 	addi	sp,sp,4
  149eac:	f800283a 	ret

00149eb0 <set_display_scale>:
   Last Modified:    May 9, 2006

*/

void  set_display_scale(enum scale_type scale)
{
  149eb0:	defff804 	addi	sp,sp,-32
  149eb4:	dfc00715 	stw	ra,28(sp)
  149eb8:	df000615 	stw	fp,24(sp)
  149ebc:	dc400515 	stw	r17,20(sp)
  149ec0:	dc000415 	stw	r16,16(sp)
  149ec4:	df000404 	addi	fp,sp,16
  149ec8:	e13fff15 	stw	r4,-4(fp)



    /* whenever change scale type, need to clear out previous scale */
    /* unnecessary if going to SCALE_GRID or from SCALE_NONE or not changing the scale */
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {
  149ecc:	e0bfff17 	ldw	r2,-4(fp)
  149ed0:	108000a0 	cmpeqi	r2,r2,2
  149ed4:	1000951e 	bne	r2,zero,14a12c <set_display_scale+0x27c>
  149ed8:	d0a27e17 	ldw	r2,-30216(gp)
  149edc:	10009326 	beq	r2,zero,14a12c <set_display_scale+0x27c>
  149ee0:	d0a27e17 	ldw	r2,-30216(gp)
  149ee4:	e0ffff17 	ldw	r3,-4(fp)
  149ee8:	18809026 	beq	r3,r2,14a12c <set_display_scale+0x27c>

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  149eec:	00bfff84 	movi	r2,-2
  149ef0:	e0bffe15 	stw	r2,-8(fp)
  149ef4:	00004206 	br	14a000 <set_display_scale+0x150>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  149ef8:	e13ffe17 	ldw	r4,-8(fp)
  149efc:	01400c04 	movi	r5,48
  149f00:	014bd900 	call	14bd90 <__mulsi3>
  149f04:	10802204 	addi	r2,r2,136
  149f08:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  149f0c:	e0bffc17 	ldw	r2,-16(fp)
  149f10:	10804410 	cmplti	r2,r2,272
  149f14:	1000021e 	bne	r2,zero,149f20 <set_display_scale+0x70>
	        p = PLOT_SIZE_Y - 1;
  149f18:	008043c4 	movi	r2,271
  149f1c:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  149f20:	e0bffc17 	ldw	r2,-16(fp)
  149f24:	1000010e 	bge	r2,zero,149f2c <set_display_scale+0x7c>
	        p = 0;
  149f28:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  149f2c:	e03ffd15 	stw	zero,-12(fp)
  149f30:	00002d06 	br	149fe8 <set_display_scale+0x138>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_x[j + Y_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  149f34:	e0bffe17 	ldw	r2,-8(fp)
  149f38:	10c00084 	addi	r3,r2,2
  149f3c:	e0bffd17 	ldw	r2,-12(fp)
  149f40:	1000010e 	bge	r2,zero,149f48 <set_display_scale+0x98>
  149f44:	108001c4 	addi	r2,r2,7
  149f48:	1005d0fa 	srai	r2,r2,3
  149f4c:	1023883a 	mov	r17,r2
  149f50:	04000574 	movhi	r16,21
  149f54:	843a3284 	addi	r16,r16,-5942
  149f58:	1809883a 	mov	r4,r3
  149f5c:	01400f04 	movi	r5,60
  149f60:	014bd900 	call	14bd90 <__mulsi3>
  149f64:	1445883a 	add	r2,r2,r17
  149f68:	8085883a 	add	r2,r16,r2
  149f6c:	10800003 	ldbu	r2,0(r2)
  149f70:	10c03fcc 	andi	r3,r2,255
  149f74:	e13ffd17 	ldw	r4,-12(fp)
  149f78:	00a00034 	movhi	r2,32768
  149f7c:	108001c4 	addi	r2,r2,7
  149f80:	2084703a 	and	r2,r4,r2
  149f84:	1000040e 	bge	r2,zero,149f98 <set_display_scale+0xe8>
  149f88:	10bfffc4 	addi	r2,r2,-1
  149f8c:	013ffe04 	movi	r4,-8
  149f90:	1104b03a 	or	r2,r2,r4
  149f94:	10800044 	addi	r2,r2,1
  149f98:	01002004 	movi	r4,128
  149f9c:	2085d83a 	sra	r2,r4,r2
  149fa0:	1884703a 	and	r2,r3,r2
  149fa4:	1000071e 	bne	r2,zero,149fc4 <set_display_scale+0x114>
		    /* saved pixel is off */
		    plot_pixel(i, p, PIXEL_WHITE);
  149fa8:	e0fffd17 	ldw	r3,-12(fp)
  149fac:	e0bffc17 	ldw	r2,-16(fp)
  149fb0:	1809883a 	mov	r4,r3
  149fb4:	100b883a 	mov	r5,r2
  149fb8:	01bfdfd4 	movui	r6,65407
  149fbc:	014b7f40 	call	14b7f4 <plot_pixel>
  149fc0:	00000606 	br	149fdc <set_display_scale+0x12c>
		else
		    /* saved pixel is on */
		    plot_pixel(i, p, PIXEL_BLACK);
  149fc4:	e0fffd17 	ldw	r3,-12(fp)
  149fc8:	e0bffc17 	ldw	r2,-16(fp)
  149fcc:	1809883a 	mov	r4,r3
  149fd0:	100b883a 	mov	r5,r2
  149fd4:	000d883a 	mov	r6,zero
  149fd8:	014b7f40 	call	14b7f4 <plot_pixel>
	        p = PLOT_SIZE_Y - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  149fdc:	e0bffd17 	ldw	r2,-12(fp)
  149fe0:	10800044 	addi	r2,r2,1
  149fe4:	e0bffd15 	stw	r2,-12(fp)
  149fe8:	e0bffd17 	ldw	r2,-12(fp)
  149fec:	10807810 	cmplti	r2,r2,480
  149ff0:	103fd01e 	bne	r2,zero,149f34 <set_display_scale+0x84>
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  149ff4:	e0bffe17 	ldw	r2,-8(fp)
  149ff8:	10800044 	addi	r2,r2,1
  149ffc:	e0bffe15 	stw	r2,-8(fp)
  14a000:	e0bffe17 	ldw	r2,-8(fp)
  14a004:	108000d0 	cmplti	r2,r2,3
  14a008:	103fbb1e 	bne	r2,zero,149ef8 <set_display_scale+0x48>
		    plot_pixel(i, p, PIXEL_BLACK);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  14a00c:	00bffec4 	movi	r2,-5
  14a010:	e0bffe15 	stw	r2,-8(fp)
  14a014:	00004206 	br	14a120 <set_display_scale+0x270>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  14a018:	e13ffe17 	ldw	r4,-8(fp)
  14a01c:	01400c04 	movi	r5,48
  14a020:	014bd900 	call	14bd90 <__mulsi3>
  14a024:	10803c04 	addi	r2,r2,240
  14a028:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  14a02c:	e0bffc17 	ldw	r2,-16(fp)
  14a030:	10807810 	cmplti	r2,r2,480
  14a034:	1000021e 	bne	r2,zero,14a040 <set_display_scale+0x190>
	        p = PLOT_SIZE_X - 1;
  14a038:	008077c4 	movi	r2,479
  14a03c:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  14a040:	e0bffc17 	ldw	r2,-16(fp)
  14a044:	1000010e 	bge	r2,zero,14a04c <set_display_scale+0x19c>
	        p = 0;
  14a048:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  14a04c:	e03ffd15 	stw	zero,-12(fp)
  14a050:	00002d06 	br	14a108 <set_display_scale+0x258>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_y[j + X_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  14a054:	e0bffe17 	ldw	r2,-8(fp)
  14a058:	10c00144 	addi	r3,r2,5
  14a05c:	e0bffd17 	ldw	r2,-12(fp)
  14a060:	1000010e 	bge	r2,zero,14a068 <set_display_scale+0x1b8>
  14a064:	108001c4 	addi	r2,r2,7
  14a068:	1005d0fa 	srai	r2,r2,3
  14a06c:	1023883a 	mov	r17,r2
  14a070:	04000574 	movhi	r16,21
  14a074:	8439d504 	addi	r16,r16,-6316
  14a078:	1809883a 	mov	r4,r3
  14a07c:	01400884 	movi	r5,34
  14a080:	014bd900 	call	14bd90 <__mulsi3>
  14a084:	1445883a 	add	r2,r2,r17
  14a088:	8085883a 	add	r2,r16,r2
  14a08c:	10800003 	ldbu	r2,0(r2)
  14a090:	10c03fcc 	andi	r3,r2,255
  14a094:	e13ffd17 	ldw	r4,-12(fp)
  14a098:	00a00034 	movhi	r2,32768
  14a09c:	108001c4 	addi	r2,r2,7
  14a0a0:	2084703a 	and	r2,r4,r2
  14a0a4:	1000040e 	bge	r2,zero,14a0b8 <set_display_scale+0x208>
  14a0a8:	10bfffc4 	addi	r2,r2,-1
  14a0ac:	013ffe04 	movi	r4,-8
  14a0b0:	1104b03a 	or	r2,r2,r4
  14a0b4:	10800044 	addi	r2,r2,1
  14a0b8:	01002004 	movi	r4,128
  14a0bc:	2085d83a 	sra	r2,r4,r2
  14a0c0:	1884703a 	and	r2,r3,r2
  14a0c4:	1000071e 	bne	r2,zero,14a0e4 <set_display_scale+0x234>
		    /* saved pixel is off */
		    plot_pixel(p, i, PIXEL_WHITE);
  14a0c8:	e0fffc17 	ldw	r3,-16(fp)
  14a0cc:	e0bffd17 	ldw	r2,-12(fp)
  14a0d0:	1809883a 	mov	r4,r3
  14a0d4:	100b883a 	mov	r5,r2
  14a0d8:	01bfdfd4 	movui	r6,65407
  14a0dc:	014b7f40 	call	14b7f4 <plot_pixel>
  14a0e0:	00000606 	br	14a0fc <set_display_scale+0x24c>
		else
		    /* saved pixel is on */
		    plot_pixel(p, i, PIXEL_BLACK);
  14a0e4:	e0fffc17 	ldw	r3,-16(fp)
  14a0e8:	e0bffd17 	ldw	r2,-12(fp)
  14a0ec:	1809883a 	mov	r4,r3
  14a0f0:	100b883a 	mov	r5,r2
  14a0f4:	000d883a 	mov	r6,zero
  14a0f8:	014b7f40 	call	14b7f4 <plot_pixel>
	        p = PLOT_SIZE_X - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  14a0fc:	e0bffd17 	ldw	r2,-12(fp)
  14a100:	10800044 	addi	r2,r2,1
  14a104:	e0bffd15 	stw	r2,-12(fp)
  14a108:	e0bffd17 	ldw	r2,-12(fp)
  14a10c:	10804410 	cmplti	r2,r2,272
  14a110:	103fd01e 	bne	r2,zero,14a054 <set_display_scale+0x1a4>
		    plot_pixel(i, p, PIXEL_BLACK);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  14a114:	e0bffe17 	ldw	r2,-8(fp)
  14a118:	10800044 	addi	r2,r2,1
  14a11c:	e0bffe15 	stw	r2,-8(fp)
  14a120:	e0bffe17 	ldw	r2,-8(fp)
  14a124:	10800190 	cmplti	r2,r2,6
  14a128:	103fbb1e 	bne	r2,zero,14a018 <set_display_scale+0x168>
	}
    }


    /* now handle the scale type appropriately */
    switch (scale)  {
  14a12c:	e0bfff17 	ldw	r2,-4(fp)
  14a130:	10005526 	beq	r2,zero,14a288 <set_display_scale+0x3d8>
  14a134:	108000e8 	cmpgeui	r2,r2,3
  14a138:	1000541e 	bne	r2,zero,14a28c <set_display_scale+0x3dc>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  14a13c:	00bfff84 	movi	r2,-2
  14a140:	e0bffd15 	stw	r2,-12(fp)
  14a144:	00002306 	br	14a1d4 <set_display_scale+0x324>

				/* get y position of the line */
				p = X_AXIS_POS + i * Y_TICK_SIZE;
  14a148:	e13ffd17 	ldw	r4,-12(fp)
  14a14c:	01400c04 	movi	r5,48
  14a150:	014bd900 	call	14bd90 <__mulsi3>
  14a154:	10802204 	addi	r2,r2,136
  14a158:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_Y)
  14a15c:	e0bffc17 	ldw	r2,-16(fp)
  14a160:	10804410 	cmplti	r2,r2,272
  14a164:	1000021e 	bne	r2,zero,14a170 <set_display_scale+0x2c0>
				    p = PLOT_SIZE_Y - 1;
  14a168:	008043c4 	movi	r2,271
  14a16c:	e0bffc15 	stw	r2,-16(fp)
				if (p < 0)
  14a170:	e0bffc17 	ldw	r2,-16(fp)
  14a174:	1000010e 	bge	r2,zero,14a17c <set_display_scale+0x2cc>
				    p = 0;
  14a178:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  14a17c:	e0bfff17 	ldw	r2,-4(fp)
  14a180:	10800098 	cmpnei	r2,r2,2
  14a184:	1000051e 	bne	r2,zero,14a19c <set_display_scale+0x2ec>
				    /* drawing a grid line */
			            plot_hline(X_GRID_START, p, (X_GRID_END - X_GRID_START));
  14a188:	0009883a 	mov	r4,zero
  14a18c:	e17ffc17 	ldw	r5,-16(fp)
  14a190:	018077c4 	movi	r6,479
  14a194:	01483d00 	call	1483d0 <plot_hline>
  14a198:	00000b06 	br	14a1c8 <set_display_scale+0x318>
				else if (i == 0)
  14a19c:	e0bffd17 	ldw	r2,-12(fp)
  14a1a0:	1000051e 	bne	r2,zero,14a1b8 <set_display_scale+0x308>
				    /* drawing the x axis */
			            plot_hline(X_AXIS_START, p, (X_AXIS_END - X_AXIS_START));
  14a1a4:	0009883a 	mov	r4,zero
  14a1a8:	e17ffc17 	ldw	r5,-16(fp)
  14a1ac:	018077c4 	movi	r6,479
  14a1b0:	01483d00 	call	1483d0 <plot_hline>
  14a1b4:	00000406 	br	14a1c8 <set_display_scale+0x318>
				else
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
  14a1b8:	01003b84 	movi	r4,238
  14a1bc:	e17ffc17 	ldw	r5,-16(fp)
  14a1c0:	01800144 	movi	r6,5
  14a1c4:	01483d00 	call	1483d0 <plot_hline>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  14a1c8:	e0bffd17 	ldw	r2,-12(fp)
  14a1cc:	10800044 	addi	r2,r2,1
  14a1d0:	e0bffd15 	stw	r2,-12(fp)
  14a1d4:	e0bffd17 	ldw	r2,-12(fp)
  14a1d8:	108000d0 	cmplti	r2,r2,3
  14a1dc:	103fda1e 	bne	r2,zero,14a148 <set_display_scale+0x298>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  14a1e0:	00bffec4 	movi	r2,-5
  14a1e4:	e0bffd15 	stw	r2,-12(fp)
  14a1e8:	00002306 	br	14a278 <set_display_scale+0x3c8>

				/* get x position of the line */
				p = Y_AXIS_POS + i * X_TICK_SIZE;
  14a1ec:	e13ffd17 	ldw	r4,-12(fp)
  14a1f0:	01400c04 	movi	r5,48
  14a1f4:	014bd900 	call	14bd90 <__mulsi3>
  14a1f8:	10803c04 	addi	r2,r2,240
  14a1fc:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_X)
  14a200:	e0bffc17 	ldw	r2,-16(fp)
  14a204:	10807810 	cmplti	r2,r2,480
  14a208:	1000021e 	bne	r2,zero,14a214 <set_display_scale+0x364>
				    p = PLOT_SIZE_X - 1;
  14a20c:	008077c4 	movi	r2,479
  14a210:	e0bffc15 	stw	r2,-16(fp)
			        if (p < 0)
  14a214:	e0bffc17 	ldw	r2,-16(fp)
  14a218:	1000010e 	bge	r2,zero,14a220 <set_display_scale+0x370>
				    p = 0;
  14a21c:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  14a220:	e0bfff17 	ldw	r2,-4(fp)
  14a224:	10800098 	cmpnei	r2,r2,2
  14a228:	1000051e 	bne	r2,zero,14a240 <set_display_scale+0x390>
				    /* drawing a grid line */
			            plot_vline(p, Y_GRID_START, (Y_GRID_END - Y_GRID_START));
  14a22c:	e13ffc17 	ldw	r4,-16(fp)
  14a230:	000b883a 	mov	r5,zero
  14a234:	018043c4 	movi	r6,271
  14a238:	014847c0 	call	14847c <plot_vline>
  14a23c:	00000b06 	br	14a26c <set_display_scale+0x3bc>
				else if (i == 0)
  14a240:	e0bffd17 	ldw	r2,-12(fp)
  14a244:	1000051e 	bne	r2,zero,14a25c <set_display_scale+0x3ac>
				    /* drawing the y axis */
			            plot_vline(p, Y_AXIS_START, (Y_AXIS_END - Y_AXIS_START));
  14a248:	e13ffc17 	ldw	r4,-16(fp)
  14a24c:	000b883a 	mov	r5,zero
  14a250:	018043c4 	movi	r6,271
  14a254:	014847c0 	call	14847c <plot_vline>
  14a258:	00000406 	br	14a26c <set_display_scale+0x3bc>
				else
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
  14a25c:	e13ffc17 	ldw	r4,-16(fp)
  14a260:	01402184 	movi	r5,134
  14a264:	01800144 	movi	r6,5
  14a268:	014847c0 	call	14847c <plot_vline>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  14a26c:	e0bffd17 	ldw	r2,-12(fp)
  14a270:	10800044 	addi	r2,r2,1
  14a274:	e0bffd15 	stw	r2,-12(fp)
  14a278:	e0bffd17 	ldw	r2,-12(fp)
  14a27c:	10800190 	cmplti	r2,r2,6
  14a280:	103fda1e 	bne	r2,zero,14a1ec <set_display_scale+0x33c>
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
			    }

			    /* done with the axes */
			    break;
  14a284:	00000106 	br	14a28c <set_display_scale+0x3dc>

        case SCALE_NONE:    /* there is no scale */
			    /* already restored plot so nothing to do */
			    break;
  14a288:	0001883a 	nop

    }


    /* now remember the new (now current) scale type */
    cur_scale = scale;
  14a28c:	e0bfff17 	ldw	r2,-4(fp)
  14a290:	d0a27e15 	stw	r2,-30216(gp)


    /* scale is taken care of, return */
    return;
  14a294:	0001883a 	nop

}
  14a298:	e037883a 	mov	sp,fp
  14a29c:	dfc00317 	ldw	ra,12(sp)
  14a2a0:	df000217 	ldw	fp,8(sp)
  14a2a4:	dc400117 	ldw	r17,4(sp)
  14a2a8:	dc000017 	ldw	r16,0(sp)
  14a2ac:	dec00404 	addi	sp,sp,16
  14a2b0:	f800283a 	ret

0014a2b4 <clear_saved_areas>:
   Last Modified:    May 9, 2006

*/

void  clear_saved_areas()
{
  14a2b4:	defffb04 	addi	sp,sp,-20
  14a2b8:	dfc00415 	stw	ra,16(sp)
  14a2bc:	df000315 	stw	fp,12(sp)
  14a2c0:	dc000215 	stw	r16,8(sp)
  14a2c4:	df000204 	addi	fp,sp,8
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  14a2c8:	e03fff15 	stw	zero,-4(fp)
  14a2cc:	00001506 	br	14a324 <clear_saved_areas+0x70>
        for (i = 0; i < (SIZE_X / 8); i++)
  14a2d0:	e03ffe15 	stw	zero,-8(fp)
  14a2d4:	00000d06 	br	14a30c <clear_saved_areas+0x58>
            saved_axis_x[j][i] = 0;
  14a2d8:	04000574 	movhi	r16,21
  14a2dc:	843a3284 	addi	r16,r16,-5942
  14a2e0:	e0bfff17 	ldw	r2,-4(fp)
  14a2e4:	1009883a 	mov	r4,r2
  14a2e8:	01400f04 	movi	r5,60
  14a2ec:	014bd900 	call	14bd90 <__mulsi3>
  14a2f0:	e0fffe17 	ldw	r3,-8(fp)
  14a2f4:	10c5883a 	add	r2,r2,r3
  14a2f8:	8085883a 	add	r2,r16,r2
  14a2fc:	10000005 	stb	zero,0(r2)



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
  14a300:	e0bffe17 	ldw	r2,-8(fp)
  14a304:	10800044 	addi	r2,r2,1
  14a308:	e0bffe15 	stw	r2,-8(fp)
  14a30c:	e0bffe17 	ldw	r2,-8(fp)
  14a310:	10800f10 	cmplti	r2,r2,60
  14a314:	103ff01e 	bne	r2,zero,14a2d8 <clear_saved_areas+0x24>
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  14a318:	e0bfff17 	ldw	r2,-4(fp)
  14a31c:	10800044 	addi	r2,r2,1
  14a320:	e0bfff15 	stw	r2,-4(fp)
  14a324:	e0bfff17 	ldw	r2,-4(fp)
  14a328:	10800150 	cmplti	r2,r2,5
  14a32c:	103fe81e 	bne	r2,zero,14a2d0 <clear_saved_areas+0x1c>
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  14a330:	e03fff15 	stw	zero,-4(fp)
  14a334:	00001506 	br	14a38c <clear_saved_areas+0xd8>
        for (i = 0; i < (SIZE_Y / 8); i++)
  14a338:	e03ffe15 	stw	zero,-8(fp)
  14a33c:	00000d06 	br	14a374 <clear_saved_areas+0xc0>
            saved_axis_y[j][i] = 0;
  14a340:	04000574 	movhi	r16,21
  14a344:	8439d504 	addi	r16,r16,-6316
  14a348:	e0bfff17 	ldw	r2,-4(fp)
  14a34c:	1009883a 	mov	r4,r2
  14a350:	01400884 	movi	r5,34
  14a354:	014bd900 	call	14bd90 <__mulsi3>
  14a358:	e0fffe17 	ldw	r3,-8(fp)
  14a35c:	10c5883a 	add	r2,r2,r3
  14a360:	8085883a 	add	r2,r16,r2
  14a364:	10000005 	stb	zero,0(r2)
    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
  14a368:	e0bffe17 	ldw	r2,-8(fp)
  14a36c:	10800044 	addi	r2,r2,1
  14a370:	e0bffe15 	stw	r2,-8(fp)
  14a374:	e0bffe17 	ldw	r2,-8(fp)
  14a378:	10800890 	cmplti	r2,r2,34
  14a37c:	103ff01e 	bne	r2,zero,14a340 <clear_saved_areas+0x8c>

    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  14a380:	e0bfff17 	ldw	r2,-4(fp)
  14a384:	10800044 	addi	r2,r2,1
  14a388:	e0bfff15 	stw	r2,-4(fp)
  14a38c:	e0bfff17 	ldw	r2,-4(fp)
  14a390:	108002d0 	cmplti	r2,r2,11
  14a394:	103fe81e 	bne	r2,zero,14a338 <clear_saved_areas+0x84>
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  14a398:	e03ffe15 	stw	zero,-8(fp)
  14a39c:	00001506 	br	14a3f4 <clear_saved_areas+0x140>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  14a3a0:	e03fff15 	stw	zero,-4(fp)
  14a3a4:	00000d06 	br	14a3dc <clear_saved_areas+0x128>
	    saved_menu[i][j] = 0;
  14a3a8:	04000574 	movhi	r16,21
  14a3ac:	84392d04 	addi	r16,r16,-6988
  14a3b0:	e0bffe17 	ldw	r2,-8(fp)
  14a3b4:	1009883a 	mov	r4,r2
  14a3b8:	01400304 	movi	r5,12
  14a3bc:	014bd900 	call	14bd90 <__mulsi3>
  14a3c0:	e0ffff17 	ldw	r3,-4(fp)
  14a3c4:	10c5883a 	add	r2,r2,r3
  14a3c8:	8085883a 	add	r2,r16,r2
  14a3cc:	10000005 	stb	zero,0(r2)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  14a3d0:	e0bfff17 	ldw	r2,-4(fp)
  14a3d4:	10800044 	addi	r2,r2,1
  14a3d8:	e0bfff15 	stw	r2,-4(fp)
  14a3dc:	e0bfff17 	ldw	r2,-4(fp)
  14a3e0:	10800310 	cmplti	r2,r2,12
  14a3e4:	103ff01e 	bne	r2,zero,14a3a8 <clear_saved_areas+0xf4>
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  14a3e8:	e0bffe17 	ldw	r2,-8(fp)
  14a3ec:	10800044 	addi	r2,r2,1
  14a3f0:	e0bffe15 	stw	r2,-8(fp)
  14a3f4:	e0bffe17 	ldw	r2,-8(fp)
  14a3f8:	10800e10 	cmplti	r2,r2,56
  14a3fc:	103fe81e 	bne	r2,zero,14a3a0 <clear_saved_areas+0xec>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  14a400:	e03ffe15 	stw	zero,-8(fp)
  14a404:	00001506 	br	14a45c <clear_saved_areas+0x1a8>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  14a408:	e03fff15 	stw	zero,-4(fp)
  14a40c:	00000d06 	br	14a444 <clear_saved_areas+0x190>
	    saved_area[i][j] = 0;
  14a410:	04000574 	movhi	r16,21
  14a414:	843a7d84 	addi	r16,r16,-5642
  14a418:	e0bffe17 	ldw	r2,-8(fp)
  14a41c:	1009883a 	mov	r4,r2
  14a420:	014003c4 	movi	r5,15
  14a424:	014bd900 	call	14bd90 <__mulsi3>
  14a428:	e0ffff17 	ldw	r3,-4(fp)
  14a42c:	10c5883a 	add	r2,r2,r3
  14a430:	8085883a 	add	r2,r16,r2
  14a434:	10000005 	stb	zero,0(r2)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  14a438:	e0bfff17 	ldw	r2,-4(fp)
  14a43c:	10800044 	addi	r2,r2,1
  14a440:	e0bfff15 	stw	r2,-4(fp)
  14a444:	e0bfff17 	ldw	r2,-4(fp)
  14a448:	108003d0 	cmplti	r2,r2,15
  14a44c:	103ff01e 	bne	r2,zero,14a410 <clear_saved_areas+0x15c>
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  14a450:	e0bffe17 	ldw	r2,-8(fp)
  14a454:	10800044 	addi	r2,r2,1
  14a458:	e0bffe15 	stw	r2,-8(fp)
  14a45c:	e0bffe17 	ldw	r2,-8(fp)
  14a460:	10800410 	cmplti	r2,r2,16
  14a464:	103fe81e 	bne	r2,zero,14a408 <clear_saved_areas+0x154>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
	    saved_area[i][j] = 0;


    /* done clearing the saved areas - return */
    return;
  14a468:	0001883a 	nop

}
  14a46c:	e037883a 	mov	sp,fp
  14a470:	dfc00217 	ldw	ra,8(sp)
  14a474:	df000117 	ldw	fp,4(sp)
  14a478:	dc000017 	ldw	r16,0(sp)
  14a47c:	dec00304 	addi	sp,sp,12
  14a480:	f800283a 	ret

0014a484 <restore_menu_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_menu_trace()
{
  14a484:	defff904 	addi	sp,sp,-28
  14a488:	dfc00615 	stw	ra,24(sp)
  14a48c:	df000515 	stw	fp,20(sp)
  14a490:	dc000415 	stw	r16,16(sp)
  14a494:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  14a498:	e03fff15 	stw	zero,-4(fp)
  14a49c:	00003406 	br	14a570 <restore_menu_trace+0xec>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  14a4a0:	00802004 	movi	r2,128
  14a4a4:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  14a4a8:	e03ffd15 	stw	zero,-12(fp)

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  14a4ac:	00805e84 	movi	r2,378
  14a4b0:	e0bffe15 	stw	r2,-8(fp)
  14a4b4:	00002806 	br	14a558 <restore_menu_trace+0xd4>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_menu[y - MENU_UL_Y][bit_offset] & bit_position) == 0)
  14a4b8:	04000574 	movhi	r16,21
  14a4bc:	84392d04 	addi	r16,r16,-6988
  14a4c0:	e0bfff17 	ldw	r2,-4(fp)
  14a4c4:	1009883a 	mov	r4,r2
  14a4c8:	01400304 	movi	r5,12
  14a4cc:	014bd900 	call	14bd90 <__mulsi3>
  14a4d0:	e0fffd17 	ldw	r3,-12(fp)
  14a4d4:	10c5883a 	add	r2,r2,r3
  14a4d8:	8085883a 	add	r2,r16,r2
  14a4dc:	10800003 	ldbu	r2,0(r2)
  14a4e0:	10c03fcc 	andi	r3,r2,255
  14a4e4:	e0bffc17 	ldw	r2,-16(fp)
  14a4e8:	1884703a 	and	r2,r3,r2
  14a4ec:	1000071e 	bne	r2,zero,14a50c <restore_menu_trace+0x88>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_WHITE);
  14a4f0:	e0fffe17 	ldw	r3,-8(fp)
  14a4f4:	e0bfff17 	ldw	r2,-4(fp)
  14a4f8:	1809883a 	mov	r4,r3
  14a4fc:	100b883a 	mov	r5,r2
  14a500:	01bfdfd4 	movui	r6,65407
  14a504:	014b7f40 	call	14b7f4 <plot_pixel>
  14a508:	00000606 	br	14a524 <restore_menu_trace+0xa0>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_BLACK);
  14a50c:	e0fffe17 	ldw	r3,-8(fp)
  14a510:	e0bfff17 	ldw	r2,-4(fp)
  14a514:	1809883a 	mov	r4,r3
  14a518:	100b883a 	mov	r5,r2
  14a51c:	000d883a 	mov	r6,zero
  14a520:	014b7f40 	call	14b7f4 <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  14a524:	e0bffc17 	ldw	r2,-16(fp)
  14a528:	1005d07a 	srai	r2,r2,1
  14a52c:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  14a530:	e0bffc17 	ldw	r2,-16(fp)
  14a534:	1000051e 	bne	r2,zero,14a54c <restore_menu_trace+0xc8>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  14a538:	00802004 	movi	r2,128
  14a53c:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  14a540:	e0bffd17 	ldw	r2,-12(fp)
  14a544:	10800044 	addi	r2,r2,1
  14a548:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  14a54c:	e0bffe17 	ldw	r2,-8(fp)
  14a550:	10800044 	addi	r2,r2,1
  14a554:	e0bffe15 	stw	r2,-8(fp)
  14a558:	e0bffe17 	ldw	r2,-8(fp)
  14a55c:	10807690 	cmplti	r2,r2,474
  14a560:	103fd51e 	bne	r2,zero,14a4b8 <restore_menu_trace+0x34>
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  14a564:	e0bfff17 	ldw	r2,-4(fp)
  14a568:	10800044 	addi	r2,r2,1
  14a56c:	e0bfff15 	stw	r2,-4(fp)
  14a570:	e0bfff17 	ldw	r2,-4(fp)
  14a574:	10800e10 	cmplti	r2,r2,56
  14a578:	103fc91e 	bne	r2,zero,14a4a0 <restore_menu_trace+0x1c>
        }
    }


    /* restored menu area - return */
    return;
  14a57c:	0001883a 	nop

}
  14a580:	e037883a 	mov	sp,fp
  14a584:	dfc00217 	ldw	ra,8(sp)
  14a588:	df000117 	ldw	fp,4(sp)
  14a58c:	dc000017 	ldw	r16,0(sp)
  14a590:	dec00304 	addi	sp,sp,12
  14a594:	f800283a 	ret

0014a598 <set_save_area>:
   Last Modified:    Mar. 8, 1994

*/

void  set_save_area(int pos_x, int pos_y, int size_x, int size_y)
{
  14a598:	defff704 	addi	sp,sp,-36
  14a59c:	dfc00815 	stw	ra,32(sp)
  14a5a0:	df000715 	stw	fp,28(sp)
  14a5a4:	dc000615 	stw	r16,24(sp)
  14a5a8:	df000604 	addi	fp,sp,24
  14a5ac:	e13ffc15 	stw	r4,-16(fp)
  14a5b0:	e17ffd15 	stw	r5,-12(fp)
  14a5b4:	e1bffe15 	stw	r6,-8(fp)
  14a5b8:	e1ffff15 	stw	r7,-4(fp)
    int  y;



    /* just setup all the locally global variables from the passed values */
    saved_pos_x = pos_x;
  14a5bc:	e0bffc17 	ldw	r2,-16(fp)
  14a5c0:	d0a28415 	stw	r2,-30192(gp)
    saved_pos_y = pos_y;
  14a5c4:	e0bffd17 	ldw	r2,-12(fp)
  14a5c8:	d0a28115 	stw	r2,-30204(gp)
    saved_end_x = pos_x + size_x;
  14a5cc:	e0fffc17 	ldw	r3,-16(fp)
  14a5d0:	e0bffe17 	ldw	r2,-8(fp)
  14a5d4:	1885883a 	add	r2,r3,r2
  14a5d8:	d0a28315 	stw	r2,-30196(gp)
    saved_end_y = pos_y + size_y;
  14a5dc:	e0fffd17 	ldw	r3,-12(fp)
  14a5e0:	e0bfff17 	ldw	r2,-4(fp)
  14a5e4:	1885883a 	add	r2,r3,r2
  14a5e8:	d0a28015 	stw	r2,-30208(gp)


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  14a5ec:	e03ffb15 	stw	zero,-20(fp)
  14a5f0:	00001506 	br	14a648 <set_save_area+0xb0>
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  14a5f4:	e03ffa15 	stw	zero,-24(fp)
  14a5f8:	00000d06 	br	14a630 <set_save_area+0x98>
	    saved_area[y][x] = 0;
  14a5fc:	04000574 	movhi	r16,21
  14a600:	843a7d84 	addi	r16,r16,-5642
  14a604:	e0bffb17 	ldw	r2,-20(fp)
  14a608:	1009883a 	mov	r4,r2
  14a60c:	014003c4 	movi	r5,15
  14a610:	014bd900 	call	14bd90 <__mulsi3>
  14a614:	e0fffa17 	ldw	r3,-24(fp)
  14a618:	10c5883a 	add	r2,r2,r3
  14a61c:	8085883a 	add	r2,r16,r2
  14a620:	10000005 	stb	zero,0(r2)
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  14a624:	e0bffa17 	ldw	r2,-24(fp)
  14a628:	10800044 	addi	r2,r2,1
  14a62c:	e0bffa15 	stw	r2,-24(fp)
  14a630:	e0bffa17 	ldw	r2,-24(fp)
  14a634:	108003d0 	cmplti	r2,r2,15
  14a638:	103ff01e 	bne	r2,zero,14a5fc <set_save_area+0x64>
    saved_end_x = pos_x + size_x;
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  14a63c:	e0bffb17 	ldw	r2,-20(fp)
  14a640:	10800044 	addi	r2,r2,1
  14a644:	e0bffb15 	stw	r2,-20(fp)
  14a648:	e0bffb17 	ldw	r2,-20(fp)
  14a64c:	10800410 	cmplti	r2,r2,16
  14a650:	103fe81e 	bne	r2,zero,14a5f4 <set_save_area+0x5c>
        }
    }


    /* setup the saved area - return */
    return;
  14a654:	0001883a 	nop

}
  14a658:	e037883a 	mov	sp,fp
  14a65c:	dfc00217 	ldw	ra,8(sp)
  14a660:	df000117 	ldw	fp,4(sp)
  14a664:	dc000017 	ldw	r16,0(sp)
  14a668:	dec00304 	addi	sp,sp,12
  14a66c:	f800283a 	ret

0014a670 <restore_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_trace()
{
  14a670:	defff904 	addi	sp,sp,-28
  14a674:	dfc00615 	stw	ra,24(sp)
  14a678:	df000515 	stw	fp,20(sp)
  14a67c:	dc000415 	stw	r16,16(sp)
  14a680:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  14a684:	d0a28117 	ldw	r2,-30204(gp)
  14a688:	e0bfff15 	stw	r2,-4(fp)
  14a68c:	00003606 	br	14a768 <restore_trace+0xf8>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  14a690:	00802004 	movi	r2,128
  14a694:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  14a698:	e03ffd15 	stw	zero,-12(fp)

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  14a69c:	d0a28417 	ldw	r2,-30192(gp)
  14a6a0:	e0bffe15 	stw	r2,-8(fp)
  14a6a4:	00002a06 	br	14a750 <restore_trace+0xe0>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_area[y - saved_pos_y][bit_offset] & bit_position) == 0)
  14a6a8:	d0a28117 	ldw	r2,-30204(gp)
  14a6ac:	e0ffff17 	ldw	r3,-4(fp)
  14a6b0:	1885c83a 	sub	r2,r3,r2
  14a6b4:	04000574 	movhi	r16,21
  14a6b8:	843a7d84 	addi	r16,r16,-5642
  14a6bc:	1009883a 	mov	r4,r2
  14a6c0:	014003c4 	movi	r5,15
  14a6c4:	014bd900 	call	14bd90 <__mulsi3>
  14a6c8:	e0fffd17 	ldw	r3,-12(fp)
  14a6cc:	10c5883a 	add	r2,r2,r3
  14a6d0:	8085883a 	add	r2,r16,r2
  14a6d4:	10800003 	ldbu	r2,0(r2)
  14a6d8:	10c03fcc 	andi	r3,r2,255
  14a6dc:	e0bffc17 	ldw	r2,-16(fp)
  14a6e0:	1884703a 	and	r2,r3,r2
  14a6e4:	1000071e 	bne	r2,zero,14a704 <restore_trace+0x94>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_WHITE);
  14a6e8:	e0fffe17 	ldw	r3,-8(fp)
  14a6ec:	e0bfff17 	ldw	r2,-4(fp)
  14a6f0:	1809883a 	mov	r4,r3
  14a6f4:	100b883a 	mov	r5,r2
  14a6f8:	01bfdfd4 	movui	r6,65407
  14a6fc:	014b7f40 	call	14b7f4 <plot_pixel>
  14a700:	00000606 	br	14a71c <restore_trace+0xac>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_BLACK);
  14a704:	e0fffe17 	ldw	r3,-8(fp)
  14a708:	e0bfff17 	ldw	r2,-4(fp)
  14a70c:	1809883a 	mov	r4,r3
  14a710:	100b883a 	mov	r5,r2
  14a714:	000d883a 	mov	r6,zero
  14a718:	014b7f40 	call	14b7f4 <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  14a71c:	e0bffc17 	ldw	r2,-16(fp)
  14a720:	1005d07a 	srai	r2,r2,1
  14a724:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  14a728:	e0bffc17 	ldw	r2,-16(fp)
  14a72c:	1000051e 	bne	r2,zero,14a744 <restore_trace+0xd4>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  14a730:	00802004 	movi	r2,128
  14a734:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  14a738:	e0bffd17 	ldw	r2,-12(fp)
  14a73c:	10800044 	addi	r2,r2,1
  14a740:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  14a744:	e0bffe17 	ldw	r2,-8(fp)
  14a748:	10800044 	addi	r2,r2,1
  14a74c:	e0bffe15 	stw	r2,-8(fp)
  14a750:	d0a28317 	ldw	r2,-30196(gp)
  14a754:	e0fffe17 	ldw	r3,-8(fp)
  14a758:	18bfd316 	blt	r3,r2,14a6a8 <restore_trace+0x38>
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  14a75c:	e0bfff17 	ldw	r2,-4(fp)
  14a760:	10800044 	addi	r2,r2,1
  14a764:	e0bfff15 	stw	r2,-4(fp)
  14a768:	d0a28017 	ldw	r2,-30208(gp)
  14a76c:	e0ffff17 	ldw	r3,-4(fp)
  14a770:	18bfc716 	blt	r3,r2,14a690 <restore_trace+0x20>
        }
    }


    /* restored the saved area - return */
    return;
  14a774:	0001883a 	nop

}
  14a778:	e037883a 	mov	sp,fp
  14a77c:	dfc00217 	ldw	ra,8(sp)
  14a780:	df000117 	ldw	fp,4(sp)
  14a784:	dc000017 	ldw	r16,0(sp)
  14a788:	dec00304 	addi	sp,sp,12
  14a78c:	f800283a 	ret

0014a790 <do_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  do_trace()
{
  14a790:	defffe04 	addi	sp,sp,-8
  14a794:	dfc00115 	stw	ra,4(sp)
  14a798:	df000015 	stw	fp,0(sp)
  14a79c:	d839883a 	mov	fp,sp



    /* start up the trace */
    /* indicate whether using automatic triggering or not */
    start_sample(get_trigger_mode() == AUTO_TRIGGER);
  14a7a0:	0148f100 	call	148f10 <get_trigger_mode>
  14a7a4:	10800060 	cmpeqi	r2,r2,1
  14a7a8:	10803fcc 	andi	r2,r2,255
  14a7ac:	1009883a 	mov	r4,r2
  14a7b0:	014b9480 	call	14b948 <start_sample>

    /* now not ready for another trace (currently doing one) */
    trace_status = FALSE;
  14a7b4:	d0227f15 	stw	zero,-30212(gp)

    /* and are currently sampling data */
    sampling = TRUE;
  14a7b8:	00800044 	movi	r2,1
  14a7bc:	d0a28515 	stw	r2,-30188(gp)


    /* trace is going, return */
    return;
  14a7c0:	0001883a 	nop

}
  14a7c4:	e037883a 	mov	sp,fp
  14a7c8:	dfc00117 	ldw	ra,4(sp)
  14a7cc:	df000017 	ldw	fp,0(sp)
  14a7d0:	dec00204 	addi	sp,sp,8
  14a7d4:	f800283a 	ret

0014a7d8 <plot_trace>:
   Last Modified:    May 9, 2006

*/

void  plot_trace(unsigned char *sample)
{
  14a7d8:	defff304 	addi	sp,sp,-52
  14a7dc:	dfc00c15 	stw	ra,48(sp)
  14a7e0:	df000b15 	stw	fp,44(sp)
  14a7e4:	dcc00a15 	stw	r19,40(sp)
  14a7e8:	dc800915 	stw	r18,36(sp)
  14a7ec:	dc400815 	stw	r17,32(sp)
  14a7f0:	dc000715 	stw	r16,28(sp)
  14a7f4:	df000704 	addi	fp,sp,28
  14a7f8:	e13fff15 	stw	r4,-4(fp)
    /* variables */
    int  x = 0;				/* current x position to plot */
  14a7fc:	e03ff915 	stw	zero,-28(fp)
    int  x_pos = (PLOT_SIZE_X / 2);	/* "fine" x position for multiple point plotting */
  14a800:	00803c04 	movi	r2,240
  14a804:	e0bffa15 	stw	r2,-24(fp)
    int  j;



    /* first, clear the display to get rid of old plots */
    clear_display();
  14a808:	014b7a40 	call	14b7a4 <clear_display>

    /* clear the saved areas too */
    clear_saved_areas();
  14a80c:	014a2b40 	call	14a2b4 <clear_saved_areas>

    /* re-display the menu (if it was on) */
    refresh_menu();
  14a810:	0148a6c0 	call	148a6c <refresh_menu>


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
  14a814:	e03ffc15 	stw	zero,-16(fp)
  14a818:	00010f06 	br	14ac58 <plot_trace+0x480>

        /* determine y position of point (note: screen coordinates invert) */
	y = (PLOT_SIZE_Y - 1) - ((sample[i] * (PLOT_SIZE_Y - 1)) / 255);
  14a81c:	e0bffc17 	ldw	r2,-16(fp)
  14a820:	e0ffff17 	ldw	r3,-4(fp)
  14a824:	1885883a 	add	r2,r3,r2
  14a828:	10800003 	ldbu	r2,0(r2)
  14a82c:	10803fcc 	andi	r2,r2,255
  14a830:	1009883a 	mov	r4,r2
  14a834:	014043c4 	movi	r5,271
  14a838:	014bd900 	call	14bd90 <__mulsi3>
  14a83c:	1009883a 	mov	r4,r2
  14a840:	01403fc4 	movi	r5,255
  14a844:	014bcd40 	call	14bcd4 <__divsi3>
  14a848:	00c043c4 	movi	r3,271
  14a84c:	1885c83a 	sub	r2,r3,r2
  14a850:	e0bffe15 	stw	r2,-8(fp)

        /* plot this point */
	plot_pixel(x, y, PIXEL_CYAN);
  14a854:	e0fff917 	ldw	r3,-28(fp)
  14a858:	e0bffe17 	ldw	r2,-8(fp)
  14a85c:	1809883a 	mov	r4,r3
  14a860:	100b883a 	mov	r5,r2
  14a864:	01801fc4 	movi	r6,127
  14a868:	014b7f40 	call	14b7f4 <plot_pixel>


	/* check if the point is in a save area */

	/* check if in the menu area */
	if ((x >= MENU_UL_X) && (x < (MENU_UL_X + MENU_SIZE_X)) &&
  14a86c:	e0bff917 	ldw	r2,-28(fp)
  14a870:	10805e90 	cmplti	r2,r2,378
  14a874:	10002f1e 	bne	r2,zero,14a934 <plot_trace+0x15c>
  14a878:	e0bff917 	ldw	r2,-28(fp)
  14a87c:	10807688 	cmpgei	r2,r2,474
  14a880:	10002c1e 	bne	r2,zero,14a934 <plot_trace+0x15c>
  14a884:	e0bffe17 	ldw	r2,-8(fp)
  14a888:	10002a16 	blt	r2,zero,14a934 <plot_trace+0x15c>
	    (y >= MENU_UL_Y) && (y < (MENU_UL_Y + MENU_SIZE_Y)))
  14a88c:	e0bffe17 	ldw	r2,-8(fp)
  14a890:	10800e08 	cmpgei	r2,r2,56
  14a894:	1000271e 	bne	r2,zero,14a934 <plot_trace+0x15c>
	    /* point is in the menu area - save it */
	    saved_menu[y - MENU_UL_Y][(x - MENU_UL_X)/8] |= (0x80 >> ((x - MENU_UL_X) % 8));
  14a898:	e0bff917 	ldw	r2,-28(fp)
  14a89c:	10bfa184 	addi	r2,r2,-378
  14a8a0:	1000010e 	bge	r2,zero,14a8a8 <plot_trace+0xd0>
  14a8a4:	108001c4 	addi	r2,r2,7
  14a8a8:	1005d0fa 	srai	r2,r2,3
  14a8ac:	1021883a 	mov	r16,r2
  14a8b0:	04400574 	movhi	r17,21
  14a8b4:	8c792d04 	addi	r17,r17,-6988
  14a8b8:	e0bffe17 	ldw	r2,-8(fp)
  14a8bc:	1009883a 	mov	r4,r2
  14a8c0:	01400304 	movi	r5,12
  14a8c4:	014bd900 	call	14bd90 <__mulsi3>
  14a8c8:	1405883a 	add	r2,r2,r16
  14a8cc:	8885883a 	add	r2,r17,r2
  14a8d0:	10800003 	ldbu	r2,0(r2)
  14a8d4:	1007883a 	mov	r3,r2
  14a8d8:	e0bff917 	ldw	r2,-28(fp)
  14a8dc:	113fa184 	addi	r4,r2,-378
  14a8e0:	00a00034 	movhi	r2,32768
  14a8e4:	108001c4 	addi	r2,r2,7
  14a8e8:	2084703a 	and	r2,r4,r2
  14a8ec:	1000040e 	bge	r2,zero,14a900 <plot_trace+0x128>
  14a8f0:	10bfffc4 	addi	r2,r2,-1
  14a8f4:	013ffe04 	movi	r4,-8
  14a8f8:	1104b03a 	or	r2,r2,r4
  14a8fc:	10800044 	addi	r2,r2,1
  14a900:	01002004 	movi	r4,128
  14a904:	2085d83a 	sra	r2,r4,r2
  14a908:	1884b03a 	or	r2,r3,r2
  14a90c:	1023883a 	mov	r17,r2
  14a910:	04800574 	movhi	r18,21
  14a914:	94b92d04 	addi	r18,r18,-6988
  14a918:	e0bffe17 	ldw	r2,-8(fp)
  14a91c:	1009883a 	mov	r4,r2
  14a920:	01400304 	movi	r5,12
  14a924:	014bd900 	call	14bd90 <__mulsi3>
  14a928:	1405883a 	add	r2,r2,r16
  14a92c:	9085883a 	add	r2,r18,r2
  14a930:	14400005 	stb	r17,0(r2)

	/* check if in the saved area */
	if ((x >= saved_pos_x) && (x <= saved_end_x) && (y >= saved_pos_y) && (y <= saved_end_y))
  14a934:	d0a28417 	ldw	r2,-30192(gp)
  14a938:	e0fff917 	ldw	r3,-28(fp)
  14a93c:	18803616 	blt	r3,r2,14aa18 <plot_trace+0x240>
  14a940:	d0e28317 	ldw	r3,-30196(gp)
  14a944:	e0bff917 	ldw	r2,-28(fp)
  14a948:	18803316 	blt	r3,r2,14aa18 <plot_trace+0x240>
  14a94c:	d0a28117 	ldw	r2,-30204(gp)
  14a950:	e0fffe17 	ldw	r3,-8(fp)
  14a954:	18803016 	blt	r3,r2,14aa18 <plot_trace+0x240>
  14a958:	d0e28017 	ldw	r3,-30208(gp)
  14a95c:	e0bffe17 	ldw	r2,-8(fp)
  14a960:	18802d16 	blt	r3,r2,14aa18 <plot_trace+0x240>
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));
  14a964:	d0a28117 	ldw	r2,-30204(gp)
  14a968:	e0fffe17 	ldw	r3,-8(fp)
  14a96c:	18a3c83a 	sub	r17,r3,r2
  14a970:	d0a28417 	ldw	r2,-30192(gp)
  14a974:	e0fff917 	ldw	r3,-28(fp)
  14a978:	1885c83a 	sub	r2,r3,r2
  14a97c:	1000010e 	bge	r2,zero,14a984 <plot_trace+0x1ac>
  14a980:	108001c4 	addi	r2,r2,7
  14a984:	1005d0fa 	srai	r2,r2,3
  14a988:	1021883a 	mov	r16,r2
  14a98c:	d0a28117 	ldw	r2,-30204(gp)
  14a990:	e0fffe17 	ldw	r3,-8(fp)
  14a994:	1885c83a 	sub	r2,r3,r2
  14a998:	04800574 	movhi	r18,21
  14a99c:	94ba7d84 	addi	r18,r18,-5642
  14a9a0:	1009883a 	mov	r4,r2
  14a9a4:	014003c4 	movi	r5,15
  14a9a8:	014bd900 	call	14bd90 <__mulsi3>
  14a9ac:	1405883a 	add	r2,r2,r16
  14a9b0:	9085883a 	add	r2,r18,r2
  14a9b4:	10800003 	ldbu	r2,0(r2)
  14a9b8:	1007883a 	mov	r3,r2
  14a9bc:	d0a28417 	ldw	r2,-30192(gp)
  14a9c0:	e13ff917 	ldw	r4,-28(fp)
  14a9c4:	2089c83a 	sub	r4,r4,r2
  14a9c8:	00a00034 	movhi	r2,32768
  14a9cc:	108001c4 	addi	r2,r2,7
  14a9d0:	2084703a 	and	r2,r4,r2
  14a9d4:	1000040e 	bge	r2,zero,14a9e8 <plot_trace+0x210>
  14a9d8:	10bfffc4 	addi	r2,r2,-1
  14a9dc:	013ffe04 	movi	r4,-8
  14a9e0:	1104b03a 	or	r2,r2,r4
  14a9e4:	10800044 	addi	r2,r2,1
  14a9e8:	01002004 	movi	r4,128
  14a9ec:	2085d83a 	sra	r2,r4,r2
  14a9f0:	1884b03a 	or	r2,r3,r2
  14a9f4:	1025883a 	mov	r18,r2
  14a9f8:	04c00574 	movhi	r19,21
  14a9fc:	9cfa7d84 	addi	r19,r19,-5642
  14aa00:	8809883a 	mov	r4,r17
  14aa04:	014003c4 	movi	r5,15
  14aa08:	014bd900 	call	14bd90 <__mulsi3>
  14aa0c:	1405883a 	add	r2,r2,r16
  14aa10:	9885883a 	add	r2,r19,r2
  14aa14:	14800005 	stb	r18,0(r2)

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  14aa18:	00bfff84 	movi	r2,-2
  14aa1c:	e0bffd15 	stw	r2,-12(fp)
  14aa20:	00003a06 	br	14ab0c <plot_trace+0x334>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  14aa24:	e13ffd17 	ldw	r4,-12(fp)
  14aa28:	01400c04 	movi	r5,48
  14aa2c:	014bd900 	call	14bd90 <__mulsi3>
  14aa30:	10802204 	addi	r2,r2,136
  14aa34:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  14aa38:	e0bffb17 	ldw	r2,-20(fp)
  14aa3c:	10804410 	cmplti	r2,r2,272
  14aa40:	1000021e 	bne	r2,zero,14aa4c <plot_trace+0x274>
	        p = PLOT_SIZE_Y - 1;
  14aa44:	008043c4 	movi	r2,271
  14aa48:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
  14aa4c:	e0bffb17 	ldw	r2,-20(fp)
  14aa50:	1000010e 	bge	r2,zero,14aa58 <plot_trace+0x280>
	        p = 0;
  14aa54:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (y == p)
  14aa58:	e0fffe17 	ldw	r3,-8(fp)
  14aa5c:	e0bffb17 	ldw	r2,-20(fp)
  14aa60:	1880271e 	bne	r3,r2,14ab00 <plot_trace+0x328>
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
  14aa64:	e0bffd17 	ldw	r2,-12(fp)
  14aa68:	14400084 	addi	r17,r2,2
  14aa6c:	e0bff917 	ldw	r2,-28(fp)
  14aa70:	1000010e 	bge	r2,zero,14aa78 <plot_trace+0x2a0>
  14aa74:	108001c4 	addi	r2,r2,7
  14aa78:	1005d0fa 	srai	r2,r2,3
  14aa7c:	1021883a 	mov	r16,r2
  14aa80:	e0bffd17 	ldw	r2,-12(fp)
  14aa84:	10800084 	addi	r2,r2,2
  14aa88:	04800574 	movhi	r18,21
  14aa8c:	94ba3284 	addi	r18,r18,-5942
  14aa90:	1009883a 	mov	r4,r2
  14aa94:	01400f04 	movi	r5,60
  14aa98:	014bd900 	call	14bd90 <__mulsi3>
  14aa9c:	1405883a 	add	r2,r2,r16
  14aaa0:	9085883a 	add	r2,r18,r2
  14aaa4:	10800003 	ldbu	r2,0(r2)
  14aaa8:	1007883a 	mov	r3,r2
  14aaac:	e13ff917 	ldw	r4,-28(fp)
  14aab0:	00a00034 	movhi	r2,32768
  14aab4:	108001c4 	addi	r2,r2,7
  14aab8:	2084703a 	and	r2,r4,r2
  14aabc:	1000040e 	bge	r2,zero,14aad0 <plot_trace+0x2f8>
  14aac0:	10bfffc4 	addi	r2,r2,-1
  14aac4:	013ffe04 	movi	r4,-8
  14aac8:	1104b03a 	or	r2,r2,r4
  14aacc:	10800044 	addi	r2,r2,1
  14aad0:	01002004 	movi	r4,128
  14aad4:	2085d83a 	sra	r2,r4,r2
  14aad8:	1884b03a 	or	r2,r3,r2
  14aadc:	1025883a 	mov	r18,r2
  14aae0:	04c00574 	movhi	r19,21
  14aae4:	9cfa3284 	addi	r19,r19,-5942
  14aae8:	8809883a 	mov	r4,r17
  14aaec:	01400f04 	movi	r5,60
  14aaf0:	014bd900 	call	14bd90 <__mulsi3>
  14aaf4:	1405883a 	add	r2,r2,r16
  14aaf8:	9885883a 	add	r2,r19,r2
  14aafc:	14800005 	stb	r18,0(r2)
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  14ab00:	e0bffd17 	ldw	r2,-12(fp)
  14ab04:	10800044 	addi	r2,r2,1
  14ab08:	e0bffd15 	stw	r2,-12(fp)
  14ab0c:	e0bffd17 	ldw	r2,-12(fp)
  14ab10:	108000d0 	cmplti	r2,r2,3
  14ab14:	103fc31e 	bne	r2,zero,14aa24 <plot_trace+0x24c>
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  14ab18:	00bffec4 	movi	r2,-5
  14ab1c:	e0bffd15 	stw	r2,-12(fp)
  14ab20:	00003a06 	br	14ac0c <plot_trace+0x434>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  14ab24:	e13ffd17 	ldw	r4,-12(fp)
  14ab28:	01400c04 	movi	r5,48
  14ab2c:	014bd900 	call	14bd90 <__mulsi3>
  14ab30:	10803c04 	addi	r2,r2,240
  14ab34:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  14ab38:	e0bffb17 	ldw	r2,-20(fp)
  14ab3c:	10807810 	cmplti	r2,r2,480
  14ab40:	1000021e 	bne	r2,zero,14ab4c <plot_trace+0x374>
	        p = PLOT_SIZE_X - 1;
  14ab44:	008077c4 	movi	r2,479
  14ab48:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
  14ab4c:	e0bffb17 	ldw	r2,-20(fp)
  14ab50:	1000010e 	bge	r2,zero,14ab58 <plot_trace+0x380>
	        p = 0;
  14ab54:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (x == p)
  14ab58:	e0fff917 	ldw	r3,-28(fp)
  14ab5c:	e0bffb17 	ldw	r2,-20(fp)
  14ab60:	1880271e 	bne	r3,r2,14ac00 <plot_trace+0x428>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
  14ab64:	e0bffd17 	ldw	r2,-12(fp)
  14ab68:	14400144 	addi	r17,r2,5
  14ab6c:	e0bffe17 	ldw	r2,-8(fp)
  14ab70:	1000010e 	bge	r2,zero,14ab78 <plot_trace+0x3a0>
  14ab74:	108001c4 	addi	r2,r2,7
  14ab78:	1005d0fa 	srai	r2,r2,3
  14ab7c:	1021883a 	mov	r16,r2
  14ab80:	e0bffd17 	ldw	r2,-12(fp)
  14ab84:	10800144 	addi	r2,r2,5
  14ab88:	04800574 	movhi	r18,21
  14ab8c:	94b9d504 	addi	r18,r18,-6316
  14ab90:	1009883a 	mov	r4,r2
  14ab94:	01400884 	movi	r5,34
  14ab98:	014bd900 	call	14bd90 <__mulsi3>
  14ab9c:	1405883a 	add	r2,r2,r16
  14aba0:	9085883a 	add	r2,r18,r2
  14aba4:	10800003 	ldbu	r2,0(r2)
  14aba8:	1007883a 	mov	r3,r2
  14abac:	e13ffe17 	ldw	r4,-8(fp)
  14abb0:	00a00034 	movhi	r2,32768
  14abb4:	108001c4 	addi	r2,r2,7
  14abb8:	2084703a 	and	r2,r4,r2
  14abbc:	1000040e 	bge	r2,zero,14abd0 <plot_trace+0x3f8>
  14abc0:	10bfffc4 	addi	r2,r2,-1
  14abc4:	013ffe04 	movi	r4,-8
  14abc8:	1104b03a 	or	r2,r2,r4
  14abcc:	10800044 	addi	r2,r2,1
  14abd0:	01002004 	movi	r4,128
  14abd4:	2085d83a 	sra	r2,r4,r2
  14abd8:	1884b03a 	or	r2,r3,r2
  14abdc:	1025883a 	mov	r18,r2
  14abe0:	04c00574 	movhi	r19,21
  14abe4:	9cf9d504 	addi	r19,r19,-6316
  14abe8:	8809883a 	mov	r4,r17
  14abec:	01400884 	movi	r5,34
  14abf0:	014bd900 	call	14bd90 <__mulsi3>
  14abf4:	1405883a 	add	r2,r2,r16
  14abf8:	9885883a 	add	r2,r19,r2
  14abfc:	14800005 	stb	r18,0(r2)
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  14ac00:	e0bffd17 	ldw	r2,-12(fp)
  14ac04:	10800044 	addi	r2,r2,1
  14ac08:	e0bffd15 	stw	r2,-12(fp)
  14ac0c:	e0bffd17 	ldw	r2,-12(fp)
  14ac10:	10800190 	cmplti	r2,r2,6
  14ac14:	103fc31e 	bne	r2,zero,14ab24 <plot_trace+0x34c>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
	}


	/* update x position */
	x_pos += PLOT_SIZE_X;
  14ac18:	e0bffa17 	ldw	r2,-24(fp)
  14ac1c:	10807804 	addi	r2,r2,480
  14ac20:	e0bffa15 	stw	r2,-24(fp)
	/* check if at next horizontal position */
	if (x_pos >= sample_size)  {
  14ac24:	d0a28217 	ldw	r2,-30200(gp)
  14ac28:	e0fffa17 	ldw	r3,-24(fp)
  14ac2c:	18800716 	blt	r3,r2,14ac4c <plot_trace+0x474>
	    /* at next position - update positions */
	    x++;
  14ac30:	e0bff917 	ldw	r2,-28(fp)
  14ac34:	10800044 	addi	r2,r2,1
  14ac38:	e0bff915 	stw	r2,-28(fp)
	    x_pos -= sample_size;
  14ac3c:	d0a28217 	ldw	r2,-30200(gp)
  14ac40:	e0fffa17 	ldw	r3,-24(fp)
  14ac44:	1885c83a 	sub	r2,r3,r2
  14ac48:	e0bffa15 	stw	r2,-24(fp)
    /* re-display the menu (if it was on) */
    refresh_menu();


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
  14ac4c:	e0bffc17 	ldw	r2,-16(fp)
  14ac50:	10800044 	addi	r2,r2,1
  14ac54:	e0bffc15 	stw	r2,-16(fp)
  14ac58:	d0a28217 	ldw	r2,-30200(gp)
  14ac5c:	e0fffc17 	ldw	r3,-16(fp)
  14ac60:	18beee16 	blt	r3,r2,14a81c <plot_trace+0x44>
	}
    }


    /* finally, output the scale if need be */
    set_display_scale(cur_scale);
  14ac64:	d0a27e17 	ldw	r2,-30216(gp)
  14ac68:	1009883a 	mov	r4,r2
  14ac6c:	0149eb00 	call	149eb0 <set_display_scale>


    /* done with plot, return */
    return;
  14ac70:	0001883a 	nop

}
  14ac74:	e037883a 	mov	sp,fp
  14ac78:	dfc00517 	ldw	ra,20(sp)
  14ac7c:	df000417 	ldw	fp,16(sp)
  14ac80:	dcc00317 	ldw	r19,12(sp)
  14ac84:	dc800217 	ldw	r18,8(sp)
  14ac88:	dc400117 	ldw	r17,4(sp)
  14ac8c:	dc000017 	ldw	r16,0(sp)
  14ac90:	dec00604 	addi	sp,sp,24
  14ac94:	f800283a 	ret

0014ac98 <key_int_installer>:

.global key_int_installer
.type	key_int_installer, @function

key_int_installer:
	SAVE
  14ac98:	deffff04 	addi	sp,sp,-4
  14ac9c:	dfc00015 	stw	ra,0(sp)
  14aca0:	deffff04 	addi	sp,sp,-4
  14aca4:	df000015 	stw	fp,0(sp)
  14aca8:	d839883a 	mov	fp,sp
  14acac:	02000574 	movhi	r8,21

	# asdf
	movia	r8, adc_speed
  14acb0:	42344404 	addi	r8,r8,-12016
	movi	r9, 0x040000
  14acb4:	02400134 	movhi	r9,4
	stw		r9, (r8)
  14acb8:	42400015 	stw	r9,0(r8)
  14acbc:	02000574 	movhi	r8,21
	movia	r8, trig_level
  14acc0:	42344584 	addi	r8,r8,-12010
	movi	r9, 0
  14acc4:	02400004 	movi	r9,0
	stb		r9, (r8)
  14acc8:	42400005 	stb	r9,0(r8)
  14accc:	02000574 	movhi	r8,21
	movia	r8, trig_delay
  14acd0:	42344504 	addi	r8,r8,-12012
	movi	r9, 240
  14acd4:	02403c04 	movi	r9,240
	sth		r9, (r8)
  14acd8:	4240000d 	sth	r9,0(r8)
	# asdf

	# Enable all switch interrupts.
	movhi	r8, %hi(KEY_INPUT_BASE)
  14acdc:	02000574 	movhi	r8,21
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  14ace0:	42047414 	ori	r8,r8,4560
	movhi	r9, %hi(SWITCH_ALL)
  14ace4:	024003f4 	movhi	r9,15
	ori		r9, r9, %lo(SWITCH_ALL)
  14ace8:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_IRQ_MASK(r8)
  14acec:	42400215 	stw	r9,8(r8)

	# Install the interrupt handler
	mov		r4, r0
  14acf0:	0009883a 	mov	r4,zero
	movi	r5, KEY_INPUT_IRQ
  14acf4:	01400144 	movi	r5,5
	movhi	r6, %hi(key_handler)
  14acf8:	01800534 	movhi	r6,20
	ori		r6, r6, %lo(key_handler)
  14acfc:	31ab4c14 	ori	r6,r6,44336
	mov		r7, r0
  14ad00:	000f883a 	mov	r7,zero
	PUSH	r0
  14ad04:	deffff04 	addi	sp,sp,-4
  14ad08:	d8000015 	stw	zero,0(sp)
	call	alt_ic_isr_register
  14ad0c:	014bef80 	call	14bef8 <alt_ic_isr_register>
	POP		r0
  14ad10:	d8000017 	ldw	zero,0(sp)
  14ad14:	dec00104 	addi	sp,sp,4

0014ad18 <key_int_installer_done>:

key_int_installer_done:
	RESTORE
  14ad18:	e037883a 	mov	sp,fp
  14ad1c:	df000017 	ldw	fp,0(sp)
  14ad20:	dec00104 	addi	sp,sp,4
  14ad24:	dfc00017 	ldw	ra,0(sp)
  14ad28:	dec00104 	addi	sp,sp,4
	ret
  14ad2c:	f800283a 	ret

0014ad30 <key_handler>:
 */

.type key_handler,@function

key_handler:
	SAVE
  14ad30:	deffff04 	addi	sp,sp,-4
  14ad34:	dfc00015 	stw	ra,0(sp)
  14ad38:	deffff04 	addi	sp,sp,-4
  14ad3c:	df000015 	stw	fp,0(sp)
  14ad40:	d839883a 	mov	fp,sp

	# Key should now be available. Update key_press.
	movi	r8, 1
  14ad44:	02000044 	movi	r8,1
  14ad48:	02400574 	movhi	r9,21
	movia	r9, key_press
  14ad4c:	4a744004 	addi	r9,r9,-12032
	stb		r8, (r9)
  14ad50:	4a000005 	stb	r8,0(r9)

	# Clear interrupts.
	movhi	r8, %hi(KEY_INPUT_BASE)
  14ad54:	02000574 	movhi	r8,21
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  14ad58:	42047414 	ori	r8,r8,4560
	stw		r0, PIO_IRQ_MASK(r8)
  14ad5c:	40000215 	stw	zero,8(r8)

	# Get the edge capture register.
	movhi	r8, %hi(KEY_INPUT_BASE)
  14ad60:	02000574 	movhi	r8,21
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  14ad64:	42047414 	ori	r8,r8,4560
	ldw		r8, PIO_EDGE_CAP(r8)
  14ad68:	42000317 	ldw	r8,12(r8)

	# Check each bit (starting at 0) and see if set.
	movi	r9, 1
  14ad6c:	02400044 	movi	r9,1
	movi	r11, 0
  14ad70:	02c00004 	movi	r11,0

0014ad74 <loop_keys>:

loop_keys:
	and		r10, r8, r9
  14ad74:	4254703a 	and	r10,r8,r9
	bne		r10, r0, key_lookup
  14ad78:	5000031e 	bne	r10,zero,14ad88 <key_lookup>
	slli	r9, r9, 1
  14ad7c:	4812907a 	slli	r9,r9,1
	addi	r11, r11, 1
  14ad80:	5ac00044 	addi	r11,r11,1
	br		loop_keys
  14ad84:	003ffb06 	br	14ad74 <loop_keys>

0014ad88 <key_lookup>:
  14ad88:	02000574 	movhi	r8,21

	# Once the key is found (r11), use the lookup table to set key_value.
key_lookup:
	movia	r8, key_map
  14ad8c:	422c9904 	addi	r8,r8,-19868
	add		r8, r8, r11
  14ad90:	42d1883a 	add	r8,r8,r11
	ldb		r8,	(r8)
  14ad94:	42000007 	ldb	r8,0(r8)
  14ad98:	02800574 	movhi	r10,21

	movia	r10, key_value
  14ad9c:	52b44044 	addi	r10,r10,-12031
	stb		r8, (r10)
  14ada0:	52000005 	stb	r8,0(r10)

	# Remove later!!!
	movi	r12, 10
  14ada4:	03000284 	movi	r12,10
	beq		r11, r12, inc_speed
  14ada8:	5b004126 	beq	r11,r12,14aeb0 <inc_speed>
	movi	r12, 11
  14adac:	030002c4 	movi	r12,11
	beq		r11, r12, dec_speed
  14adb0:	5b001826 	beq	r11,r12,14ae14 <dec_speed>

	movi	r12, 16
  14adb4:	03000404 	movi	r12,16
	beq		r11, r12, inc_level
  14adb8:	5b008b26 	beq	r11,r12,14afe8 <inc_level>
	movi	r12, 17
  14adbc:	03000444 	movi	r12,17
	beq		r11, r12, dec_level
  14adc0:	5b006426 	beq	r11,r12,14af54 <dec_level>

	movi	r12, 18
  14adc4:	03000484 	movi	r12,18
	beq		r11, r12, inc_delay
  14adc8:	5b00d526 	beq	r11,r12,14b120 <inc_delay>
	movi	r12, 19
  14adcc:	030004c4 	movi	r12,19
	beq		r11, r12, dec_delay
  14add0:	5b00af26 	beq	r11,r12,14b090 <dec_delay>

0014add4 <key_lookup_cont>:
key_lookup_cont:
	# <END Remove later!!!>

	# Clear the edge capture register (write 1 to clear).
	movhi	r8, %hi(KEY_INPUT_BASE)
  14add4:	02000574 	movhi	r8,21
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  14add8:	42047414 	ori	r8,r8,4560
	movhi	r9, %hi(SWITCH_ALL)
  14addc:	024003f4 	movhi	r9,15
	ori		r9, r9, %lo(SWITCH_ALL)
  14ade0:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_EDGE_CAP(r8)
  14ade4:	42400315 	stw	r9,12(r8)

	# Re-enable interrupts.
	movhi	r8, %hi(KEY_INPUT_BASE)
  14ade8:	02000574 	movhi	r8,21
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  14adec:	42047414 	ori	r8,r8,4560
	movhi	r9, %hi(SWITCH_ALL)
  14adf0:	024003f4 	movhi	r9,15
	ori		r9, r9, %lo(SWITCH_ALL)
  14adf4:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_IRQ_MASK(r8)
  14adf8:	42400215 	stw	r9,8(r8)

0014adfc <key_handler_done>:

key_handler_done:
	RESTORE
  14adfc:	e037883a 	mov	sp,fp
  14ae00:	df000017 	ldw	fp,0(sp)
  14ae04:	dec00104 	addi	sp,sp,4
  14ae08:	dfc00017 	ldw	ra,0(sp)
  14ae0c:	dec00104 	addi	sp,sp,4
	ret
  14ae10:	f800283a 	ret

0014ae14 <dec_speed>:
  14ae14:	03400574 	movhi	r13,21

# hashtag
dec_speed:
	movia	r13, adc_speed
  14ae18:	6b744404 	addi	r13,r13,-12016
	ldw		r14, (r13)
  14ae1c:	6b800017 	ldw	r14,0(r13)
	slli	r14, r14, 1
  14ae20:	701c907a 	slli	r14,r14,1
	MOVWI	r15, 0x00FFFFFF
  14ae24:	03c03ff4 	movhi	r15,255
  14ae28:	7bffffd4 	ori	r15,r15,65535
	and		r14, r14, r15
  14ae2c:	73dc703a 	and	r14,r14,r15
	beq		r14, r0, set_speed_2
  14ae30:	70004526 	beq	r14,zero,14af48 <set_speed_2>

0014ae34 <dec_speed_cont>:
dec_speed_cont:
	MOVWI	r15, ADC_RATE_BASE
  14ae34:	03c00574 	movhi	r15,21
  14ae38:	7bc46c14 	ori	r15,r15,4528
	stw		r14, (r15)
  14ae3c:	7b800015 	stw	r14,0(r15)
	stw		r14, (r13)
  14ae40:	6b800015 	stw	r14,0(r13)

	# Turn on FIFO write
	STWI	ADC_CTRL_BASE, 0x04
  14ae44:	deffff04 	addi	sp,sp,-4
  14ae48:	da400015 	stw	r9,0(sp)
  14ae4c:	deffff04 	addi	sp,sp,-4
  14ae50:	da800015 	stw	r10,0(sp)
  14ae54:	02400574 	movhi	r9,21
  14ae58:	4a444014 	ori	r9,r9,4352
  14ae5c:	02800034 	movhi	r10,0
  14ae60:	52800114 	ori	r10,r10,4
  14ae64:	4a800035 	stwio	r10,0(r9)
  14ae68:	da800017 	ldw	r10,0(sp)
  14ae6c:	dec00104 	addi	sp,sp,4
  14ae70:	da400017 	ldw	r9,0(sp)
  14ae74:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14ae78:	deffff04 	addi	sp,sp,-4
  14ae7c:	da400015 	stw	r9,0(sp)
  14ae80:	deffff04 	addi	sp,sp,-4
  14ae84:	da800015 	stw	r10,0(sp)
  14ae88:	02400574 	movhi	r9,21
  14ae8c:	4a444014 	ori	r9,r9,4352
  14ae90:	02800034 	movhi	r10,0
  14ae94:	52800094 	ori	r10,r10,2
  14ae98:	4a800035 	stwio	r10,0(r9)
  14ae9c:	da800017 	ldw	r10,0(sp)
  14aea0:	dec00104 	addi	sp,sp,4
  14aea4:	da400017 	ldw	r9,0(sp)
  14aea8:	dec00104 	addi	sp,sp,4

	br		key_lookup_cont
  14aeac:	003fc906 	br	14add4 <key_lookup_cont>

0014aeb0 <inc_speed>:
  14aeb0:	03400574 	movhi	r13,21

inc_speed:
	movia	r13, adc_speed
  14aeb4:	6b744404 	addi	r13,r13,-12016
	ldwio	r14, (r13)
  14aeb8:	6b800037 	ldwio	r14,0(r13)
	srli	r14, r14, 1
  14aebc:	701cd07a 	srli	r14,r14,1
	beq		r14, r0, set_speed_1
  14aec0:	70001f26 	beq	r14,zero,14af40 <set_speed_1>

0014aec4 <inc_speed_cont>:
inc_speed_cont:
	MOVWI	r15, ADC_RATE_BASE
  14aec4:	03c00574 	movhi	r15,21
  14aec8:	7bc46c14 	ori	r15,r15,4528
	stwio	r14, (r15)
  14aecc:	7b800035 	stwio	r14,0(r15)
	stwio	r14, (r13)
  14aed0:	6b800035 	stwio	r14,0(r13)

	# Turn on FIFO write
	STWI	ADC_CTRL_BASE, 0x04
  14aed4:	deffff04 	addi	sp,sp,-4
  14aed8:	da400015 	stw	r9,0(sp)
  14aedc:	deffff04 	addi	sp,sp,-4
  14aee0:	da800015 	stw	r10,0(sp)
  14aee4:	02400574 	movhi	r9,21
  14aee8:	4a444014 	ori	r9,r9,4352
  14aeec:	02800034 	movhi	r10,0
  14aef0:	52800114 	ori	r10,r10,4
  14aef4:	4a800035 	stwio	r10,0(r9)
  14aef8:	da800017 	ldw	r10,0(sp)
  14aefc:	dec00104 	addi	sp,sp,4
  14af00:	da400017 	ldw	r9,0(sp)
  14af04:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14af08:	deffff04 	addi	sp,sp,-4
  14af0c:	da400015 	stw	r9,0(sp)
  14af10:	deffff04 	addi	sp,sp,-4
  14af14:	da800015 	stw	r10,0(sp)
  14af18:	02400574 	movhi	r9,21
  14af1c:	4a444014 	ori	r9,r9,4352
  14af20:	02800034 	movhi	r10,0
  14af24:	52800094 	ori	r10,r10,2
  14af28:	4a800035 	stwio	r10,0(r9)
  14af2c:	da800017 	ldw	r10,0(sp)
  14af30:	dec00104 	addi	sp,sp,4
  14af34:	da400017 	ldw	r9,0(sp)
  14af38:	dec00104 	addi	sp,sp,4

	br		key_lookup_cont
  14af3c:	003fa506 	br	14add4 <key_lookup_cont>

0014af40 <set_speed_1>:

set_speed_1:
	movi	r14, 1
  14af40:	03800044 	movi	r14,1
	br		inc_speed_cont
  14af44:	003fdf06 	br	14aec4 <inc_speed_cont>

0014af48 <set_speed_2>:

set_speed_2:
	MOVWI	r14, 0x00800000
  14af48:	03802034 	movhi	r14,128
  14af4c:	73802034 	orhi	r14,r14,128
	br		dec_speed_cont
  14af50:	003fb806 	br	14ae34 <dec_speed_cont>

0014af54 <dec_level>:
  14af54:	03400574 	movhi	r13,21



dec_level:
	movia	r13, trig_level
  14af58:	6b744584 	addi	r13,r13,-12010
	ldb		r14, (r13)
  14af5c:	6b800007 	ldb	r14,0(r13)
	subi	r14, r14, 5
  14af60:	73bffec4 	addi	r14,r14,-5
	movi	r15, -128
  14af64:	03ffe004 	movi	r15,-128
	blt		r14, r15, set_level_2
  14af68:	73c04616 	blt	r14,r15,14b084 <set_level_2>

0014af6c <dec_level_cont>:
dec_level_cont:
	MOVWI	r15, TRIG_LEVEL_BASE
  14af6c:	03c00574 	movhi	r15,21
  14af70:	7bc43014 	ori	r15,r15,4288
	stw		r14, (r15)
  14af74:	7b800015 	stw	r14,0(r15)
	stb		r14, (r13)
  14af78:	6b800005 	stb	r14,0(r13)

	# Turn on FIFO write
	STWI	ADC_CTRL_BASE, 0x04
  14af7c:	deffff04 	addi	sp,sp,-4
  14af80:	da400015 	stw	r9,0(sp)
  14af84:	deffff04 	addi	sp,sp,-4
  14af88:	da800015 	stw	r10,0(sp)
  14af8c:	02400574 	movhi	r9,21
  14af90:	4a444014 	ori	r9,r9,4352
  14af94:	02800034 	movhi	r10,0
  14af98:	52800114 	ori	r10,r10,4
  14af9c:	4a800035 	stwio	r10,0(r9)
  14afa0:	da800017 	ldw	r10,0(sp)
  14afa4:	dec00104 	addi	sp,sp,4
  14afa8:	da400017 	ldw	r9,0(sp)
  14afac:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14afb0:	deffff04 	addi	sp,sp,-4
  14afb4:	da400015 	stw	r9,0(sp)
  14afb8:	deffff04 	addi	sp,sp,-4
  14afbc:	da800015 	stw	r10,0(sp)
  14afc0:	02400574 	movhi	r9,21
  14afc4:	4a444014 	ori	r9,r9,4352
  14afc8:	02800034 	movhi	r10,0
  14afcc:	52800094 	ori	r10,r10,2
  14afd0:	4a800035 	stwio	r10,0(r9)
  14afd4:	da800017 	ldw	r10,0(sp)
  14afd8:	dec00104 	addi	sp,sp,4
  14afdc:	da400017 	ldw	r9,0(sp)
  14afe0:	dec00104 	addi	sp,sp,4

	br		key_lookup_cont
  14afe4:	003f7b06 	br	14add4 <key_lookup_cont>

0014afe8 <inc_level>:
  14afe8:	03400574 	movhi	r13,21

inc_level:
	movia	r13, trig_level
  14afec:	6b744584 	addi	r13,r13,-12010
	ldb		r14, (r13)
  14aff0:	6b800007 	ldb	r14,0(r13)
	addi	r14, r14, 5
  14aff4:	73800144 	addi	r14,r14,5
	movi	r15, 127
  14aff8:	03c01fc4 	movi	r15,127
	bgt		r14, r15, set_level_1
  14affc:	7b801f16 	blt	r15,r14,14b07c <set_level_1>

0014b000 <inc_level_cont>:
inc_level_cont:
	MOVWI	r15, TRIG_LEVEL_BASE
  14b000:	03c00574 	movhi	r15,21
  14b004:	7bc43014 	ori	r15,r15,4288
	stw		r14, (r15)
  14b008:	7b800015 	stw	r14,0(r15)
	stb		r14, (r13)
  14b00c:	6b800005 	stb	r14,0(r13)

	# Turn on FIFO write
	STWI	ADC_CTRL_BASE, 0x04
  14b010:	deffff04 	addi	sp,sp,-4
  14b014:	da400015 	stw	r9,0(sp)
  14b018:	deffff04 	addi	sp,sp,-4
  14b01c:	da800015 	stw	r10,0(sp)
  14b020:	02400574 	movhi	r9,21
  14b024:	4a444014 	ori	r9,r9,4352
  14b028:	02800034 	movhi	r10,0
  14b02c:	52800114 	ori	r10,r10,4
  14b030:	4a800035 	stwio	r10,0(r9)
  14b034:	da800017 	ldw	r10,0(sp)
  14b038:	dec00104 	addi	sp,sp,4
  14b03c:	da400017 	ldw	r9,0(sp)
  14b040:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14b044:	deffff04 	addi	sp,sp,-4
  14b048:	da400015 	stw	r9,0(sp)
  14b04c:	deffff04 	addi	sp,sp,-4
  14b050:	da800015 	stw	r10,0(sp)
  14b054:	02400574 	movhi	r9,21
  14b058:	4a444014 	ori	r9,r9,4352
  14b05c:	02800034 	movhi	r10,0
  14b060:	52800094 	ori	r10,r10,2
  14b064:	4a800035 	stwio	r10,0(r9)
  14b068:	da800017 	ldw	r10,0(sp)
  14b06c:	dec00104 	addi	sp,sp,4
  14b070:	da400017 	ldw	r9,0(sp)
  14b074:	dec00104 	addi	sp,sp,4

	br		key_lookup_cont
  14b078:	003f5606 	br	14add4 <key_lookup_cont>

0014b07c <set_level_1>:

set_level_1:
	movi	r14, 127
  14b07c:	03801fc4 	movi	r14,127
	br		inc_level_cont
  14b080:	003fdf06 	br	14b000 <inc_level_cont>

0014b084 <set_level_2>:

set_level_2:
	MOVWI	r14, -128
  14b084:	03bffff4 	movhi	r14,65535
  14b088:	73bfe014 	ori	r14,r14,65408
	br		dec_level_cont
  14b08c:	003fb706 	br	14af6c <dec_level_cont>

0014b090 <dec_delay>:
  14b090:	03400574 	movhi	r13,21



dec_delay:
	movia	r13, trig_delay
  14b094:	6b744504 	addi	r13,r13,-12012
	ldh		r14, (r13)
  14b098:	6b80000f 	ldh	r14,0(r13)
	subi	r14, r14, 10
  14b09c:	73bffd84 	addi	r14,r14,-10
	ble		r14, r0, set_delay_2
  14b0a0:	0380470e 	bge	zero,r14,14b1c0 <set_delay_2>

0014b0a4 <dec_delay_cont>:
dec_delay_cont:
	MOVWI	r15, TRIG_DELAY_BASE
  14b0a4:	03c00574 	movhi	r15,21
  14b0a8:	7bc42814 	ori	r15,r15,4256
	stw		r14, (r15)
  14b0ac:	7b800015 	stw	r14,0(r15)
	sth		r14, (r13)
  14b0b0:	6b80000d 	sth	r14,0(r13)

	# Turn on FIFO write
	STWI	ADC_CTRL_BASE, 0x04
  14b0b4:	deffff04 	addi	sp,sp,-4
  14b0b8:	da400015 	stw	r9,0(sp)
  14b0bc:	deffff04 	addi	sp,sp,-4
  14b0c0:	da800015 	stw	r10,0(sp)
  14b0c4:	02400574 	movhi	r9,21
  14b0c8:	4a444014 	ori	r9,r9,4352
  14b0cc:	02800034 	movhi	r10,0
  14b0d0:	52800114 	ori	r10,r10,4
  14b0d4:	4a800035 	stwio	r10,0(r9)
  14b0d8:	da800017 	ldw	r10,0(sp)
  14b0dc:	dec00104 	addi	sp,sp,4
  14b0e0:	da400017 	ldw	r9,0(sp)
  14b0e4:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14b0e8:	deffff04 	addi	sp,sp,-4
  14b0ec:	da400015 	stw	r9,0(sp)
  14b0f0:	deffff04 	addi	sp,sp,-4
  14b0f4:	da800015 	stw	r10,0(sp)
  14b0f8:	02400574 	movhi	r9,21
  14b0fc:	4a444014 	ori	r9,r9,4352
  14b100:	02800034 	movhi	r10,0
  14b104:	52800094 	ori	r10,r10,2
  14b108:	4a800035 	stwio	r10,0(r9)
  14b10c:	da800017 	ldw	r10,0(sp)
  14b110:	dec00104 	addi	sp,sp,4
  14b114:	da400017 	ldw	r9,0(sp)
  14b118:	dec00104 	addi	sp,sp,4

	br		key_lookup_cont
  14b11c:	003f2d06 	br	14add4 <key_lookup_cont>

0014b120 <inc_delay>:
  14b120:	03400574 	movhi	r13,21

inc_delay:
	movia	r13, trig_delay
  14b124:	6b744504 	addi	r13,r13,-12012
	ldh		r14, (r13)
  14b128:	6b80000f 	ldh	r14,0(r13)
	addi	r14, r14, 10
  14b12c:	73800284 	addi	r14,r14,10
	movi	r15, 1000
  14b130:	03c0fa04 	movi	r15,1000
	bgeu	r14, r15, set_delay_1
  14b134:	73c01f2e 	bgeu	r14,r15,14b1b4 <set_delay_1>

0014b138 <inc_delay_cont>:
inc_delay_cont:
	MOVWI	r15, TRIG_DELAY_BASE
  14b138:	03c00574 	movhi	r15,21
  14b13c:	7bc42814 	ori	r15,r15,4256
	stw		r14, (r15)
  14b140:	7b800015 	stw	r14,0(r15)
	sth		r14, (r13)
  14b144:	6b80000d 	sth	r14,0(r13)

	# Turn on FIFO write
	STWI	ADC_CTRL_BASE, 0x04
  14b148:	deffff04 	addi	sp,sp,-4
  14b14c:	da400015 	stw	r9,0(sp)
  14b150:	deffff04 	addi	sp,sp,-4
  14b154:	da800015 	stw	r10,0(sp)
  14b158:	02400574 	movhi	r9,21
  14b15c:	4a444014 	ori	r9,r9,4352
  14b160:	02800034 	movhi	r10,0
  14b164:	52800114 	ori	r10,r10,4
  14b168:	4a800035 	stwio	r10,0(r9)
  14b16c:	da800017 	ldw	r10,0(sp)
  14b170:	dec00104 	addi	sp,sp,4
  14b174:	da400017 	ldw	r9,0(sp)
  14b178:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14b17c:	deffff04 	addi	sp,sp,-4
  14b180:	da400015 	stw	r9,0(sp)
  14b184:	deffff04 	addi	sp,sp,-4
  14b188:	da800015 	stw	r10,0(sp)
  14b18c:	02400574 	movhi	r9,21
  14b190:	4a444014 	ori	r9,r9,4352
  14b194:	02800034 	movhi	r10,0
  14b198:	52800094 	ori	r10,r10,2
  14b19c:	4a800035 	stwio	r10,0(r9)
  14b1a0:	da800017 	ldw	r10,0(sp)
  14b1a4:	dec00104 	addi	sp,sp,4
  14b1a8:	da400017 	ldw	r9,0(sp)
  14b1ac:	dec00104 	addi	sp,sp,4

	br		key_lookup_cont
  14b1b0:	003f0806 	br	14add4 <key_lookup_cont>

0014b1b4 <set_delay_1>:

set_delay_1:
	MOVWI	r14, 50000
  14b1b4:	03800034 	movhi	r14,0
  14b1b8:	73b0d414 	ori	r14,r14,50000
	br		inc_delay_cont
  14b1bc:	003fde06 	br	14b138 <inc_delay_cont>

0014b1c0 <set_delay_2>:

set_delay_2:
	mov		r14, r0
  14b1c0:	001d883a 	mov	r14,zero
	br		dec_delay_cont
  14b1c4:	003fb706 	br	14b0a4 <dec_delay_cont>

0014b1c8 <key_available>:

.global key_available
.type	key_available, @function

key_available:
	SAVE
  14b1c8:	deffff04 	addi	sp,sp,-4
  14b1cc:	dfc00015 	stw	ra,0(sp)
  14b1d0:	deffff04 	addi	sp,sp,-4
  14b1d4:	df000015 	stw	fp,0(sp)
  14b1d8:	d839883a 	mov	fp,sp
  14b1dc:	00800574 	movhi	r2,21

	# Simply return the value in key_press.
	movia	r2, key_press
  14b1e0:	10b44004 	addi	r2,r2,-12032
	ldb		r2, (r2)
  14b1e4:	10800007 	ldb	r2,0(r2)

0014b1e8 <key_available_done>:

key_available_done:
	RESTORE
  14b1e8:	e037883a 	mov	sp,fp
  14b1ec:	df000017 	ldw	fp,0(sp)
  14b1f0:	dec00104 	addi	sp,sp,4
  14b1f4:	dfc00017 	ldw	ra,0(sp)
  14b1f8:	dec00104 	addi	sp,sp,4
	ret
  14b1fc:	f800283a 	ret

0014b200 <getkey>:

.global	getkey
.type	getkey, @function

getkey:
	SAVE
  14b200:	deffff04 	addi	sp,sp,-4
  14b204:	dfc00015 	stw	ra,0(sp)
  14b208:	deffff04 	addi	sp,sp,-4
  14b20c:	df000015 	stw	fp,0(sp)
  14b210:	d839883a 	mov	fp,sp
  14b214:	02000574 	movhi	r8,21

	# Block until legal key arrives (which is also when key_press = TRUE).
	movia	r8, key_value
  14b218:	42344044 	addi	r8,r8,-12031
	ldb		r8, (r8)
  14b21c:	42000007 	ldb	r8,0(r8)
	movi	r9, KEY_ILLEGAL
  14b220:	02400184 	movi	r9,6
	beq		r8, r9, getkey
  14b224:	427ff626 	beq	r8,r9,14b200 <getkey>
  14b228:	00800574 	movhi	r2,21

	# Get return value.
	movia	r2, key_value
  14b22c:	10b44044 	addi	r2,r2,-12031
	ldb		r2, (r2)
  14b230:	10800007 	ldb	r2,0(r2)
  14b234:	02800574 	movhi	r10,21

	# Update key_value with KEY_ILLEGAL.
	movia	r10, key_value
  14b238:	52b44044 	addi	r10,r10,-12031
	stb		r9, (r10)
  14b23c:	52400005 	stb	r9,0(r10)
  14b240:	02800574 	movhi	r10,21

	# Update key_press with FALSE.
	movia	r10, key_press
  14b244:	52b44004 	addi	r10,r10,-12032
	stb		r0, (r10)
  14b248:	50000005 	stb	zero,0(r10)

0014b24c <getkey_done>:

getkey_done:
	RESTORE
  14b24c:	e037883a 	mov	sp,fp
  14b250:	df000017 	ldw	fp,0(sp)
  14b254:	dec00104 	addi	sp,sp,4
  14b258:	dfc00017 	ldw	ra,0(sp)
  14b25c:	dec00104 	addi	sp,sp,4
	ret
  14b260:	f800283a 	ret

0014b264 <key_map>:
  14b264:	03020100 	call	302010 <_gp+0x1ac588>
  14b268:	00000004 	movi	zero,0
	...
  14b274:	06000000 	call	600000 <_gp+0x4aa578>

0014b278 <adc_int_installer>:

.global adc_int_installer
.type	adc_int_installer, @function

adc_int_installer:
	SAVE
  14b278:	deffff04 	addi	sp,sp,-4
  14b27c:	dfc00015 	stw	ra,0(sp)
  14b280:	deffff04 	addi	sp,sp,-4
  14b284:	df000015 	stw	fp,0(sp)
  14b288:	d839883a 	mov	fp,sp

	# Set FIFO speed
	STWI	ADC_RATE_BASE, 0x040000
  14b28c:	deffff04 	addi	sp,sp,-4
  14b290:	da400015 	stw	r9,0(sp)
  14b294:	deffff04 	addi	sp,sp,-4
  14b298:	da800015 	stw	r10,0(sp)
  14b29c:	02400574 	movhi	r9,21
  14b2a0:	4a446c14 	ori	r9,r9,4528
  14b2a4:	02800134 	movhi	r10,4
  14b2a8:	52800134 	orhi	r10,r10,4
  14b2ac:	4a800035 	stwio	r10,0(r9)
  14b2b0:	da800017 	ldw	r10,0(sp)
  14b2b4:	dec00104 	addi	sp,sp,4
  14b2b8:	da400017 	ldw	r9,0(sp)
  14b2bc:	dec00104 	addi	sp,sp,4

	# Set Trigger default level (2's complement), delay
	STWI	TRIG_LEVEL_BASE, 0
  14b2c0:	deffff04 	addi	sp,sp,-4
  14b2c4:	da400015 	stw	r9,0(sp)
  14b2c8:	deffff04 	addi	sp,sp,-4
  14b2cc:	da800015 	stw	r10,0(sp)
  14b2d0:	02400574 	movhi	r9,21
  14b2d4:	4a443014 	ori	r9,r9,4288
  14b2d8:	02800034 	movhi	r10,0
  14b2dc:	52800014 	ori	r10,r10,0
  14b2e0:	4a800035 	stwio	r10,0(r9)
  14b2e4:	da800017 	ldw	r10,0(sp)
  14b2e8:	dec00104 	addi	sp,sp,4
  14b2ec:	da400017 	ldw	r9,0(sp)
  14b2f0:	dec00104 	addi	sp,sp,4
	STWI	TRIG_DELAY_BASE, 240
  14b2f4:	deffff04 	addi	sp,sp,-4
  14b2f8:	da400015 	stw	r9,0(sp)
  14b2fc:	deffff04 	addi	sp,sp,-4
  14b300:	da800015 	stw	r10,0(sp)
  14b304:	02400574 	movhi	r9,21
  14b308:	4a442814 	ori	r9,r9,4256
  14b30c:	02800034 	movhi	r10,0
  14b310:	52803c14 	ori	r10,r10,240
  14b314:	4a800035 	stwio	r10,0(r9)
  14b318:	da800017 	ldw	r10,0(sp)
  14b31c:	dec00104 	addi	sp,sp,4
  14b320:	da400017 	ldw	r9,0(sp)
  14b324:	dec00104 	addi	sp,sp,4
	STWI	TRIG_ERROR_BASE, 5
  14b328:	deffff04 	addi	sp,sp,-4
  14b32c:	da400015 	stw	r9,0(sp)
  14b330:	deffff04 	addi	sp,sp,-4
  14b334:	da800015 	stw	r10,0(sp)
  14b338:	02400574 	movhi	r9,21
  14b33c:	4a446814 	ori	r9,r9,4512
  14b340:	02800034 	movhi	r10,0
  14b344:	52800154 	ori	r10,r10,5
  14b348:	4a800035 	stwio	r10,0(r9)
  14b34c:	da800017 	ldw	r10,0(sp)
  14b350:	dec00104 	addi	sp,sp,4
  14b354:	da400017 	ldw	r9,0(sp)
  14b358:	dec00104 	addi	sp,sp,4

	# Install the interrupt handler
	mov		r4, r0
  14b35c:	0009883a 	mov	r4,zero
	movi	r5, 6
  14b360:	01400184 	movi	r5,6
	MOVWI	r6, adc_int_handler
  14b364:	01800534 	movhi	r6,20
  14b368:	31acec14 	ori	r6,r6,46000
	mov		r7, r0
  14b36c:	000f883a 	mov	r7,zero
	PUSH	r0
  14b370:	deffff04 	addi	sp,sp,-4
  14b374:	d8000015 	stw	zero,0(sp)
	call	alt_ic_isr_register
  14b378:	014bef80 	call	14bef8 <alt_ic_isr_register>
	POP		r0
  14b37c:	d8000017 	ldw	zero,0(sp)
  14b380:	dec00104 	addi	sp,sp,4

	# Clear the edge capture register (write 1 to clear).
	MOVWI	r8, TRIG_INT_BASE
  14b384:	02000574 	movhi	r8,21
  14b388:	42044814 	ori	r8,r8,4384
	MOVWI	r9, 0xFFFFFFFF
  14b38c:	027ffff4 	movhi	r9,65535
  14b390:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_EDGE_CAP(r8)
  14b394:	42400315 	stw	r9,12(r8)

0014b398 <adc_int_installer_done>:
	STWI	TRIG_CTRL_BASE, 0x01
	STWI	TRIG_CTRL_BASE, 0x00
	*/

adc_int_installer_done:
	RESTORE
  14b398:	e037883a 	mov	sp,fp
  14b39c:	df000017 	ldw	fp,0(sp)
  14b3a0:	dec00104 	addi	sp,sp,4
  14b3a4:	dfc00017 	ldw	ra,0(sp)
  14b3a8:	dec00104 	addi	sp,sp,4
	ret
  14b3ac:	f800283a 	ret

0014b3b0 <adc_int_handler>:

.global adc_int_handler
.type adc_int_handler, @function

adc_int_handler:
	SAVE
  14b3b0:	deffff04 	addi	sp,sp,-4
  14b3b4:	dfc00015 	stw	ra,0(sp)
  14b3b8:	deffff04 	addi	sp,sp,-4
  14b3bc:	df000015 	stw	fp,0(sp)
  14b3c0:	d839883a 	mov	fp,sp

	# Clear interrupts.
	MOVWI	r8, TRIG_INT_BASE
  14b3c4:	02000574 	movhi	r8,21
  14b3c8:	42044814 	ori	r8,r8,4384
	stw		r0, PIO_IRQ_MASK(r8)
  14b3cc:	40000215 	stw	zero,8(r8)

	# Get the edge capture register.
	ldw		r9, PIO_EDGE_CAP(r8)
  14b3d0:	42400317 	ldw	r9,12(r8)

	# Pause FIFO write
	STWI	ADC_CTRL_BASE, 0x00
  14b3d4:	deffff04 	addi	sp,sp,-4
  14b3d8:	da400015 	stw	r9,0(sp)
  14b3dc:	deffff04 	addi	sp,sp,-4
  14b3e0:	da800015 	stw	r10,0(sp)
  14b3e4:	02400574 	movhi	r9,21
  14b3e8:	4a444014 	ori	r9,r9,4352
  14b3ec:	02800034 	movhi	r10,0
  14b3f0:	52800014 	ori	r10,r10,0
  14b3f4:	4a800035 	stwio	r10,0(r9)
  14b3f8:	da800017 	ldw	r10,0(sp)
  14b3fc:	dec00104 	addi	sp,sp,4
  14b400:	da400017 	ldw	r9,0(sp)
  14b404:	dec00104 	addi	sp,sp,4

	mov		r10, r0
  14b408:	0015883a 	mov	r10,zero

0014b40c <adc_int_handler_clear_front>:
adc_int_handler_clear_front:
	# Bitbang clock pulse
	STWI	ADC_CTRL_BASE, 0x01
  14b40c:	deffff04 	addi	sp,sp,-4
  14b410:	da400015 	stw	r9,0(sp)
  14b414:	deffff04 	addi	sp,sp,-4
  14b418:	da800015 	stw	r10,0(sp)
  14b41c:	02400574 	movhi	r9,21
  14b420:	4a444014 	ori	r9,r9,4352
  14b424:	02800034 	movhi	r10,0
  14b428:	52800054 	ori	r10,r10,1
  14b42c:	4a800035 	stwio	r10,0(r9)
  14b430:	da800017 	ldw	r10,0(sp)
  14b434:	dec00104 	addi	sp,sp,4
  14b438:	da400017 	ldw	r9,0(sp)
  14b43c:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x00
  14b440:	deffff04 	addi	sp,sp,-4
  14b444:	da400015 	stw	r9,0(sp)
  14b448:	deffff04 	addi	sp,sp,-4
  14b44c:	da800015 	stw	r10,0(sp)
  14b450:	02400574 	movhi	r9,21
  14b454:	4a444014 	ori	r9,r9,4352
  14b458:	02800034 	movhi	r10,0
  14b45c:	52800014 	ori	r10,r10,0
  14b460:	4a800035 	stwio	r10,0(r9)
  14b464:	da800017 	ldw	r10,0(sp)
  14b468:	dec00104 	addi	sp,sp,4
  14b46c:	da400017 	ldw	r9,0(sp)
  14b470:	dec00104 	addi	sp,sp,4

	addi	r10, r10, 1
  14b474:	52800044 	addi	r10,r10,1
	movi	r13, 13
  14b478:	03400344 	movi	r13,13
	bltu	r10, r13, adc_int_handler_clear_front
  14b47c:	537fe336 	bltu	r10,r13,14b40c <adc_int_handler_clear_front>
  14b480:	02000574 	movhi	r8,21

	movia	r8, sample_buffer_A
  14b484:	42344804 	addi	r8,r8,-12000
	mov		r10, r0
  14b488:	0015883a 	mov	r10,zero

0014b48c <adc_int_handler_loop>:

adc_int_handler_loop:
	# Bitbang clock pulse
	STWI	ADC_CTRL_BASE, 0x01
  14b48c:	deffff04 	addi	sp,sp,-4
  14b490:	da400015 	stw	r9,0(sp)
  14b494:	deffff04 	addi	sp,sp,-4
  14b498:	da800015 	stw	r10,0(sp)
  14b49c:	02400574 	movhi	r9,21
  14b4a0:	4a444014 	ori	r9,r9,4352
  14b4a4:	02800034 	movhi	r10,0
  14b4a8:	52800054 	ori	r10,r10,1
  14b4ac:	4a800035 	stwio	r10,0(r9)
  14b4b0:	da800017 	ldw	r10,0(sp)
  14b4b4:	dec00104 	addi	sp,sp,4
  14b4b8:	da400017 	ldw	r9,0(sp)
  14b4bc:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x00
  14b4c0:	deffff04 	addi	sp,sp,-4
  14b4c4:	da400015 	stw	r9,0(sp)
  14b4c8:	deffff04 	addi	sp,sp,-4
  14b4cc:	da800015 	stw	r10,0(sp)
  14b4d0:	02400574 	movhi	r9,21
  14b4d4:	4a444014 	ori	r9,r9,4352
  14b4d8:	02800034 	movhi	r10,0
  14b4dc:	52800014 	ori	r10,r10,0
  14b4e0:	4a800035 	stwio	r10,0(r9)
  14b4e4:	da800017 	ldw	r10,0(sp)
  14b4e8:	dec00104 	addi	sp,sp,4
  14b4ec:	da400017 	ldw	r9,0(sp)
  14b4f0:	dec00104 	addi	sp,sp,4

	MOVWI	r11, ADC_RAW_BASE
  14b4f4:	02c00574 	movhi	r11,21
  14b4f8:	5ac47014 	ori	r11,r11,4544
	ldwio	r12, (r11)
  14b4fc:	5b000037 	ldwio	r12,0(r11)
	movui	r13, 128
  14b500:	03402014 	movui	r13,128
	add		r12, r12, r13
  14b504:	6359883a 	add	r12,r12,r13
	andi	r12, r12, 0xFF
  14b508:	63003fcc 	andi	r12,r12,255

	stb		r12, (r8)
  14b50c:	43000005 	stb	r12,0(r8)
	addi	r8, r8, 1
  14b510:	42000044 	addi	r8,r8,1
	addi	r10, r10, 1
  14b514:	52800044 	addi	r10,r10,1
	movi	r13, 480
  14b518:	03407804 	movi	r13,480
	bltu	r10, r13, adc_int_handler_loop
  14b51c:	537fdb36 	bltu	r10,r13,14b48c <adc_int_handler_loop>
  14b520:	02000574 	movhi	r8,21

	//call	draw_trace
	# Sample done.
	movia	r8, sample_complete
  14b524:	42344804 	addi	r8,r8,-12000
	movi	r9, 1
  14b528:	02400044 	movi	r9,1
	stb		r9, (r8)
  14b52c:	42400005 	stb	r9,0(r8)

0014b530 <adc_int_handler_done>:
	# Restart trigger counter [ch. A], [+ slope]
	STWI	TRIG_CTRL_BASE, 0x01
	STWI	TRIG_CTRL_BASE, 0x00
	*/

	RESTORE
  14b530:	e037883a 	mov	sp,fp
  14b534:	df000017 	ldw	fp,0(sp)
  14b538:	dec00104 	addi	sp,sp,4
  14b53c:	dfc00017 	ldw	ra,0(sp)
  14b540:	dec00104 	addi	sp,sp,4
	ret
  14b544:	f800283a 	ret

0014b548 <draw_trace>:

.global draw_trace
.type draw_trace, @function

draw_trace:
	SAVE
  14b548:	deffff04 	addi	sp,sp,-4
  14b54c:	dfc00015 	stw	ra,0(sp)
  14b550:	deffff04 	addi	sp,sp,-4
  14b554:	df000015 	stw	fp,0(sp)
  14b558:	d839883a 	mov	fp,sp
	push	r4
  14b55c:	deffff04 	addi	sp,sp,-4
  14b560:	d9000015 	stw	r4,0(sp)
	push	r5
  14b564:	deffff04 	addi	sp,sp,-4
  14b568:	d9400015 	stw	r5,0(sp)
	push	r6
  14b56c:	deffff04 	addi	sp,sp,-4
  14b570:	d9800015 	stw	r6,0(sp)
  14b574:	02000574 	movhi	r8,21

	movia	r8, sample_buffer_A
  14b578:	42344804 	addi	r8,r8,-12000
	mov		r10, r0
  14b57c:	0015883a 	mov	r10,zero

0014b580 <draw_trace_loop>:

draw_trace_loop:
	ldb		r12, (r8)
  14b580:	43000007 	ldb	r12,0(r8)
	movui	r15, 255
  14b584:	03c03fd4 	movui	r15,255
	sub		r12, r15, r12
  14b588:	7b19c83a 	sub	r12,r15,r12
	andi	r12, r12, 0xFF
  14b58c:	63003fcc 	andi	r12,r12,255
	addi	r12, r12, 8
  14b590:	63000204 	addi	r12,r12,8

	MOVWI	r9, VRAM_CTRL_BASE
  14b594:	02400234 	movhi	r9,8
  14b598:	4a400234 	orhi	r9,r9,8
	add		r9, r9, r10
  14b59c:	4a93883a 	add	r9,r9,r10
	add		r9, r9, r10
  14b5a0:	4a93883a 	add	r9,r9,r10

	mov		r11, r0
  14b5a4:	0017883a 	mov	r11,zero

0014b5a8 <draw_trace_col_loop>:
draw_trace_col_loop:
	MOVWI	r15, 0x001C
  14b5a8:	03c00034 	movhi	r15,0
  14b5ac:	7bc00714 	ori	r15,r15,28
	sthio	r15, (r9)
  14b5b0:	4bc0002d 	sthio	r15,0(r9)

	movi	r15, 136
  14b5b4:	03c02204 	movi	r15,136
	beq		r11, r15, draw_grid_pt
  14b5b8:	5bc01726 	beq	r11,r15,14b618 <draw_grid_pt>

	movi	r15, 240
  14b5bc:	03c03c04 	movi	r15,240
	beq		r10, r15, draw_grid_pt
  14b5c0:	53c01526 	beq	r10,r15,14b618 <draw_grid_pt>

	beq		r11, r12, draw_trace_pt
  14b5c4:	5b001826 	beq	r11,r12,14b628 <draw_trace_pt>

0014b5c8 <draw_trace_col_loop_continue>:

draw_trace_col_loop_continue:
	addi	r9, r9, 0x400
  14b5c8:	4a410004 	addi	r9,r9,1024
	addi	r11, r11, 1
  14b5cc:	5ac00044 	addi	r11,r11,1
	movi	r15, 272
  14b5d0:	03c04404 	movi	r15,272
	bltu	r11, r15, draw_trace_col_loop
  14b5d4:	5bfff436 	bltu	r11,r15,14b5a8 <draw_trace_col_loop>

	addi	r8, r8, 1
  14b5d8:	42000044 	addi	r8,r8,1
	addi	r10, r10, 1
  14b5dc:	52800044 	addi	r10,r10,1
	movi	r15, 480
  14b5e0:	03c07804 	movi	r15,480
	bltu	r10, r15, draw_trace_loop
  14b5e4:	53ffe636 	bltu	r10,r15,14b580 <draw_trace_loop>

0014b5e8 <draw_trace_done>:

draw_trace_done:
	pop		r6
  14b5e8:	d9800017 	ldw	r6,0(sp)
  14b5ec:	dec00104 	addi	sp,sp,4
	pop		r5
  14b5f0:	d9400017 	ldw	r5,0(sp)
  14b5f4:	dec00104 	addi	sp,sp,4
	pop		r4
  14b5f8:	d9000017 	ldw	r4,0(sp)
  14b5fc:	dec00104 	addi	sp,sp,4
	RESTORE
  14b600:	e037883a 	mov	sp,fp
  14b604:	df000017 	ldw	fp,0(sp)
  14b608:	dec00104 	addi	sp,sp,4
  14b60c:	dfc00017 	ldw	ra,0(sp)
  14b610:	dec00104 	addi	sp,sp,4
	ret
  14b614:	f800283a 	ret

0014b618 <draw_grid_pt>:

draw_grid_pt:
	MOVWI	r15, 0x1F00
  14b618:	03c00034 	movhi	r15,0
  14b61c:	7bc7c014 	ori	r15,r15,7936
	sthio	r15, (r9)
  14b620:	4bc0002d 	sthio	r15,0(r9)
	br		draw_trace_col_loop_continue
  14b624:	003fe806 	br	14b5c8 <draw_trace_col_loop_continue>

0014b628 <draw_trace_pt>:

draw_trace_pt:
	MOVWI	r15, 0xE07F
  14b628:	03c00034 	movhi	r15,0
  14b62c:	7bf81fd4 	ori	r15,r15,57471
	sthio	r15, (r9)
  14b630:	4bc0002d 	sthio	r15,0(r9)
	br		draw_trace_col_loop_continue
  14b634:	003fe406 	br	14b5c8 <draw_trace_col_loop_continue>

0014b638 <draw_grid>:

.global draw_grid
.type draw_grid, @function

draw_grid:
	SAVE
  14b638:	deffff04 	addi	sp,sp,-4
  14b63c:	dfc00015 	stw	ra,0(sp)
  14b640:	deffff04 	addi	sp,sp,-4
  14b644:	df000015 	stw	fp,0(sp)
  14b648:	d839883a 	mov	fp,sp
	push	r4
  14b64c:	deffff04 	addi	sp,sp,-4
  14b650:	d9000015 	stw	r4,0(sp)
	push	r5
  14b654:	deffff04 	addi	sp,sp,-4
  14b658:	d9400015 	stw	r5,0(sp)
	push	r6
  14b65c:	deffff04 	addi	sp,sp,-4
  14b660:	d9800015 	stw	r6,0(sp)

	movui	r6, 0x1F00
  14b664:	0187c014 	movui	r6,7936

	movui	r4, 136
  14b668:	01002214 	movui	r4,136
	mov		r5, r0
  14b66c:	000b883a 	mov	r5,zero

0014b670 <draw_grid_horiz>:
draw_grid_horiz:
	call	draw_pixel
  14b670:	014b6ec0 	call	14b6ec <draw_pixel>
	movui	r6, 0x003C
  14b674:	01800f14 	movui	r6,60
	addi	r4, r4, 1
  14b678:	21000044 	addi	r4,r4,1
	call	draw_pixel
  14b67c:	014b6ec0 	call	14b6ec <draw_pixel>
	addi	r4, r4, 1
  14b680:	21000044 	addi	r4,r4,1
	call	draw_pixel
  14b684:	014b6ec0 	call	14b6ec <draw_pixel>
	addi	r4, r4, 1
  14b688:	21000044 	addi	r4,r4,1
	call	draw_pixel
  14b68c:	014b6ec0 	call	14b6ec <draw_pixel>
	movui	r6, 0x1F00
  14b690:	0187c014 	movui	r6,7936
	subi	r4, r4, 3
  14b694:	213fff44 	addi	r4,r4,-3

	addi	r5, r5, 1
  14b698:	29400044 	addi	r5,r5,1
	movi	r8, 480
  14b69c:	02007804 	movi	r8,480
	bltu	r5, r8, draw_grid_horiz
  14b6a0:	2a3ff336 	bltu	r5,r8,14b670 <draw_grid_horiz>

	mov		r4, r0
  14b6a4:	0009883a 	mov	r4,zero
	movui	r5, 240
  14b6a8:	01403c14 	movui	r5,240

0014b6ac <draw_grid_vert>:
draw_grid_vert:
	call	draw_pixel
  14b6ac:	014b6ec0 	call	14b6ec <draw_pixel>

	addi	r4, r4, 1
  14b6b0:	21000044 	addi	r4,r4,1
	movi	r8, 272
  14b6b4:	02004404 	movi	r8,272
	bltu	r4, r8, draw_grid_vert
  14b6b8:	223ffc36 	bltu	r4,r8,14b6ac <draw_grid_vert>

0014b6bc <draw_grid_done>:

draw_grid_done:
	pop		r6
  14b6bc:	d9800017 	ldw	r6,0(sp)
  14b6c0:	dec00104 	addi	sp,sp,4
	pop		r5
  14b6c4:	d9400017 	ldw	r5,0(sp)
  14b6c8:	dec00104 	addi	sp,sp,4
	pop		r4
  14b6cc:	d9000017 	ldw	r4,0(sp)
  14b6d0:	dec00104 	addi	sp,sp,4
	RESTORE
  14b6d4:	e037883a 	mov	sp,fp
  14b6d8:	df000017 	ldw	fp,0(sp)
  14b6dc:	dec00104 	addi	sp,sp,4
  14b6e0:	dfc00017 	ldw	ra,0(sp)
  14b6e4:	dec00104 	addi	sp,sp,4
	ret
  14b6e8:	f800283a 	ret

0014b6ec <draw_pixel>:




draw_pixel:
	SAVE
  14b6ec:	deffff04 	addi	sp,sp,-4
  14b6f0:	dfc00015 	stw	ra,0(sp)
  14b6f4:	deffff04 	addi	sp,sp,-4
  14b6f8:	df000015 	stw	fp,0(sp)
  14b6fc:	d839883a 	mov	fp,sp

	push	r4
  14b700:	deffff04 	addi	sp,sp,-4
  14b704:	d9000015 	stw	r4,0(sp)
	push	r5
  14b708:	deffff04 	addi	sp,sp,-4
  14b70c:	d9400015 	stw	r5,0(sp)

	slli	r4, r4, 10
  14b710:	200892ba 	slli	r4,r4,10
	add		r4, r4, r5
  14b714:	2149883a 	add	r4,r4,r5
	add		r4, r4, r5
  14b718:	2149883a 	add	r4,r4,r5
	MOVWI	r5, VRAM_CTRL_BASE
  14b71c:	01400234 	movhi	r5,8
  14b720:	29400234 	orhi	r5,r5,8
	add		r4, r4, r5
  14b724:	2149883a 	add	r4,r4,r5
	sth		r6, (r4)
  14b728:	2180000d 	sth	r6,0(r4)

	pop		r5
  14b72c:	d9400017 	ldw	r5,0(sp)
  14b730:	dec00104 	addi	sp,sp,4
	pop		r4
  14b734:	d9000017 	ldw	r4,0(sp)
  14b738:	dec00104 	addi	sp,sp,4

0014b73c <draw_pixel_done>:

draw_pixel_done:
	RESTORE
  14b73c:	e037883a 	mov	sp,fp
  14b740:	df000017 	ldw	fp,0(sp)
  14b744:	dec00104 	addi	sp,sp,4
  14b748:	dfc00017 	ldw	ra,0(sp)
  14b74c:	dec00104 	addi	sp,sp,4
	ret
  14b750:	f800283a 	ret

0014b754 <clear_display_x>:

.global clear_display_x
.type clear_display_x, @function

clear_display_x:
	SAVE
  14b754:	deffff04 	addi	sp,sp,-4
  14b758:	dfc00015 	stw	ra,0(sp)
  14b75c:	deffff04 	addi	sp,sp,-4
  14b760:	df000015 	stw	fp,0(sp)
  14b764:	d839883a 	mov	fp,sp

	MOVWI	r8, VRAM_CTRL_BASE
  14b768:	02000234 	movhi	r8,8
  14b76c:	42000234 	orhi	r8,r8,8
	movui	r9, 272
  14b770:	02404414 	movui	r9,272
	slli	r9, r9, 10
  14b774:	481292ba 	slli	r9,r9,10
	add		r9, r8, r9
  14b778:	4253883a 	add	r9,r8,r9
	movui	r15, 0x001C
  14b77c:	03c00714 	movui	r15,28

0014b780 <loop_clr_x>:

loop_clr_x:
	sthio 	r15, (r8)
  14b780:	43c0002d 	sthio	r15,0(r8)
	addi	r8, r8, 2
  14b784:	42000084 	addi	r8,r8,2
	bltu	r8, r9, loop_clr_x
  14b788:	427ffd36 	bltu	r8,r9,14b780 <loop_clr_x>

	RESTORE
  14b78c:	e037883a 	mov	sp,fp
  14b790:	df000017 	ldw	fp,0(sp)
  14b794:	dec00104 	addi	sp,sp,4
  14b798:	dfc00017 	ldw	ra,0(sp)
  14b79c:	dec00104 	addi	sp,sp,4
	ret
  14b7a0:	f800283a 	ret

0014b7a4 <clear_display>:

.global clear_display
.type clear_display, @function

clear_display:
	SAVE
  14b7a4:	deffff04 	addi	sp,sp,-4
  14b7a8:	dfc00015 	stw	ra,0(sp)
  14b7ac:	deffff04 	addi	sp,sp,-4
  14b7b0:	df000015 	stw	fp,0(sp)
  14b7b4:	d839883a 	mov	fp,sp

	MOVWI	r8, VRAM_CTRL_BASE
  14b7b8:	02000234 	movhi	r8,8
  14b7bc:	42000234 	orhi	r8,r8,8
	movui	r9, 272
  14b7c0:	02404414 	movui	r9,272
	slli	r9, r9, 10
  14b7c4:	481292ba 	slli	r9,r9,10
	add		r9, r8, r9
  14b7c8:	4253883a 	add	r9,r8,r9
	movui	r15, 0x001C
  14b7cc:	03c00714 	movui	r15,28

0014b7d0 <clear_display_loop>:

clear_display_loop:
	sthio 	r15, (r8)
  14b7d0:	43c0002d 	sthio	r15,0(r8)
	addi	r8, r8, 2
  14b7d4:	42000084 	addi	r8,r8,2
	bltu	r8, r9, clear_display_loop
  14b7d8:	427ffd36 	bltu	r8,r9,14b7d0 <clear_display_loop>

0014b7dc <clear_display_done>:

clear_display_done:
	RESTORE
  14b7dc:	e037883a 	mov	sp,fp
  14b7e0:	df000017 	ldw	fp,0(sp)
  14b7e4:	dec00104 	addi	sp,sp,4
  14b7e8:	dfc00017 	ldw	ra,0(sp)
  14b7ec:	dec00104 	addi	sp,sp,4
	ret
  14b7f0:	f800283a 	ret

0014b7f4 <plot_pixel>:

.global plot_pixel
.type plot_pixel, @function

plot_pixel:
	SAVE
  14b7f4:	deffff04 	addi	sp,sp,-4
  14b7f8:	dfc00015 	stw	ra,0(sp)
  14b7fc:	deffff04 	addi	sp,sp,-4
  14b800:	df000015 	stw	fp,0(sp)
  14b804:	d839883a 	mov	fp,sp

	push	r4
  14b808:	deffff04 	addi	sp,sp,-4
  14b80c:	d9000015 	stw	r4,0(sp)
	push	r5
  14b810:	deffff04 	addi	sp,sp,-4
  14b814:	d9400015 	stw	r5,0(sp)

	slli	r5, r5, 10
  14b818:	280a92ba 	slli	r5,r5,10
	add		r5, r5, r4
  14b81c:	290b883a 	add	r5,r5,r4
	add		r5, r5, r4
  14b820:	290b883a 	add	r5,r5,r4
	MOVWI	r4, VRAM_CTRL_BASE
  14b824:	01000234 	movhi	r4,8
  14b828:	21000234 	orhi	r4,r4,8
	add		r5, r5, r4
  14b82c:	290b883a 	add	r5,r5,r4
	sth		r6, (r5)
  14b830:	2980000d 	sth	r6,0(r5)

	pop		r5
  14b834:	d9400017 	ldw	r5,0(sp)
  14b838:	dec00104 	addi	sp,sp,4
	pop		r4
  14b83c:	d9000017 	ldw	r4,0(sp)
  14b840:	dec00104 	addi	sp,sp,4

0014b844 <plot_pixel_done>:

plot_pixel_done:
	RESTORE
  14b844:	e037883a 	mov	sp,fp
  14b848:	df000017 	ldw	fp,0(sp)
  14b84c:	dec00104 	addi	sp,sp,4
  14b850:	dfc00017 	ldw	ra,0(sp)
  14b854:	dec00104 	addi	sp,sp,4
	ret
  14b858:	f800283a 	ret

0014b85c <set_sample_rate>:

.global set_sample_rate
.type set_sample_rate, @function

set_sample_rate:
	SAVE
  14b85c:	deffff04 	addi	sp,sp,-4
  14b860:	dfc00015 	stw	ra,0(sp)
  14b864:	deffff04 	addi	sp,sp,-4
  14b868:	df000015 	stw	fp,0(sp)
  14b86c:	d839883a 	mov	fp,sp

	# Divide fastest sample rate by desired sample rate
	# to get number of ticks to pause (not collect samples)
	# between collecting samples.
	MOVWI	r8, ADC_RATE_BASE
  14b870:	02000574 	movhi	r8,21
  14b874:	42046c14 	ori	r8,r8,4528
	#MOVWI	r9, 180000000
	#divu	r9, r9, r4
	#MOVWI	r9, 100000
	stw		r4, (r8)
  14b878:	41000015 	stw	r4,0(r8)

	MOVWI	r8, TEST_INPUT_BASE
  14b87c:	02000574 	movhi	r8,21
  14b880:	42046414 	ori	r8,r8,4496
	ldw		r9, (r8)
  14b884:	42400017 	ldw	r9,0(r8)

	# Always return 480 samples.
	movui	r2, 480
  14b888:	00807814 	movui	r2,480

0014b88c <set_sample_rate_done>:

set_sample_rate_done:
	RESTORE
  14b88c:	e037883a 	mov	sp,fp
  14b890:	df000017 	ldw	fp,0(sp)
  14b894:	dec00104 	addi	sp,sp,4
  14b898:	dfc00017 	ldw	ra,0(sp)
  14b89c:	dec00104 	addi	sp,sp,4
	ret
  14b8a0:	f800283a 	ret

0014b8a4 <set_trigger>:

.global set_trigger
.type set_trigger, @function

set_trigger:
	SAVE
  14b8a4:	deffff04 	addi	sp,sp,-4
  14b8a8:	dfc00015 	stw	ra,0(sp)
  14b8ac:	deffff04 	addi	sp,sp,-4
  14b8b0:	df000015 	stw	fp,0(sp)
  14b8b4:	d839883a 	mov	fp,sp

	# Convert [0 to 127] to signed 8-bit [-127 to 127].
	# Then update trigger level.
	MOVWI	r8, TRIG_LEVEL_BASE
  14b8b8:	02000574 	movhi	r8,21
  14b8bc:	42043014 	ori	r8,r8,4288
	slli	r9, r4, 1
  14b8c0:	2012907a 	slli	r9,r4,1
	subi	r9, r9, 127
  14b8c4:	4a7fe044 	addi	r9,r9,-127
	andi	r9, r9, 0xFF
  14b8c8:	4a403fcc 	andi	r9,r9,255
	stw		r9, (r8)
  14b8cc:	42400015 	stw	r9,0(r8)

	# Slope is second bit of TRIG_CTRL. Modify the given
	# argument, then update slope.
	beq		r5, r0, set_trigger_slope_pos
  14b8d0:	28000526 	beq	r5,zero,14b8e8 <set_trigger_slope_pos>
	movi	r8, 0x02
  14b8d4:	02000084 	movi	r8,2
	MOVWI	r9, TRIG_CTRL_BASE
  14b8d8:	02400574 	movhi	r9,21
  14b8dc:	4a443814 	ori	r9,r9,4320
	stw		r8, PIO_OUTSET(r9)
  14b8e0:	4a000415 	stw	r8,16(r9)
	br		set_trigger_done
  14b8e4:	00000406 	br	14b8f8 <set_trigger_done>

0014b8e8 <set_trigger_slope_pos>:

set_trigger_slope_pos:
	movi	r8, 0x02
  14b8e8:	02000084 	movi	r8,2
	MOVWI	r9, TRIG_CTRL_BASE
  14b8ec:	02400574 	movhi	r9,21
  14b8f0:	4a443814 	ori	r9,r9,4320
	stw		r8, PIO_OUTCLR(r9)
  14b8f4:	4a000515 	stw	r8,20(r9)

0014b8f8 <set_trigger_done>:

set_trigger_done:
	RESTORE
  14b8f8:	e037883a 	mov	sp,fp
  14b8fc:	df000017 	ldw	fp,0(sp)
  14b900:	dec00104 	addi	sp,sp,4
  14b904:	dfc00017 	ldw	ra,0(sp)
  14b908:	dec00104 	addi	sp,sp,4
	ret
  14b90c:	f800283a 	ret

0014b910 <set_delay>:

.global set_delay
.type set_delay, @function

set_delay:
	SAVE
  14b910:	deffff04 	addi	sp,sp,-4
  14b914:	dfc00015 	stw	ra,0(sp)
  14b918:	deffff04 	addi	sp,sp,-4
  14b91c:	df000015 	stw	fp,0(sp)
  14b920:	d839883a 	mov	fp,sp

	# Simply set the delay...
	MOVWI	r8, TRIG_DELAY_BASE
  14b924:	02000574 	movhi	r8,21
  14b928:	42042814 	ori	r8,r8,4256
	stw		r4, (r8)
  14b92c:	41000015 	stw	r4,0(r8)

0014b930 <set_delay_done>:

set_delay_done:
	RESTORE
  14b930:	e037883a 	mov	sp,fp
  14b934:	df000017 	ldw	fp,0(sp)
  14b938:	dec00104 	addi	sp,sp,4
  14b93c:	dfc00017 	ldw	ra,0(sp)
  14b940:	dec00104 	addi	sp,sp,4
	ret
  14b944:	f800283a 	ret

0014b948 <start_sample>:

.global start_sample
.type start_sample, @function

start_sample:
	SAVE
  14b948:	deffff04 	addi	sp,sp,-4
  14b94c:	dfc00015 	stw	ra,0(sp)
  14b950:	deffff04 	addi	sp,sp,-4
  14b954:	df000015 	stw	fp,0(sp)
  14b958:	d839883a 	mov	fp,sp

	# Clear the edge capture register (write 1 to clear).
	MOVWI	r8, TRIG_INT_BASE
  14b95c:	02000574 	movhi	r8,21
  14b960:	42044814 	ori	r8,r8,4384
	MOVWI	r9, 0xFFFFFFFF
  14b964:	027ffff4 	movhi	r9,65535
  14b968:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_EDGE_CAP(r8)
  14b96c:	42400315 	stw	r9,12(r8)

	# Enable trigger interrupts.
	MOVWI	r9, 0x00000002
  14b970:	02400034 	movhi	r9,0
  14b974:	4a400094 	ori	r9,r9,2
	# If auto-trigger, enable time-outs as well.
	slli	r8, r4, 2
  14b978:	201090ba 	slli	r8,r4,2
	add		r9, r8, r9
  14b97c:	4253883a 	add	r9,r8,r9

	MOVWI	r8, TRIG_INT_BASE
  14b980:	02000574 	movhi	r8,21
  14b984:	42044814 	ori	r8,r8,4384
	stw		r9, PIO_IRQ_MASK(r8)
  14b988:	42400215 	stw	r9,8(r8)

	# Clear FIFO, turn on FIFO write.
	STWI	ADC_CTRL_BASE, 0x04
  14b98c:	deffff04 	addi	sp,sp,-4
  14b990:	da400015 	stw	r9,0(sp)
  14b994:	deffff04 	addi	sp,sp,-4
  14b998:	da800015 	stw	r10,0(sp)
  14b99c:	02400574 	movhi	r9,21
  14b9a0:	4a444014 	ori	r9,r9,4352
  14b9a4:	02800034 	movhi	r10,0
  14b9a8:	52800114 	ori	r10,r10,4
  14b9ac:	4a800035 	stwio	r10,0(r9)
  14b9b0:	da800017 	ldw	r10,0(sp)
  14b9b4:	dec00104 	addi	sp,sp,4
  14b9b8:	da400017 	ldw	r9,0(sp)
  14b9bc:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  14b9c0:	deffff04 	addi	sp,sp,-4
  14b9c4:	da400015 	stw	r9,0(sp)
  14b9c8:	deffff04 	addi	sp,sp,-4
  14b9cc:	da800015 	stw	r10,0(sp)
  14b9d0:	02400574 	movhi	r9,21
  14b9d4:	4a444014 	ori	r9,r9,4352
  14b9d8:	02800034 	movhi	r10,0
  14b9dc:	52800094 	ori	r10,r10,2
  14b9e0:	4a800035 	stwio	r10,0(r9)
  14b9e4:	da800017 	ldw	r10,0(sp)
  14b9e8:	dec00104 	addi	sp,sp,4
  14b9ec:	da400017 	ldw	r9,0(sp)
  14b9f0:	dec00104 	addi	sp,sp,4

	# Restart trigger counter [ch. A], [+ slope]
	MOVWI	r8, TRIG_CTRL_BASE
  14b9f4:	02000574 	movhi	r8,21
  14b9f8:	42043814 	ori	r8,r8,4320
	movi	r9, 1
  14b9fc:	02400044 	movi	r9,1
	stw		r9, PIO_OUTSET(r8)
  14ba00:	42400415 	stw	r9,16(r8)
	stw		r9, PIO_OUTCLR(r8)
  14ba04:	42400515 	stw	r9,20(r8)

0014ba08 <start_sample_done>:

start_sample_done:
	RESTORE
  14ba08:	e037883a 	mov	sp,fp
  14ba0c:	df000017 	ldw	fp,0(sp)
  14ba10:	dec00104 	addi	sp,sp,4
  14ba14:	dfc00017 	ldw	ra,0(sp)
  14ba18:	dec00104 	addi	sp,sp,4
	ret
  14ba1c:	f800283a 	ret

0014ba20 <sample_done>:

.global sample_done
.type sample_done, @function

sample_done:
	SAVE
  14ba20:	deffff04 	addi	sp,sp,-4
  14ba24:	dfc00015 	stw	ra,0(sp)
  14ba28:	deffff04 	addi	sp,sp,-4
  14ba2c:	df000015 	stw	fp,0(sp)
  14ba30:	d839883a 	mov	fp,sp
  14ba34:	02000574 	movhi	r8,21

	# Test if sample occurred.
	movia	r8, sample_complete
  14ba38:	42344804 	addi	r8,r8,-12000
	ldb		r9, (r8)
  14ba3c:	42400007 	ldb	r9,0(r8)
	beq		r9, r0, sample_null
  14ba40:	48000426 	beq	r9,zero,14ba54 <sample_null>

	# If so, reset sample complete variable and return buffer start.
	stb		r0, (r8)
  14ba44:	40000005 	stb	zero,0(r8)
  14ba48:	00800574 	movhi	r2,21
	movia	r2, sample_buffer_A
  14ba4c:	10b44804 	addi	r2,r2,-12000
	br		sample_done_done
  14ba50:	00000106 	br	14ba58 <sample_done_done>

0014ba54 <sample_null>:

sample_null:
	# Otherwise, return null.
	mov		r2, r0
  14ba54:	0005883a 	mov	r2,zero

0014ba58 <sample_done_done>:

sample_done_done:
	RESTORE
  14ba58:	e037883a 	mov	sp,fp
  14ba5c:	df000017 	ldw	fp,0(sp)
  14ba60:	dec00104 	addi	sp,sp,4
  14ba64:	dfc00017 	ldw	ra,0(sp)
  14ba68:	dec00104 	addi	sp,sp,4
	ret
  14ba6c:	f800283a 	ret

0014ba70 <test_disp>:

.global test_disp
.type test_disp,@function

test_disp:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  14ba70:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  14ba74:	42000234 	orhi	r8,r8,8
	mov		r11, r0
  14ba78:	0017883a 	mov	r11,zero
	mov		r12, r0
  14ba7c:	0019883a 	mov	r12,zero

0014ba80 <disp>:

disp:
	movi	r13, 136
  14ba80:	03402204 	movi	r13,136
	bltu	r12, r13, draw_top
  14ba84:	63400836 	bltu	r12,r13,14baa8 <draw_top>
	br 		draw_bot
  14ba88:	00000a06 	br	14bab4 <draw_bot>

0014ba8c <disp_cont>:
disp_cont:
	addi	r8, r8, 2
  14ba8c:	42000084 	addi	r8,r8,2
	addi	r11, r11, 1
  14ba90:	5ac00044 	addi	r11,r11,1
	movi	r13, 272
  14ba94:	03404404 	movi	r13,272
	bgeu	r12, r13, draw_border
  14ba98:	6340152e 	bgeu	r12,r13,14baf0 <draw_border>
	movi	r13, 0x0200
  14ba9c:	03408004 	movi	r13,512
	bgeu	r11, r13, disp_reset
  14baa0:	5b403d2e 	bgeu	r11,r13,14bb98 <disp_reset>
	br		disp
  14baa4:	003ff606 	br	14ba80 <disp>

0014baa8 <draw_top>:

draw_top:
	movi	r13, 240
  14baa8:	03403c04 	movi	r13,240
	bltu	r11, r13, draw_red
  14baac:	5b400436 	bltu	r11,r13,14bac0 <draw_red>
	br		draw_yellow
  14bab0:	00000606 	br	14bacc <draw_yellow>

0014bab4 <draw_bot>:

draw_bot:
	movi	r13, 240
  14bab4:	03403c04 	movi	r13,240
	bltu	r11, r13, draw_green
  14bab8:	5b400736 	bltu	r11,r13,14bad8 <draw_green>
	br		draw_blue
  14babc:	00000906 	br	14bae4 <draw_blue>

0014bac0 <draw_red>:

draw_red:
	movi	r9, 0x1F00
  14bac0:	0247c004 	movi	r9,7936
	sthio	r9, (r8)
  14bac4:	4240002d 	sthio	r9,0(r8)
	br 		disp_cont
  14bac8:	003ff006 	br	14ba8c <disp_cont>

0014bacc <draw_yellow>:

draw_yellow:
	movui	r9, 0xFF03
  14bacc:	027fc0d4 	movui	r9,65283
	sthio 	r9, (r8)
  14bad0:	4240002d 	sthio	r9,0(r8)
	br		disp_cont
  14bad4:	003fed06 	br	14ba8c <disp_cont>

0014bad8 <draw_green>:

draw_green:
	movui	r9, 0xE003
  14bad8:	027800d4 	movui	r9,57347
	sthio 	r9, (r8)
  14badc:	4240002d 	sthio	r9,0(r8)
	br		disp_cont
  14bae0:	003fea06 	br	14ba8c <disp_cont>

0014bae4 <draw_blue>:

draw_blue:
	movi	r9, 0x007C
  14bae4:	02401f04 	movi	r9,124
	sthio 	r9, (r8)
  14bae8:	4240002d 	sthio	r9,0(r8)
	br		disp_cont
  14baec:	003fe706 	br	14ba8c <disp_cont>

0014baf0 <draw_border>:

draw_border:
	movi	r9, 0x1F7C
  14baf0:	0247df04 	movi	r9,8060
	movi	r12, 272
  14baf4:	03004404 	movi	r12,272
	movi	r13, 480
  14baf8:	03407804 	movi	r13,480

0014bafc <draw_border_top>:

draw_border_top:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  14bafc:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  14bb00:	42000234 	orhi	r8,r8,8
	addi	r8, r8, 0x0400
  14bb04:	42010004 	addi	r8,r8,1024
	mov		r11, r0
  14bb08:	0017883a 	mov	r11,zero

0014bb0c <dbt_loop>:
dbt_loop:
	sthio	r9, (r8)
  14bb0c:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 2
  14bb10:	42000084 	addi	r8,r8,2
	addi	r11, r11, 1
  14bb14:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r13, draw_border_bot
  14bb18:	5b40012e 	bgeu	r11,r13,14bb20 <draw_border_bot>
	br		dbt_loop
  14bb1c:	003ffb06 	br	14bb0c <dbt_loop>

0014bb20 <draw_border_bot>:

draw_border_bot:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  14bb20:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  14bb24:	42000234 	orhi	r8,r8,8
	movhi	r14, %hi(277504)
  14bb28:	03800134 	movhi	r14,4
	ori		r14, r14, %lo(277504)
  14bb2c:	738f0014 	ori	r14,r14,15360
	add		r8, r8, r14
  14bb30:	4391883a 	add	r8,r8,r14
	mov		r11, r0
  14bb34:	0017883a 	mov	r11,zero

0014bb38 <dbb_loop>:
dbb_loop:
	sthio	r9, (r8)
  14bb38:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 2
  14bb3c:	42000084 	addi	r8,r8,2
	addi	r11, r11, 1
  14bb40:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r13, draw_border_left
  14bb44:	5b40012e 	bgeu	r11,r13,14bb4c <draw_border_left>
	br		dbb_loop
  14bb48:	003ffb06 	br	14bb38 <dbb_loop>

0014bb4c <draw_border_left>:

draw_border_left:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  14bb4c:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  14bb50:	42000234 	orhi	r8,r8,8
	mov		r11, r0
  14bb54:	0017883a 	mov	r11,zero

0014bb58 <dbl_loop>:
dbl_loop:
	sthio	r9, (r8)
  14bb58:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 0x0400
  14bb5c:	42010004 	addi	r8,r8,1024
	addi	r11, r11, 1
  14bb60:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r12, draw_border_right
  14bb64:	5b00012e 	bgeu	r11,r12,14bb6c <draw_border_right>
	br		dbl_loop
  14bb68:	003ffb06 	br	14bb58 <dbl_loop>

0014bb6c <draw_border_right>:

draw_border_right:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  14bb6c:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  14bb70:	42000234 	orhi	r8,r8,8
	add		r8, r8, r13
  14bb74:	4351883a 	add	r8,r8,r13
	add		r8, r8, r13
  14bb78:	4351883a 	add	r8,r8,r13
	subi	r8, r8, 1
  14bb7c:	423fffc4 	addi	r8,r8,-1
	mov		r11, r0
  14bb80:	0017883a 	mov	r11,zero

0014bb84 <dbr_loop>:
dbr_loop:
	sthio	r9, (r8)
  14bb84:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 0x0400
  14bb88:	42010004 	addi	r8,r8,1024
	addi	r11, r11, 1
  14bb8c:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r12, test_disp_done
  14bb90:	5b00042e 	bgeu	r11,r12,14bba4 <test_disp_done>
	br		dbr_loop
  14bb94:	003ffb06 	br	14bb84 <dbr_loop>

0014bb98 <disp_reset>:

disp_reset:
	mov		r11, r0
  14bb98:	0017883a 	mov	r11,zero
	addi	r12, r12, 1
  14bb9c:	63000044 	addi	r12,r12,1
	br		disp
  14bba0:	003fb706 	br	14ba80 <disp>

0014bba4 <test_disp_done>:

test_disp_done:
	ret
  14bba4:	f800283a 	ret

0014bba8 <test_vram>:

.global test_vram
.type test_vram,@function

test_vram:
	SAVE
  14bba8:	deffff04 	addi	sp,sp,-4
  14bbac:	dfc00015 	stw	ra,0(sp)
  14bbb0:	deffff04 	addi	sp,sp,-4
  14bbb4:	df000015 	stw	fp,0(sp)
  14bbb8:	d839883a 	mov	fp,sp

	movhi	r8, %hi(VRAM_CTRL_BASE)
  14bbbc:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  14bbc0:	42000234 	orhi	r8,r8,8
	movhi	r9, %hi(VRAM_CTRL_SPAN)
  14bbc4:	02400234 	movhi	r9,8
	ori		r9, r9, %lo(VRAM_CTRL_SPAN)
  14bbc8:	4a400234 	orhi	r9,r9,8
	add		r9, r8, r9
  14bbcc:	4253883a 	add	r9,r8,r9
	movui	r12, 0x7000
  14bbd0:	031c0014 	movui	r12,28672

	#call	write_read_all

	call	write_all
  14bbd4:	014bc040 	call	14bc04 <write_all>
	call	read_all
  14bbd8:	014bc300 	call	14bc30 <read_all>

	nop
  14bbdc:	0001883a 	nop
	call	read_all
  14bbe0:	014bc300 	call	14bc30 <read_all>

0014bbe4 <test_vram_fail>:

test_vram_fail:
	nop
  14bbe4:	0001883a 	nop
	br 		test_vram_fail
  14bbe8:	003ffe06 	br	14bbe4 <test_vram_fail>

0014bbec <test_vram_done>:

test_vram_done:
	RESTORE
  14bbec:	e037883a 	mov	sp,fp
  14bbf0:	df000017 	ldw	fp,0(sp)
  14bbf4:	dec00104 	addi	sp,sp,4
  14bbf8:	dfc00017 	ldw	ra,0(sp)
  14bbfc:	dec00104 	addi	sp,sp,4
	ret
  14bc00:	f800283a 	ret

0014bc04 <write_all>:


.type write_all, @function

write_all:
	mov		r10, r8
  14bc04:	4015883a 	mov	r10,r8
	mov		r11, r0
  14bc08:	0017883a 	mov	r11,zero

0014bc0c <write_all_loop>:

write_all_loop:
	sthio	r11, (r10)
  14bc0c:	52c0002d 	sthio	r11,0(r10)
	addi	r10, r10, 2
  14bc10:	52800084 	addi	r10,r10,2
	addi	r11, r11, 1
  14bc14:	5ac00044 	addi	r11,r11,1
	bgeu	r10, r9, write_all_done
  14bc18:	5240042e 	bgeu	r10,r9,14bc2c <write_all_done>
	bgeu	r11, r12, write_all_reset_cnt
  14bc1c:	5b00012e 	bgeu	r11,r12,14bc24 <write_all_reset_cnt>
	br		write_all_loop
  14bc20:	003ffa06 	br	14bc0c <write_all_loop>

0014bc24 <write_all_reset_cnt>:

write_all_reset_cnt:
	mov		r11, r0
  14bc24:	0017883a 	mov	r11,zero
	br		write_all_loop
  14bc28:	003ff806 	br	14bc0c <write_all_loop>

0014bc2c <write_all_done>:

write_all_done:
	ret
  14bc2c:	f800283a 	ret

0014bc30 <read_all>:


.type read_all, @function

read_all:
	mov		r10, r8
  14bc30:	4015883a 	mov	r10,r8
	mov		r11, r0
  14bc34:	0017883a 	mov	r11,zero

0014bc38 <read_all_loop>:

read_all_loop:
	ldhio	r13, (r10)
  14bc38:	5340002f 	ldhio	r13,0(r10)
	bne		r13, r11, test_vram_fail
  14bc3c:	6affe91e 	bne	r13,r11,14bbe4 <test_vram_fail>
	addi	r10, r10, 2
  14bc40:	52800084 	addi	r10,r10,2
	addi	r11, r11, 1
  14bc44:	5ac00044 	addi	r11,r11,1
	bgeu	r10, r9, read_all_done
  14bc48:	5240042e 	bgeu	r10,r9,14bc5c <read_all_done>
	bgeu	r11, r12, read_all_reset_cnt
  14bc4c:	5b00012e 	bgeu	r11,r12,14bc54 <read_all_reset_cnt>
	br		read_all_loop
  14bc50:	003ff906 	br	14bc38 <read_all_loop>

0014bc54 <read_all_reset_cnt>:

read_all_reset_cnt:
	mov		r11, r0
  14bc54:	0017883a 	mov	r11,zero
	br		write_all_loop
  14bc58:	003fec06 	br	14bc0c <write_all_loop>

0014bc5c <read_all_done>:

read_all_done:
	ret
  14bc5c:	f800283a 	ret

0014bc60 <udivmodsi4>:
  14bc60:	2005883a 	mov	r2,r4
  14bc64:	2900182e 	bgeu	r5,r4,14bcc8 <udivmodsi4+0x68>
  14bc68:	28001716 	blt	r5,zero,14bcc8 <udivmodsi4+0x68>
  14bc6c:	01000804 	movi	r4,32
  14bc70:	00c00044 	movi	r3,1
  14bc74:	00000206 	br	14bc80 <udivmodsi4+0x20>
  14bc78:	20001126 	beq	r4,zero,14bcc0 <udivmodsi4+0x60>
  14bc7c:	28000516 	blt	r5,zero,14bc94 <udivmodsi4+0x34>
  14bc80:	294b883a 	add	r5,r5,r5
  14bc84:	213fffc4 	addi	r4,r4,-1
  14bc88:	18c7883a 	add	r3,r3,r3
  14bc8c:	28bffa36 	bltu	r5,r2,14bc78 <udivmodsi4+0x18>
  14bc90:	18000b26 	beq	r3,zero,14bcc0 <udivmodsi4+0x60>
  14bc94:	0009883a 	mov	r4,zero
  14bc98:	11400236 	bltu	r2,r5,14bca4 <udivmodsi4+0x44>
  14bc9c:	1145c83a 	sub	r2,r2,r5
  14bca0:	20c8b03a 	or	r4,r4,r3
  14bca4:	1806d07a 	srli	r3,r3,1
  14bca8:	280ad07a 	srli	r5,r5,1
  14bcac:	183ffa1e 	bne	r3,zero,14bc98 <udivmodsi4+0x38>
  14bcb0:	3000021e 	bne	r6,zero,14bcbc <udivmodsi4+0x5c>
  14bcb4:	2005883a 	mov	r2,r4
  14bcb8:	f800283a 	ret
  14bcbc:	f800283a 	ret
  14bcc0:	0009883a 	mov	r4,zero
  14bcc4:	003ffa06 	br	14bcb0 <udivmodsi4+0x50>
  14bcc8:	00c00044 	movi	r3,1
  14bccc:	0009883a 	mov	r4,zero
  14bcd0:	003ff106 	br	14bc98 <udivmodsi4+0x38>

0014bcd4 <__divsi3>:
  14bcd4:	defffe04 	addi	sp,sp,-8
  14bcd8:	dfc00115 	stw	ra,4(sp)
  14bcdc:	dc000015 	stw	r16,0(sp)
  14bce0:	20000a16 	blt	r4,zero,14bd0c <__divsi3+0x38>
  14bce4:	0021883a 	mov	r16,zero
  14bce8:	28000b16 	blt	r5,zero,14bd18 <__divsi3+0x44>
  14bcec:	000d883a 	mov	r6,zero
  14bcf0:	014bc600 	call	14bc60 <udivmodsi4>
  14bcf4:	80000126 	beq	r16,zero,14bcfc <__divsi3+0x28>
  14bcf8:	0085c83a 	sub	r2,zero,r2
  14bcfc:	dfc00117 	ldw	ra,4(sp)
  14bd00:	dc000017 	ldw	r16,0(sp)
  14bd04:	dec00204 	addi	sp,sp,8
  14bd08:	f800283a 	ret
  14bd0c:	0109c83a 	sub	r4,zero,r4
  14bd10:	04000044 	movi	r16,1
  14bd14:	283ff50e 	bge	r5,zero,14bcec <__divsi3+0x18>
  14bd18:	014bc83a 	sub	r5,zero,r5
  14bd1c:	8400005c 	xori	r16,r16,1
  14bd20:	003ff206 	br	14bcec <__divsi3+0x18>

0014bd24 <__modsi3>:
  14bd24:	deffff04 	addi	sp,sp,-4
  14bd28:	dfc00015 	stw	ra,0(sp)
  14bd2c:	20000516 	blt	r4,zero,14bd44 <__modsi3+0x20>
  14bd30:	28000c16 	blt	r5,zero,14bd64 <__modsi3+0x40>
  14bd34:	01800044 	movi	r6,1
  14bd38:	dfc00017 	ldw	ra,0(sp)
  14bd3c:	dec00104 	addi	sp,sp,4
  14bd40:	014bc601 	jmpi	14bc60 <udivmodsi4>
  14bd44:	0109c83a 	sub	r4,zero,r4
  14bd48:	28000b16 	blt	r5,zero,14bd78 <__modsi3+0x54>
  14bd4c:	01800044 	movi	r6,1
  14bd50:	014bc600 	call	14bc60 <udivmodsi4>
  14bd54:	0085c83a 	sub	r2,zero,r2
  14bd58:	dfc00017 	ldw	ra,0(sp)
  14bd5c:	dec00104 	addi	sp,sp,4
  14bd60:	f800283a 	ret
  14bd64:	014bc83a 	sub	r5,zero,r5
  14bd68:	01800044 	movi	r6,1
  14bd6c:	dfc00017 	ldw	ra,0(sp)
  14bd70:	dec00104 	addi	sp,sp,4
  14bd74:	014bc601 	jmpi	14bc60 <udivmodsi4>
  14bd78:	014bc83a 	sub	r5,zero,r5
  14bd7c:	003ff306 	br	14bd4c <__modsi3+0x28>

0014bd80 <__udivsi3>:
  14bd80:	000d883a 	mov	r6,zero
  14bd84:	014bc601 	jmpi	14bc60 <udivmodsi4>

0014bd88 <__umodsi3>:
  14bd88:	01800044 	movi	r6,1
  14bd8c:	014bc601 	jmpi	14bc60 <udivmodsi4>

0014bd90 <__mulsi3>:
  14bd90:	0005883a 	mov	r2,zero
  14bd94:	20000726 	beq	r4,zero,14bdb4 <__mulsi3+0x24>
  14bd98:	20c0004c 	andi	r3,r4,1
  14bd9c:	2008d07a 	srli	r4,r4,1
  14bda0:	18000126 	beq	r3,zero,14bda8 <__mulsi3+0x18>
  14bda4:	1145883a 	add	r2,r2,r5
  14bda8:	294b883a 	add	r5,r5,r5
  14bdac:	203ffa1e 	bne	r4,zero,14bd98 <__mulsi3+0x8>
  14bdb0:	f800283a 	ret
  14bdb4:	f800283a 	ret

0014bdb8 <memcpy>:
  14bdb8:	defffb04 	addi	sp,sp,-20
  14bdbc:	dc000015 	stw	r16,0(sp)
  14bdc0:	dfc00415 	stw	ra,16(sp)
  14bdc4:	dcc00315 	stw	r19,12(sp)
  14bdc8:	dc800215 	stw	r18,8(sp)
  14bdcc:	dc400115 	stw	r17,4(sp)
  14bdd0:	00c003c4 	movi	r3,15
  14bdd4:	2021883a 	mov	r16,r4
  14bdd8:	3005883a 	mov	r2,r6
  14bddc:	1980032e 	bgeu	r3,r6,14bdec <memcpy+0x34>
  14bde0:	2906b03a 	or	r3,r5,r4
  14bde4:	18c000cc 	andi	r3,r3,3
  14bde8:	18001026 	beq	r3,zero,14be2c <memcpy+0x74>
  14bdec:	8007883a 	mov	r3,r16
  14bdf0:	288f883a 	add	r7,r5,r2
  14bdf4:	10000526 	beq	r2,zero,14be0c <memcpy+0x54>
  14bdf8:	29800003 	ldbu	r6,0(r5)
  14bdfc:	18c00044 	addi	r3,r3,1
  14be00:	29400044 	addi	r5,r5,1
  14be04:	19bfffc5 	stb	r6,-1(r3)
  14be08:	29fffb1e 	bne	r5,r7,14bdf8 <memcpy+0x40>
  14be0c:	8005883a 	mov	r2,r16
  14be10:	dfc00417 	ldw	ra,16(sp)
  14be14:	dcc00317 	ldw	r19,12(sp)
  14be18:	dc800217 	ldw	r18,8(sp)
  14be1c:	dc400117 	ldw	r17,4(sp)
  14be20:	dc000017 	ldw	r16,0(sp)
  14be24:	dec00504 	addi	sp,sp,20
  14be28:	f800283a 	ret
  14be2c:	32bffc04 	addi	r10,r6,-16
  14be30:	5014d13a 	srli	r10,r10,4
  14be34:	20800404 	addi	r2,r4,16
  14be38:	2007883a 	mov	r3,r4
  14be3c:	5008913a 	slli	r4,r10,4
  14be40:	280f883a 	mov	r7,r5
  14be44:	1105883a 	add	r2,r2,r4
  14be48:	3a000017 	ldw	r8,0(r7)
  14be4c:	18c00404 	addi	r3,r3,16
  14be50:	39c00404 	addi	r7,r7,16
  14be54:	1a3ffc15 	stw	r8,-16(r3)
  14be58:	3a3ffd17 	ldw	r8,-12(r7)
  14be5c:	1a3ffd15 	stw	r8,-12(r3)
  14be60:	3a3ffe17 	ldw	r8,-8(r7)
  14be64:	1a3ffe15 	stw	r8,-8(r3)
  14be68:	3a3fff17 	ldw	r8,-4(r7)
  14be6c:	1a3fff15 	stw	r8,-4(r3)
  14be70:	18bff51e 	bne	r3,r2,14be48 <memcpy+0x90>
  14be74:	52800044 	addi	r10,r10,1
  14be78:	5014913a 	slli	r10,r10,4
  14be7c:	308003cc 	andi	r2,r6,15
  14be80:	010000c4 	movi	r4,3
  14be84:	8287883a 	add	r3,r16,r10
  14be88:	2a95883a 	add	r10,r5,r10
  14be8c:	2080182e 	bgeu	r4,r2,14bef0 <memcpy+0x138>
  14be90:	147fff04 	addi	r17,r2,-4
  14be94:	8808d0ba 	srli	r4,r17,2
  14be98:	1a400104 	addi	r9,r3,4
  14be9c:	180d883a 	mov	r6,r3
  14bea0:	2105883a 	add	r2,r4,r4
  14bea4:	1085883a 	add	r2,r2,r2
  14bea8:	4893883a 	add	r9,r9,r2
  14beac:	500f883a 	mov	r7,r10
  14beb0:	3a000017 	ldw	r8,0(r7)
  14beb4:	31800104 	addi	r6,r6,4
  14beb8:	39c00104 	addi	r7,r7,4
  14bebc:	323fff15 	stw	r8,-4(r6)
  14bec0:	327ffb1e 	bne	r6,r9,14beb0 <memcpy+0xf8>
  14bec4:	20800044 	addi	r2,r4,1
  14bec8:	1085883a 	add	r2,r2,r2
  14becc:	1085883a 	add	r2,r2,r2
  14bed0:	017fff04 	movi	r5,-4
  14bed4:	18a5883a 	add	r18,r3,r2
  14bed8:	50a7883a 	add	r19,r10,r2
  14bedc:	014bd900 	call	14bd90 <__mulsi3>
  14bee0:	1445883a 	add	r2,r2,r17
  14bee4:	980b883a 	mov	r5,r19
  14bee8:	9007883a 	mov	r3,r18
  14beec:	003fc006 	br	14bdf0 <memcpy+0x38>
  14bef0:	500b883a 	mov	r5,r10
  14bef4:	003fbe06 	br	14bdf0 <memcpy+0x38>

0014bef8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  14bef8:	defff904 	addi	sp,sp,-28
  14befc:	dfc00615 	stw	ra,24(sp)
  14bf00:	df000515 	stw	fp,20(sp)
  14bf04:	df000504 	addi	fp,sp,20
  14bf08:	e13ffc15 	stw	r4,-16(fp)
  14bf0c:	e17ffd15 	stw	r5,-12(fp)
  14bf10:	e1bffe15 	stw	r6,-8(fp)
  14bf14:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  14bf18:	e0800217 	ldw	r2,8(fp)
  14bf1c:	d8800015 	stw	r2,0(sp)
  14bf20:	e13ffc17 	ldw	r4,-16(fp)
  14bf24:	e17ffd17 	ldw	r5,-12(fp)
  14bf28:	e1bffe17 	ldw	r6,-8(fp)
  14bf2c:	e1ffff17 	ldw	r7,-4(fp)
  14bf30:	014c0d00 	call	14c0d0 <alt_iic_isr_register>
}  
  14bf34:	e037883a 	mov	sp,fp
  14bf38:	dfc00117 	ldw	ra,4(sp)
  14bf3c:	df000017 	ldw	fp,0(sp)
  14bf40:	dec00204 	addi	sp,sp,8
  14bf44:	f800283a 	ret

0014bf48 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  14bf48:	defff904 	addi	sp,sp,-28
  14bf4c:	df000615 	stw	fp,24(sp)
  14bf50:	df000604 	addi	fp,sp,24
  14bf54:	e13ffe15 	stw	r4,-8(fp)
  14bf58:	e17fff15 	stw	r5,-4(fp)
  14bf5c:	e0bfff17 	ldw	r2,-4(fp)
  14bf60:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  14bf64:	0005303a 	rdctl	r2,status
  14bf68:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  14bf6c:	e0fffb17 	ldw	r3,-20(fp)
  14bf70:	00bfff84 	movi	r2,-2
  14bf74:	1884703a 	and	r2,r3,r2
  14bf78:	1001703a 	wrctl	status,r2
  
  return context;
  14bf7c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  14bf80:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  14bf84:	e0bffa17 	ldw	r2,-24(fp)
  14bf88:	00c00044 	movi	r3,1
  14bf8c:	1884983a 	sll	r2,r3,r2
  14bf90:	1007883a 	mov	r3,r2
  14bf94:	00800574 	movhi	r2,21
  14bf98:	10b92804 	addi	r2,r2,-7008
  14bf9c:	10800017 	ldw	r2,0(r2)
  14bfa0:	1886b03a 	or	r3,r3,r2
  14bfa4:	00800574 	movhi	r2,21
  14bfa8:	10b92804 	addi	r2,r2,-7008
  14bfac:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  14bfb0:	00800574 	movhi	r2,21
  14bfb4:	10b92804 	addi	r2,r2,-7008
  14bfb8:	10800017 	ldw	r2,0(r2)
  14bfbc:	100170fa 	wrctl	ienable,r2
  14bfc0:	e0bffc17 	ldw	r2,-16(fp)
  14bfc4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  14bfc8:	e0bffd17 	ldw	r2,-12(fp)
  14bfcc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  14bfd0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  14bfd4:	e037883a 	mov	sp,fp
  14bfd8:	df000017 	ldw	fp,0(sp)
  14bfdc:	dec00104 	addi	sp,sp,4
  14bfe0:	f800283a 	ret

0014bfe4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  14bfe4:	defff904 	addi	sp,sp,-28
  14bfe8:	df000615 	stw	fp,24(sp)
  14bfec:	df000604 	addi	fp,sp,24
  14bff0:	e13ffe15 	stw	r4,-8(fp)
  14bff4:	e17fff15 	stw	r5,-4(fp)
  14bff8:	e0bfff17 	ldw	r2,-4(fp)
  14bffc:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  14c000:	0005303a 	rdctl	r2,status
  14c004:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  14c008:	e0fffb17 	ldw	r3,-20(fp)
  14c00c:	00bfff84 	movi	r2,-2
  14c010:	1884703a 	and	r2,r3,r2
  14c014:	1001703a 	wrctl	status,r2
  
  return context;
  14c018:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  14c01c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  14c020:	e0bffa17 	ldw	r2,-24(fp)
  14c024:	00c00044 	movi	r3,1
  14c028:	1884983a 	sll	r2,r3,r2
  14c02c:	0084303a 	nor	r2,zero,r2
  14c030:	1007883a 	mov	r3,r2
  14c034:	00800574 	movhi	r2,21
  14c038:	10b92804 	addi	r2,r2,-7008
  14c03c:	10800017 	ldw	r2,0(r2)
  14c040:	1886703a 	and	r3,r3,r2
  14c044:	00800574 	movhi	r2,21
  14c048:	10b92804 	addi	r2,r2,-7008
  14c04c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  14c050:	00800574 	movhi	r2,21
  14c054:	10b92804 	addi	r2,r2,-7008
  14c058:	10800017 	ldw	r2,0(r2)
  14c05c:	100170fa 	wrctl	ienable,r2
  14c060:	e0bffc17 	ldw	r2,-16(fp)
  14c064:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  14c068:	e0bffd17 	ldw	r2,-12(fp)
  14c06c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  14c070:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  14c074:	e037883a 	mov	sp,fp
  14c078:	df000017 	ldw	fp,0(sp)
  14c07c:	dec00104 	addi	sp,sp,4
  14c080:	f800283a 	ret

0014c084 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  14c084:	defffc04 	addi	sp,sp,-16
  14c088:	df000315 	stw	fp,12(sp)
  14c08c:	df000304 	addi	fp,sp,12
  14c090:	e13ffe15 	stw	r4,-8(fp)
  14c094:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  14c098:	000530fa 	rdctl	r2,ienable
  14c09c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  14c0a0:	e0bfff17 	ldw	r2,-4(fp)
  14c0a4:	00c00044 	movi	r3,1
  14c0a8:	1884983a 	sll	r2,r3,r2
  14c0ac:	1007883a 	mov	r3,r2
  14c0b0:	e0bffd17 	ldw	r2,-12(fp)
  14c0b4:	1884703a 	and	r2,r3,r2
  14c0b8:	1004c03a 	cmpne	r2,r2,zero
  14c0bc:	10803fcc 	andi	r2,r2,255
}
  14c0c0:	e037883a 	mov	sp,fp
  14c0c4:	df000017 	ldw	fp,0(sp)
  14c0c8:	dec00104 	addi	sp,sp,4
  14c0cc:	f800283a 	ret

0014c0d0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  14c0d0:	defff504 	addi	sp,sp,-44
  14c0d4:	dfc00a15 	stw	ra,40(sp)
  14c0d8:	df000915 	stw	fp,36(sp)
  14c0dc:	df000904 	addi	fp,sp,36
  14c0e0:	e13ffc15 	stw	r4,-16(fp)
  14c0e4:	e17ffd15 	stw	r5,-12(fp)
  14c0e8:	e1bffe15 	stw	r6,-8(fp)
  14c0ec:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  14c0f0:	00bffa84 	movi	r2,-22
  14c0f4:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  14c0f8:	e0bffd17 	ldw	r2,-12(fp)
  14c0fc:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  14c100:	e0bff817 	ldw	r2,-32(fp)
  14c104:	10800808 	cmpgei	r2,r2,32
  14c108:	1000271e 	bne	r2,zero,14c1a8 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  14c10c:	0005303a 	rdctl	r2,status
  14c110:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  14c114:	e0fffa17 	ldw	r3,-24(fp)
  14c118:	00bfff84 	movi	r2,-2
  14c11c:	1884703a 	and	r2,r3,r2
  14c120:	1001703a 	wrctl	status,r2
  
  return context;
  14c124:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  14c128:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  14c12c:	00c00574 	movhi	r3,21
  14c130:	18faba04 	addi	r3,r3,-5400
  14c134:	e0bff817 	ldw	r2,-32(fp)
  14c138:	100490fa 	slli	r2,r2,3
  14c13c:	1885883a 	add	r2,r3,r2
  14c140:	e0fffe17 	ldw	r3,-8(fp)
  14c144:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  14c148:	00c00574 	movhi	r3,21
  14c14c:	18faba04 	addi	r3,r3,-5400
  14c150:	e0bff817 	ldw	r2,-32(fp)
  14c154:	100490fa 	slli	r2,r2,3
  14c158:	1885883a 	add	r2,r3,r2
  14c15c:	10800104 	addi	r2,r2,4
  14c160:	e0ffff17 	ldw	r3,-4(fp)
  14c164:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  14c168:	e0bffe17 	ldw	r2,-8(fp)
  14c16c:	10000526 	beq	r2,zero,14c184 <alt_iic_isr_register+0xb4>
  14c170:	e0bff817 	ldw	r2,-32(fp)
  14c174:	e13ffc17 	ldw	r4,-16(fp)
  14c178:	100b883a 	mov	r5,r2
  14c17c:	014bf480 	call	14bf48 <alt_ic_irq_enable>
  14c180:	00000406 	br	14c194 <alt_iic_isr_register+0xc4>
  14c184:	e0bff817 	ldw	r2,-32(fp)
  14c188:	e13ffc17 	ldw	r4,-16(fp)
  14c18c:	100b883a 	mov	r5,r2
  14c190:	014bfe40 	call	14bfe4 <alt_ic_irq_disable>
  14c194:	e0bff715 	stw	r2,-36(fp)
  14c198:	e0bff917 	ldw	r2,-28(fp)
  14c19c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  14c1a0:	e0bffb17 	ldw	r2,-20(fp)
  14c1a4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  14c1a8:	e0bff717 	ldw	r2,-36(fp)
}
  14c1ac:	e037883a 	mov	sp,fp
  14c1b0:	dfc00117 	ldw	ra,4(sp)
  14c1b4:	df000017 	ldw	fp,0(sp)
  14c1b8:	dec00204 	addi	sp,sp,8
  14c1bc:	f800283a 	ret

0014c1c0 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  14c1c0:	defffc04 	addi	sp,sp,-16
  14c1c4:	df000315 	stw	fp,12(sp)
  14c1c8:	df000304 	addi	fp,sp,12
  14c1cc:	e13ffd15 	stw	r4,-12(fp)
  14c1d0:	e17ffe15 	stw	r5,-8(fp)
  14c1d4:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  14c1d8:	e0fffe17 	ldw	r3,-8(fp)
  14c1dc:	e0bffd17 	ldw	r2,-12(fp)
  14c1e0:	18800e26 	beq	r3,r2,14c21c <alt_load_section+0x5c>
  {
    while( to != end )
  14c1e4:	00000a06 	br	14c210 <alt_load_section+0x50>
    {
      *to++ = *from++;
  14c1e8:	e0bffd17 	ldw	r2,-12(fp)
  14c1ec:	10c00017 	ldw	r3,0(r2)
  14c1f0:	e0bffe17 	ldw	r2,-8(fp)
  14c1f4:	10c00015 	stw	r3,0(r2)
  14c1f8:	e0bffe17 	ldw	r2,-8(fp)
  14c1fc:	10800104 	addi	r2,r2,4
  14c200:	e0bffe15 	stw	r2,-8(fp)
  14c204:	e0bffd17 	ldw	r2,-12(fp)
  14c208:	10800104 	addi	r2,r2,4
  14c20c:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  14c210:	e0fffe17 	ldw	r3,-8(fp)
  14c214:	e0bfff17 	ldw	r2,-4(fp)
  14c218:	18bff31e 	bne	r3,r2,14c1e8 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  14c21c:	e037883a 	mov	sp,fp
  14c220:	df000017 	ldw	fp,0(sp)
  14c224:	dec00104 	addi	sp,sp,4
  14c228:	f800283a 	ret

0014c22c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  14c22c:	defffe04 	addi	sp,sp,-8
  14c230:	dfc00115 	stw	ra,4(sp)
  14c234:	df000015 	stw	fp,0(sp)
  14c238:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  14c23c:	01000574 	movhi	r4,21
  14c240:	2136ab04 	addi	r4,r4,-9556
  14c244:	01400574 	movhi	r5,21
  14c248:	29743e04 	addi	r5,r5,-12040
  14c24c:	01800574 	movhi	r6,21
  14c250:	31b6ab04 	addi	r6,r6,-9556
  14c254:	014c1c00 	call	14c1c0 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  14c258:	01000574 	movhi	r4,21
  14c25c:	21200804 	addi	r4,r4,-32736
  14c260:	01400574 	movhi	r5,21
  14c264:	29600804 	addi	r5,r5,-32736
  14c268:	01800574 	movhi	r6,21
  14c26c:	31a06e04 	addi	r6,r6,-32328
  14c270:	014c1c00 	call	14c1c0 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  14c274:	01000574 	movhi	r4,21
  14c278:	21326304 	addi	r4,r4,-13940
  14c27c:	01400574 	movhi	r5,21
  14c280:	29726304 	addi	r5,r5,-13940
  14c284:	01800574 	movhi	r6,21
  14c288:	31b43e04 	addi	r6,r6,-12040
  14c28c:	014c1c00 	call	14c1c0 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  14c290:	014c4780 	call	14c478 <alt_dcache_flush_all>
  alt_icache_flush_all();
  14c294:	014c5780 	call	14c578 <alt_icache_flush_all>
}
  14c298:	e037883a 	mov	sp,fp
  14c29c:	dfc00117 	ldw	ra,4(sp)
  14c2a0:	df000017 	ldw	fp,0(sp)
  14c2a4:	dec00204 	addi	sp,sp,8
  14c2a8:	f800283a 	ret

0014c2ac <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  14c2ac:	defffd04 	addi	sp,sp,-12
  14c2b0:	dfc00215 	stw	ra,8(sp)
  14c2b4:	df000115 	stw	fp,4(sp)
  14c2b8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  14c2bc:	0009883a 	mov	r4,zero
  14c2c0:	014c3080 	call	14c308 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  14c2c4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  14c2c8:	014c33c0 	call	14c33c <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  14c2cc:	014c4c00 	call	14c4c0 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  14c2d0:	01000574 	movhi	r4,21
  14c2d4:	21314704 	addi	r4,r4,-15076
  14c2d8:	014c6340 	call	14c634 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  14c2dc:	d1228717 	ldw	r4,-30180(gp)
  14c2e0:	d0e28817 	ldw	r3,-30176(gp)
  14c2e4:	d0a28917 	ldw	r2,-30172(gp)
  14c2e8:	180b883a 	mov	r5,r3
  14c2ec:	100d883a 	mov	r6,r2
  14c2f0:	01487380 	call	148738 <main>
  14c2f4:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  14c2f8:	01000044 	movi	r4,1
  14c2fc:	014c3ac0 	call	14c3ac <close>
  exit (result);
  14c300:	e13fff17 	ldw	r4,-4(fp)
  14c304:	014c6480 	call	14c648 <exit>

0014c308 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  14c308:	defffd04 	addi	sp,sp,-12
  14c30c:	dfc00215 	stw	ra,8(sp)
  14c310:	df000115 	stw	fp,4(sp)
  14c314:	df000104 	addi	fp,sp,4
  14c318:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( PROC, PROC);
  14c31c:	014c6140 	call	14c614 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  14c320:	00800044 	movi	r2,1
  14c324:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  14c328:	e037883a 	mov	sp,fp
  14c32c:	dfc00117 	ldw	ra,4(sp)
  14c330:	df000017 	ldw	fp,0(sp)
  14c334:	dec00204 	addi	sp,sp,8
  14c338:	f800283a 	ret

0014c33c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  14c33c:	deffff04 	addi	sp,sp,-4
  14c340:	df000015 	stw	fp,0(sp)
  14c344:	d839883a 	mov	fp,sp
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
  14c348:	0001883a 	nop
}
  14c34c:	e037883a 	mov	sp,fp
  14c350:	df000017 	ldw	fp,0(sp)
  14c354:	dec00104 	addi	sp,sp,4
  14c358:	f800283a 	ret

0014c35c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  14c35c:	defffe04 	addi	sp,sp,-8
  14c360:	dfc00115 	stw	ra,4(sp)
  14c364:	df000015 	stw	fp,0(sp)
  14c368:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  14c36c:	00800574 	movhi	r2,21
  14c370:	10b6a804 	addi	r2,r2,-9568
  14c374:	10800017 	ldw	r2,0(r2)
  14c378:	10000526 	beq	r2,zero,14c390 <alt_get_errno+0x34>
  14c37c:	00800574 	movhi	r2,21
  14c380:	10b6a804 	addi	r2,r2,-9568
  14c384:	10800017 	ldw	r2,0(r2)
  14c388:	103ee83a 	callr	r2
  14c38c:	00000206 	br	14c398 <alt_get_errno+0x3c>
  14c390:	00800574 	movhi	r2,21
  14c394:	10b92c04 	addi	r2,r2,-6992
}
  14c398:	e037883a 	mov	sp,fp
  14c39c:	dfc00117 	ldw	ra,4(sp)
  14c3a0:	df000017 	ldw	fp,0(sp)
  14c3a4:	dec00204 	addi	sp,sp,8
  14c3a8:	f800283a 	ret

0014c3ac <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  14c3ac:	defffb04 	addi	sp,sp,-20
  14c3b0:	dfc00415 	stw	ra,16(sp)
  14c3b4:	df000315 	stw	fp,12(sp)
  14c3b8:	df000304 	addi	fp,sp,12
  14c3bc:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  14c3c0:	e0bfff17 	ldw	r2,-4(fp)
  14c3c4:	10000716 	blt	r2,zero,14c3e4 <close+0x38>
  14c3c8:	e13fff17 	ldw	r4,-4(fp)
  14c3cc:	01400304 	movi	r5,12
  14c3d0:	014bd900 	call	14bd90 <__mulsi3>
  14c3d4:	00c00574 	movhi	r3,21
  14c3d8:	18f54204 	addi	r3,r3,-11000
  14c3dc:	10c5883a 	add	r2,r2,r3
  14c3e0:	00000106 	br	14c3e8 <close+0x3c>
  14c3e4:	0005883a 	mov	r2,zero
  14c3e8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  14c3ec:	e0bffd17 	ldw	r2,-12(fp)
  14c3f0:	10001826 	beq	r2,zero,14c454 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  14c3f4:	e0bffd17 	ldw	r2,-12(fp)
  14c3f8:	10800017 	ldw	r2,0(r2)
  14c3fc:	10800417 	ldw	r2,16(r2)
  14c400:	10000626 	beq	r2,zero,14c41c <close+0x70>
  14c404:	e0bffd17 	ldw	r2,-12(fp)
  14c408:	10800017 	ldw	r2,0(r2)
  14c40c:	10800417 	ldw	r2,16(r2)
  14c410:	e13ffd17 	ldw	r4,-12(fp)
  14c414:	103ee83a 	callr	r2
  14c418:	00000106 	br	14c420 <close+0x74>
  14c41c:	0005883a 	mov	r2,zero
  14c420:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  14c424:	e13fff17 	ldw	r4,-4(fp)
  14c428:	014c5940 	call	14c594 <alt_release_fd>
    if (rval < 0)
  14c42c:	e0bffe17 	ldw	r2,-8(fp)
  14c430:	1000060e 	bge	r2,zero,14c44c <close+0xa0>
    {
      ALT_ERRNO = -rval;
  14c434:	014c35c0 	call	14c35c <alt_get_errno>
  14c438:	e0fffe17 	ldw	r3,-8(fp)
  14c43c:	00c7c83a 	sub	r3,zero,r3
  14c440:	10c00015 	stw	r3,0(r2)
      return -1;
  14c444:	00bfffc4 	movi	r2,-1
  14c448:	00000606 	br	14c464 <close+0xb8>
    }
    return 0;
  14c44c:	0005883a 	mov	r2,zero
  14c450:	00000406 	br	14c464 <close+0xb8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  14c454:	014c35c0 	call	14c35c <alt_get_errno>
  14c458:	00c01444 	movi	r3,81
  14c45c:	10c00015 	stw	r3,0(r2)
    return -1;
  14c460:	00bfffc4 	movi	r2,-1
  }
}
  14c464:	e037883a 	mov	sp,fp
  14c468:	dfc00117 	ldw	ra,4(sp)
  14c46c:	df000017 	ldw	fp,0(sp)
  14c470:	dec00204 	addi	sp,sp,8
  14c474:	f800283a 	ret

0014c478 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  14c478:	deffff04 	addi	sp,sp,-4
  14c47c:	df000015 	stw	fp,0(sp)
  14c480:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  14c484:	e037883a 	mov	sp,fp
  14c488:	df000017 	ldw	fp,0(sp)
  14c48c:	dec00104 	addi	sp,sp,4
  14c490:	f800283a 	ret

0014c494 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  14c494:	defffc04 	addi	sp,sp,-16
  14c498:	df000315 	stw	fp,12(sp)
  14c49c:	df000304 	addi	fp,sp,12
  14c4a0:	e13ffd15 	stw	r4,-12(fp)
  14c4a4:	e17ffe15 	stw	r5,-8(fp)
  14c4a8:	e1bfff15 	stw	r6,-4(fp)
  return len;
  14c4ac:	e0bfff17 	ldw	r2,-4(fp)
}
  14c4b0:	e037883a 	mov	sp,fp
  14c4b4:	df000017 	ldw	fp,0(sp)
  14c4b8:	dec00104 	addi	sp,sp,4
  14c4bc:	f800283a 	ret

0014c4c0 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  14c4c0:	defffd04 	addi	sp,sp,-12
  14c4c4:	dfc00215 	stw	ra,8(sp)
  14c4c8:	df000115 	stw	fp,4(sp)
  14c4cc:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  14c4d0:	00800574 	movhi	r2,21
  14c4d4:	10b26204 	addi	r2,r2,-13944
  14c4d8:	e0bfff15 	stw	r2,-4(fp)
  14c4dc:	00000606 	br	14c4f8 <_do_ctors+0x38>
        (*ctor) (); 
  14c4e0:	e0bfff17 	ldw	r2,-4(fp)
  14c4e4:	10800017 	ldw	r2,0(r2)
  14c4e8:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  14c4ec:	e0bfff17 	ldw	r2,-4(fp)
  14c4f0:	10bfff04 	addi	r2,r2,-4
  14c4f4:	e0bfff15 	stw	r2,-4(fp)
  14c4f8:	e0ffff17 	ldw	r3,-4(fp)
  14c4fc:	00800574 	movhi	r2,21
  14c500:	10b26304 	addi	r2,r2,-13940
  14c504:	18bff62e 	bgeu	r3,r2,14c4e0 <_do_ctors+0x20>
        (*ctor) (); 
}
  14c508:	e037883a 	mov	sp,fp
  14c50c:	dfc00117 	ldw	ra,4(sp)
  14c510:	df000017 	ldw	fp,0(sp)
  14c514:	dec00204 	addi	sp,sp,8
  14c518:	f800283a 	ret

0014c51c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  14c51c:	defffd04 	addi	sp,sp,-12
  14c520:	dfc00215 	stw	ra,8(sp)
  14c524:	df000115 	stw	fp,4(sp)
  14c528:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  14c52c:	00800574 	movhi	r2,21
  14c530:	10b26204 	addi	r2,r2,-13944
  14c534:	e0bfff15 	stw	r2,-4(fp)
  14c538:	00000606 	br	14c554 <_do_dtors+0x38>
        (*dtor) (); 
  14c53c:	e0bfff17 	ldw	r2,-4(fp)
  14c540:	10800017 	ldw	r2,0(r2)
  14c544:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  14c548:	e0bfff17 	ldw	r2,-4(fp)
  14c54c:	10bfff04 	addi	r2,r2,-4
  14c550:	e0bfff15 	stw	r2,-4(fp)
  14c554:	e0ffff17 	ldw	r3,-4(fp)
  14c558:	00800574 	movhi	r2,21
  14c55c:	10b26304 	addi	r2,r2,-13940
  14c560:	18bff62e 	bgeu	r3,r2,14c53c <_do_dtors+0x20>
        (*dtor) (); 
}
  14c564:	e037883a 	mov	sp,fp
  14c568:	dfc00117 	ldw	ra,4(sp)
  14c56c:	df000017 	ldw	fp,0(sp)
  14c570:	dec00204 	addi	sp,sp,8
  14c574:	f800283a 	ret

0014c578 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  14c578:	deffff04 	addi	sp,sp,-4
  14c57c:	df000015 	stw	fp,0(sp)
  14c580:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  14c584:	e037883a 	mov	sp,fp
  14c588:	df000017 	ldw	fp,0(sp)
  14c58c:	dec00104 	addi	sp,sp,4
  14c590:	f800283a 	ret

0014c594 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  14c594:	defffc04 	addi	sp,sp,-16
  14c598:	dfc00315 	stw	ra,12(sp)
  14c59c:	df000215 	stw	fp,8(sp)
  14c5a0:	dc000115 	stw	r16,4(sp)
  14c5a4:	df000104 	addi	fp,sp,4
  14c5a8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  14c5ac:	e0bfff17 	ldw	r2,-4(fp)
  14c5b0:	108000d0 	cmplti	r2,r2,3
  14c5b4:	1000111e 	bne	r2,zero,14c5fc <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  14c5b8:	04000574 	movhi	r16,21
  14c5bc:	84354204 	addi	r16,r16,-11000
  14c5c0:	e0bfff17 	ldw	r2,-4(fp)
  14c5c4:	1009883a 	mov	r4,r2
  14c5c8:	01400304 	movi	r5,12
  14c5cc:	014bd900 	call	14bd90 <__mulsi3>
  14c5d0:	8085883a 	add	r2,r16,r2
  14c5d4:	10800204 	addi	r2,r2,8
  14c5d8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  14c5dc:	04000574 	movhi	r16,21
  14c5e0:	84354204 	addi	r16,r16,-11000
  14c5e4:	e0bfff17 	ldw	r2,-4(fp)
  14c5e8:	1009883a 	mov	r4,r2
  14c5ec:	01400304 	movi	r5,12
  14c5f0:	014bd900 	call	14bd90 <__mulsi3>
  14c5f4:	8085883a 	add	r2,r16,r2
  14c5f8:	10000015 	stw	zero,0(r2)
  }
}
  14c5fc:	e037883a 	mov	sp,fp
  14c600:	dfc00217 	ldw	ra,8(sp)
  14c604:	df000117 	ldw	fp,4(sp)
  14c608:	dc000017 	ldw	r16,0(sp)
  14c60c:	dec00304 	addi	sp,sp,12
  14c610:	f800283a 	ret

0014c614 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  14c614:	deffff04 	addi	sp,sp,-4
  14c618:	df000015 	stw	fp,0(sp)
  14c61c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  14c620:	000170fa 	wrctl	ienable,zero
}
  14c624:	e037883a 	mov	sp,fp
  14c628:	df000017 	ldw	fp,0(sp)
  14c62c:	dec00104 	addi	sp,sp,4
  14c630:	f800283a 	ret

0014c634 <atexit>:
  14c634:	200b883a 	mov	r5,r4
  14c638:	000d883a 	mov	r6,zero
  14c63c:	0009883a 	mov	r4,zero
  14c640:	000f883a 	mov	r7,zero
  14c644:	014c6801 	jmpi	14c680 <__register_exitproc>

0014c648 <exit>:
  14c648:	defffe04 	addi	sp,sp,-8
  14c64c:	000b883a 	mov	r5,zero
  14c650:	dc000015 	stw	r16,0(sp)
  14c654:	dfc00115 	stw	ra,4(sp)
  14c658:	2021883a 	mov	r16,r4
  14c65c:	014c7b00 	call	14c7b0 <__call_exitprocs>
  14c660:	00800574 	movhi	r2,21
  14c664:	10b6a904 	addi	r2,r2,-9564
  14c668:	11000017 	ldw	r4,0(r2)
  14c66c:	20800f17 	ldw	r2,60(r4)
  14c670:	10000126 	beq	r2,zero,14c678 <exit+0x30>
  14c674:	103ee83a 	callr	r2
  14c678:	8009883a 	mov	r4,r16
  14c67c:	014c9500 	call	14c950 <_exit>

0014c680 <__register_exitproc>:
  14c680:	defffa04 	addi	sp,sp,-24
  14c684:	00800574 	movhi	r2,21
  14c688:	10b6a904 	addi	r2,r2,-9564
  14c68c:	dc000315 	stw	r16,12(sp)
  14c690:	14000017 	ldw	r16,0(r2)
  14c694:	dc400415 	stw	r17,16(sp)
  14c698:	dfc00515 	stw	ra,20(sp)
  14c69c:	80805217 	ldw	r2,328(r16)
  14c6a0:	2023883a 	mov	r17,r4
  14c6a4:	10003e26 	beq	r2,zero,14c7a0 <__register_exitproc+0x120>
  14c6a8:	10c00117 	ldw	r3,4(r2)
  14c6ac:	020007c4 	movi	r8,31
  14c6b0:	40c0180e 	bge	r8,r3,14c714 <__register_exitproc+0x94>
  14c6b4:	00800034 	movhi	r2,0
  14c6b8:	10800004 	addi	r2,r2,0
  14c6bc:	1000061e 	bne	r2,zero,14c6d8 <__register_exitproc+0x58>
  14c6c0:	00bfffc4 	movi	r2,-1
  14c6c4:	dfc00517 	ldw	ra,20(sp)
  14c6c8:	dc400417 	ldw	r17,16(sp)
  14c6cc:	dc000317 	ldw	r16,12(sp)
  14c6d0:	dec00604 	addi	sp,sp,24
  14c6d4:	f800283a 	ret
  14c6d8:	01006404 	movi	r4,400
  14c6dc:	d9400015 	stw	r5,0(sp)
  14c6e0:	d9800115 	stw	r6,4(sp)
  14c6e4:	d9c00215 	stw	r7,8(sp)
  14c6e8:	00000000 	call	0 <PIO_IRQ_MASK-0x8>
  14c6ec:	d9400017 	ldw	r5,0(sp)
  14c6f0:	d9800117 	ldw	r6,4(sp)
  14c6f4:	d9c00217 	ldw	r7,8(sp)
  14c6f8:	103ff126 	beq	r2,zero,14c6c0 <__register_exitproc+0x40>
  14c6fc:	80c05217 	ldw	r3,328(r16)
  14c700:	10000115 	stw	zero,4(r2)
  14c704:	10c00015 	stw	r3,0(r2)
  14c708:	80805215 	stw	r2,328(r16)
  14c70c:	10006215 	stw	zero,392(r2)
  14c710:	10006315 	stw	zero,396(r2)
  14c714:	10c00117 	ldw	r3,4(r2)
  14c718:	88000d1e 	bne	r17,zero,14c750 <__register_exitproc+0xd0>
  14c71c:	19000084 	addi	r4,r3,2
  14c720:	2109883a 	add	r4,r4,r4
  14c724:	18c00044 	addi	r3,r3,1
  14c728:	2109883a 	add	r4,r4,r4
  14c72c:	1109883a 	add	r4,r2,r4
  14c730:	10c00115 	stw	r3,4(r2)
  14c734:	0005883a 	mov	r2,zero
  14c738:	21400015 	stw	r5,0(r4)
  14c73c:	dfc00517 	ldw	ra,20(sp)
  14c740:	dc400417 	ldw	r17,16(sp)
  14c744:	dc000317 	ldw	r16,12(sp)
  14c748:	dec00604 	addi	sp,sp,24
  14c74c:	f800283a 	ret
  14c750:	02400044 	movi	r9,1
  14c754:	12806217 	ldw	r10,392(r2)
  14c758:	48d2983a 	sll	r9,r9,r3
  14c75c:	19000804 	addi	r4,r3,32
  14c760:	18d1883a 	add	r8,r3,r3
  14c764:	2109883a 	add	r4,r4,r4
  14c768:	4211883a 	add	r8,r8,r8
  14c76c:	2109883a 	add	r4,r4,r4
  14c770:	1109883a 	add	r4,r2,r4
  14c774:	1211883a 	add	r8,r2,r8
  14c778:	5254b03a 	or	r10,r10,r9
  14c77c:	21c02215 	stw	r7,136(r4)
  14c780:	41802215 	stw	r6,136(r8)
  14c784:	12806215 	stw	r10,392(r2)
  14c788:	01000084 	movi	r4,2
  14c78c:	893fe31e 	bne	r17,r4,14c71c <__register_exitproc+0x9c>
  14c790:	11006317 	ldw	r4,396(r2)
  14c794:	2252b03a 	or	r9,r4,r9
  14c798:	12406315 	stw	r9,396(r2)
  14c79c:	003fdf06 	br	14c71c <__register_exitproc+0x9c>
  14c7a0:	00800574 	movhi	r2,21
  14c7a4:	10bafa04 	addi	r2,r2,-5144
  14c7a8:	80805215 	stw	r2,328(r16)
  14c7ac:	003fbe06 	br	14c6a8 <__register_exitproc+0x28>

0014c7b0 <__call_exitprocs>:
  14c7b0:	00800574 	movhi	r2,21
  14c7b4:	10b6a904 	addi	r2,r2,-9564
  14c7b8:	10800017 	ldw	r2,0(r2)
  14c7bc:	defff304 	addi	sp,sp,-52
  14c7c0:	df000b15 	stw	fp,44(sp)
  14c7c4:	d8800015 	stw	r2,0(sp)
  14c7c8:	10805204 	addi	r2,r2,328
  14c7cc:	dd400815 	stw	r21,32(sp)
  14c7d0:	dfc00c15 	stw	ra,48(sp)
  14c7d4:	ddc00a15 	stw	r23,40(sp)
  14c7d8:	dd800915 	stw	r22,36(sp)
  14c7dc:	dd000715 	stw	r20,28(sp)
  14c7e0:	dcc00615 	stw	r19,24(sp)
  14c7e4:	dc800515 	stw	r18,20(sp)
  14c7e8:	dc400415 	stw	r17,16(sp)
  14c7ec:	dc000315 	stw	r16,12(sp)
  14c7f0:	d9000115 	stw	r4,4(sp)
  14c7f4:	2839883a 	mov	fp,r5
  14c7f8:	d8800215 	stw	r2,8(sp)
  14c7fc:	057fffc4 	movi	r21,-1
  14c800:	d8800017 	ldw	r2,0(sp)
  14c804:	ddc00217 	ldw	r23,8(sp)
  14c808:	14805217 	ldw	r18,328(r2)
  14c80c:	90001726 	beq	r18,zero,14c86c <__call_exitprocs+0xbc>
  14c810:	94400117 	ldw	r17,4(r18)
  14c814:	8c3fffc4 	addi	r16,r17,-1
  14c818:	80001116 	blt	r16,zero,14c860 <__call_exitprocs+0xb0>
  14c81c:	8c400044 	addi	r17,r17,1
  14c820:	8427883a 	add	r19,r16,r16
  14c824:	8c63883a 	add	r17,r17,r17
  14c828:	95802204 	addi	r22,r18,136
  14c82c:	9ce7883a 	add	r19,r19,r19
  14c830:	8c63883a 	add	r17,r17,r17
  14c834:	b4e7883a 	add	r19,r22,r19
  14c838:	9463883a 	add	r17,r18,r17
  14c83c:	e0001726 	beq	fp,zero,14c89c <__call_exitprocs+0xec>
  14c840:	8c87c83a 	sub	r3,r17,r18
  14c844:	b0c7883a 	add	r3,r22,r3
  14c848:	18c01e17 	ldw	r3,120(r3)
  14c84c:	1f001326 	beq	r3,fp,14c89c <__call_exitprocs+0xec>
  14c850:	843fffc4 	addi	r16,r16,-1
  14c854:	9cffff04 	addi	r19,r19,-4
  14c858:	8c7fff04 	addi	r17,r17,-4
  14c85c:	857ff71e 	bne	r16,r21,14c83c <__call_exitprocs+0x8c>
  14c860:	00800034 	movhi	r2,0
  14c864:	10800004 	addi	r2,r2,0
  14c868:	10002a1e 	bne	r2,zero,14c914 <__call_exitprocs+0x164>
  14c86c:	dfc00c17 	ldw	ra,48(sp)
  14c870:	df000b17 	ldw	fp,44(sp)
  14c874:	ddc00a17 	ldw	r23,40(sp)
  14c878:	dd800917 	ldw	r22,36(sp)
  14c87c:	dd400817 	ldw	r21,32(sp)
  14c880:	dd000717 	ldw	r20,28(sp)
  14c884:	dcc00617 	ldw	r19,24(sp)
  14c888:	dc800517 	ldw	r18,20(sp)
  14c88c:	dc400417 	ldw	r17,16(sp)
  14c890:	dc000317 	ldw	r16,12(sp)
  14c894:	dec00d04 	addi	sp,sp,52
  14c898:	f800283a 	ret
  14c89c:	91000117 	ldw	r4,4(r18)
  14c8a0:	88c00017 	ldw	r3,0(r17)
  14c8a4:	213fffc4 	addi	r4,r4,-1
  14c8a8:	24001526 	beq	r4,r16,14c900 <__call_exitprocs+0x150>
  14c8ac:	88000015 	stw	zero,0(r17)
  14c8b0:	183fe726 	beq	r3,zero,14c850 <__call_exitprocs+0xa0>
  14c8b4:	00800044 	movi	r2,1
  14c8b8:	1408983a 	sll	r4,r2,r16
  14c8bc:	91406217 	ldw	r5,392(r18)
  14c8c0:	95000117 	ldw	r20,4(r18)
  14c8c4:	214a703a 	and	r5,r4,r5
  14c8c8:	28000b26 	beq	r5,zero,14c8f8 <__call_exitprocs+0x148>
  14c8cc:	91406317 	ldw	r5,396(r18)
  14c8d0:	2148703a 	and	r4,r4,r5
  14c8d4:	20000c1e 	bne	r4,zero,14c908 <__call_exitprocs+0x158>
  14c8d8:	99400017 	ldw	r5,0(r19)
  14c8dc:	d9000117 	ldw	r4,4(sp)
  14c8e0:	183ee83a 	callr	r3
  14c8e4:	90c00117 	ldw	r3,4(r18)
  14c8e8:	1d3fc51e 	bne	r3,r20,14c800 <__call_exitprocs+0x50>
  14c8ec:	b8c00017 	ldw	r3,0(r23)
  14c8f0:	1cbfd726 	beq	r3,r18,14c850 <__call_exitprocs+0xa0>
  14c8f4:	003fc206 	br	14c800 <__call_exitprocs+0x50>
  14c8f8:	183ee83a 	callr	r3
  14c8fc:	003ff906 	br	14c8e4 <__call_exitprocs+0x134>
  14c900:	94000115 	stw	r16,4(r18)
  14c904:	003fea06 	br	14c8b0 <__call_exitprocs+0x100>
  14c908:	99000017 	ldw	r4,0(r19)
  14c90c:	183ee83a 	callr	r3
  14c910:	003ff406 	br	14c8e4 <__call_exitprocs+0x134>
  14c914:	90c00117 	ldw	r3,4(r18)
  14c918:	1800071e 	bne	r3,zero,14c938 <__call_exitprocs+0x188>
  14c91c:	90c00017 	ldw	r3,0(r18)
  14c920:	18000926 	beq	r3,zero,14c948 <__call_exitprocs+0x198>
  14c924:	9009883a 	mov	r4,r18
  14c928:	b8c00015 	stw	r3,0(r23)
  14c92c:	00000000 	call	0 <PIO_IRQ_MASK-0x8>
  14c930:	bc800017 	ldw	r18,0(r23)
  14c934:	003fb506 	br	14c80c <__call_exitprocs+0x5c>
  14c938:	90c00017 	ldw	r3,0(r18)
  14c93c:	902f883a 	mov	r23,r18
  14c940:	1825883a 	mov	r18,r3
  14c944:	003fb106 	br	14c80c <__call_exitprocs+0x5c>
  14c948:	0007883a 	mov	r3,zero
  14c94c:	003ffb06 	br	14c93c <__call_exitprocs+0x18c>

0014c950 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  14c950:	defffc04 	addi	sp,sp,-16
  14c954:	df000315 	stw	fp,12(sp)
  14c958:	df000304 	addi	fp,sp,12
  14c95c:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  14c960:	0001883a 	nop
  14c964:	e0bfff17 	ldw	r2,-4(fp)
  14c968:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
  14c96c:	e0bffd17 	ldw	r2,-12(fp)
  14c970:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  14c974:	e0bffe17 	ldw	r2,-8(fp)
  14c978:	10000226 	beq	r2,zero,14c984 <_exit+0x34>
    ALT_SIM_FAIL();
  14c97c:	002af070 	cmpltui	zero,zero,43969
  14c980:	00000106 	br	14c988 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
  14c984:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  14c988:	003fff06 	br	14c988 <_exit+0x38>
