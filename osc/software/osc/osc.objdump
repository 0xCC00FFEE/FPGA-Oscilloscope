
osc.elf:     file format elf32-littlenios2
osc.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x001501b8

Program Header:
    LOAD off    0x00001000 vaddr 0x00150000 paddr 0x00150000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00150020 paddr 0x00150020 align 2**12
         filesz 0x00006580 memsz 0x00006580 flags r-x
    LOAD off    0x000075a0 vaddr 0x001565a0 paddr 0x00157204 align 2**12
         filesz 0x00000c64 memsz 0x00000c64 flags rw-
    LOAD off    0x00008e68 vaddr 0x00157e68 paddr 0x00157e68 align 2**12
         filesz 0x00000000 memsz 0x00003618 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00150000  00150000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000198  00150020  00150020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00005c2c  001501b8  001501b8  000011b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000007bc  00155de4  00155de4  00006de4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000c64  001565a0  00157204  000075a0  2**4
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00003618  00157e68  00157e68  00008e68  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00008204  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000608  00000000  00000000  00008228  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00007c45  00000000  00000000  00008830  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000262d  00000000  00000000  00010475  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00002d42  00000000  00000000  00012aa2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000fe4  00000000  00000000  000157e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001c94  00000000  00000000  000167c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001b9e  00000000  00000000  0001845c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000020  00000000  00000000  00019ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000000d0  00000000  00000000  0001a020  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  0001d363  2**0
                  CONTENTS, READONLY
 17 .cpu          00000004  00000000  00000000  0001d366  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  0001d36a  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0001d36b  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  0001d36c  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  0001d370  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  0001d374  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000004  00000000  00000000  0001d378  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000004  00000000  00000000  0001d37c  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000004  00000000  00000000  0001d380  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000004  00000000  00000000  0001d384  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000000d  00000000  00000000  0001d388  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     0009623e  00000000  00000000  0001d395  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00150000 l    d  .entry	00000000 .entry
00150020 l    d  .exceptions	00000000 .exceptions
001501b8 l    d  .text	00000000 .text
00155de4 l    d  .rodata	00000000 .rodata
001565a0 l    d  .rwdata	00000000 .rwdata
00157e68 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../osc_bsp//obj/HAL/src/crt0.o
001501f0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00150094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 char57.c
00000000 l    df *ABS*	00000000 keyproc.c
00000000 l    df *ABS*	00000000 lcdout.c
00000000 l    df *ABS*	00000000 mainloop.c
00000000 l    df *ABS*	00000000 menu.c
00000000 l    df *ABS*	00000000 menuact.c
00000000 l    df *ABS*	00000000 stubfncs.c
00000000 l    df *ABS*	00000000 testcode.c
00000000 l    df *ABS*	00000000 tracutil.c
00000000 l    df *ABS*	00000000 obj/default/keyint.o
000fffff l       *ABS*	00000000 SWITCH_ALL
00000008 l       *ABS*	00000000 PIO_IRQ_MASK
0000000c l       *ABS*	00000000 PIO_EDGE_CAP
00000010 l       *ABS*	00000000 PIO_OUTSET
00000014 l       *ABS*	00000000 PIO_OUTCLR
001565b0 l       .rwdata	00000000 adc_speed
001565b6 l       .rwdata	00000000 trig_level
001565b4 l       .rwdata	00000000 trig_delay
00152fcc l     F .text	00000000 key_handler
00152fb4 l       .text	00000000 key_int_installer_done
001565a0 l       .rwdata	00000000 key_press
00153010 l       .text	00000000 loop_keys
00153024 l       .text	00000000 key_lookup
00153244 l       .text	00000000 key_map
001565a1 l       .rwdata	00000000 key_value
00153120 l       .text	00000000 call_action
001530e0 l       .text	00000000 key_lookup_cont
00153108 l       .text	00000000 key_handler_done
001531c8 l       .text	00000000 key_available_done
0015322c l       .text	00000000 getkey_done
00000000 l    df *ABS*	00000000 obj/default/testadc.o
000fffff l       *ABS*	00000000 SWITCH_ALL
00000008 l       *ABS*	00000000 PIO_IRQ_MASK
0000000c l       *ABS*	00000000 PIO_EDGE_CAP
00000010 l       *ABS*	00000000 PIO_OUTSET
00000014 l       *ABS*	00000000 PIO_OUTCLR
0015337c l       .text	00000000 adc_int_installer_done
001565c4 l       .rwdata	00000000 fifo_clk_src
00153408 l       .text	00000000 adc_int_handler_fast_clk_offset
00153400 l       .text	00000000 adc_int_handler_1M_clk_offset
0015340c l       .text	00000000 adc_int_handler_clear_front
001565c8 l       .rwdata	00000000 sample_buffer_A
00153488 l       .text	00000000 adc_int_handler_loop
001567a8 l       .rwdata	00000000 sample_buffer_B
00156988 l       .rwdata	00000000 sample_buffer_L
001565c0 l       .rwdata	00000000 sample_complete
00153568 l       .text	00000000 adc_int_handler_done
001535b8 l       .text	00000000 draw_trace_loop
001535e0 l       .text	00000000 draw_trace_col_loop
00153650 l       .text	00000000 draw_grid_pt
00153660 l       .text	00000000 draw_trace_pt
00153600 l       .text	00000000 draw_trace_col_loop_continue
00153620 l       .text	00000000 draw_trace_done
001536a8 l       .text	00000000 draw_grid_horiz
00153724 l       .text	00000000 draw_pixel
001536e4 l       .text	00000000 draw_grid_vert
001536f4 l       .text	00000000 draw_grid_done
00153774 l       .text	00000000 draw_pixel_done
001537b8 l       .text	00000000 clear_display_loop
001537c4 l       .text	00000000 clear_display_done
0015382c l       .text	00000000 plot_pixel_done
001538a4 l       .text	00000000 slow_sample_rate
00153864 l       .text	00000000 fast_sample_rate
001538e4 l       .text	00000000 set_sample_rate_done
00153944 l       .text	00000000 set_trigger_slope_pos
00153954 l       .text	00000000 set_trigger_done
00153990 l       .text	00000000 set_delay_done
00153a68 l       .text	00000000 start_sample_done
00153ab4 l       .text	00000000 sample_null
00153ad0 l       .text	00000000 sample_map
00153ab8 l       .text	00000000 sample_done_done
00000000 l    df *ABS*	00000000 obj/default/testdisp.o
00153aec l       .text	00000000 disp
00153b14 l       .text	00000000 draw_top
00153b20 l       .text	00000000 draw_bot
00153af8 l       .text	00000000 disp_cont
00153b5c l       .text	00000000 draw_border
00153c04 l       .text	00000000 disp_reset
00153b2c l       .text	00000000 draw_red
00153b38 l       .text	00000000 draw_yellow
00153b44 l       .text	00000000 draw_green
00153b50 l       .text	00000000 draw_blue
00153b68 l       .text	00000000 draw_border_top
00153b78 l       .text	00000000 dbt_loop
00153b8c l       .text	00000000 draw_border_bot
00153ba4 l       .text	00000000 dbb_loop
00153bb8 l       .text	00000000 draw_border_left
00153bc4 l       .text	00000000 dbl_loop
00153bd8 l       .text	00000000 draw_border_right
00153bf0 l       .text	00000000 dbr_loop
00153c10 l       .text	00000000 test_disp_done
00000000 l    df *ABS*	00000000 obj/default/testvram.o
00153c70 l     F .text	00000000 write_all
00153c9c l     F .text	00000000 read_all
00153c50 l       .text	00000000 test_vram_fail
00153c58 l       .text	00000000 test_vram_done
00153c78 l       .text	00000000 write_all_loop
00153c98 l       .text	00000000 write_all_done
00153c90 l       .text	00000000 write_all_reset_cnt
00153ca4 l       .text	00000000 read_all_loop
00153cc8 l       .text	00000000 read_all_done
00153cc0 l       .text	00000000 read_all_reset_cnt
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
0015408c l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00156b68 l     O .rwdata	000000c8 EPCS_ctrl
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0015423c l     F .text	00000038 alt_flash_device_register
001542c8 l     F .text	0000028c alt_epcs_flash_query
00154554 l     F .text	000000e8 alt_epcs_flash_memcmp
00154928 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 epcs_commands.c
00154c28 l     F .text	00000038 epcs_test_wip
00154c60 l     F .text	00000038 epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_close.c
001551f0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00155324 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00155350 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
00156dd8 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
0015489c g     F .text	0000008c alt_epcs_flash_get_info
00154178 g     F .text	0000005c alt_main
0015b1f0 g     O .bss	00000100 alt_irq
00151738 g     F .text	0000004c trg_delay_down
00157204 g       *ABS*	00000000 __flash_rwdata_start
00151210 g     F .text	00000084 display_scale
00157e88 g     O .bss	00000004 cur_scale
00151f08 g     F .text	00000028 trace_rearm
00153a80 g     F .text	00000000 sample_done
00150f9c g     F .text	00000020 get_trigger_mode
00157ebc g     O .bss	00000780 saved_trace_A
0015619c g     O .rodata	00000070 menu
00150e60 g     F .text	00000020 no_menu_action
0015396c g     F .text	00000000 set_delay
00000000  w      *UND*	00000000 __errno
00154c98 g     F .text	000000f8 epcs_sector_erase
00150000 g     F .entry	0000001c __reset
00150020 g       *ABS*	00000000 __flash_exceptions_start
001501f4 g     F .text	00000024 no_action
00157eb8 g     O .bss	00000004 errno
00157e70 g     O .bss	00000004 trigger_mode
001502f8 g     F .text	00000030 menu_right
00151460 g     F .text	00000048 set_trg_level
00157eb0 g     O .bss	00000004 alt_argv
00150940 g     F .text	00000064 init_menu
0015f1d8 g       *ABS*	00000000 _gp
00151e70 g     F .text	00000020 is_sampling
00120000 g       *ABS*	00000000 __alt_mem_RAM_ctrl
001502c8 g     F .text	00000030 menu_left
00156c58 g     O .rwdata	00000180 alt_fd_list
00154ed4 g     F .text	00000068 epcs_write_status_register
00155868 g     F .text	00000090 alt_find_dev
00153ccc g     F .text	000000f8 memcpy
001514f8 g     F .text	00000054 trg_level_up
00155de4 g       *ABS*	00000000 __DTOR_END__
00150eac g     F .text	00000040 set_trigger_mode
00154a30 g     F .text	00000104 alt_epcs_flash_write_block
001537dc g     F .text	00000000 plot_pixel
00000000  w      *UND*	00000000 malloc
0015268c g     F .text	00000110 restore_trace
00151b14 g     F .text	00000188 cvt_num_field
00157e8c g     O .bss	00000004 trace_status
001558f8 g     F .text	0000008c alt_icache_flush
001525cc g     F .text	000000c0 set_save_area
001539a8 g     F .text	00000000 start_sample
00151148 g     F .text	00000064 scale_down
001571ec g     O .rwdata	00000004 alt_max_fd
001531a8 g     F .text	00000000 key_available
00157e68 g     O .bss	00000004 menu_entry
001513f8 g     F .text	00000068 display_sweep
001549bc g     F .text	00000074 alt_epcs_flash_erase_block
00151f5c g     F .text	000003cc set_display_scale
00153580 g     F .text	00000000 draw_trace
0015279c g     F .text	00000048 do_trace
001571fc g     O .rwdata	00000004 _global_impure_ptr
00155198 g     F .text	00000058 epcs_exit_4_bytes_mode
0015b480 g       *ABS*	00000000 __bss_end
00153f9c g     F .text	000000f0 alt_iic_isr_register
00151dd4 g     F .text	00000064 init_trace
0015863c g     O .bss	00000780 saved_trace_B
00153f50 g     F .text	0000004c alt_ic_irq_enabled
001516f8 g     F .text	00000040 set_trg_delay
00150298 g     F .text	00000030 menu_down
00157ea8 g     O .bss	00000004 alt_irq_active
00151c9c g     F .text	00000138 get_test_sample
001500ec g     F .exceptions	000000cc alt_irq_handler
00156c30 g     O .rwdata	00000028 alt_dev_null
00150328 g     F .text	000000a8 clear_region
00155de4 g     O .rodata	00000380 char_patterns
00155308 g     F .text	0000001c alt_dcache_flush_all
00158dbc g     O .bss	00000780 trace_A
00150b4c g     F .text	0000006c previous_entry
00157204 g       *ABS*	00000000 __ram_rwdata_end
001571e4 g     O .rwdata	00000008 alt_dev_list
00151e38 g     F .text	00000038 set_mode
00153670 g     F .text	00000000 draw_grid
00130000 g       *ABS*	00000000 __alt_mem_FLASH_ctrl
00150d90 g     F .text	000000d0 display_entry
001565a0 g       *ABS*	00000000 __ram_rodata_end
00157e90 g     O .bss	00000004 saved_end_y
00151084 g     F .text	00000084 display_mode
00157e6c g     O .bss	00000004 menu_display
00155058 g     F .text	00000068 epcs_read_electronic_signature
0015b480 g       *ABS*	00000000 end
00150e80 g     F .text	0000002c no_display
0015154c g     F .text	00000098 display_trg_level
00151374 g     F .text	00000084 sweep_up
00150a80 g     F .text	0000005c reset_menu
001509a4 g     F .text	00000024 clear_menu
00151784 g     F .text	0000004c trg_delay_up
00155de4 g       *ABS*	00000000 __CTOR_LIST__
0015c000 g       *ABS*	00000000 __alt_stack_pointer
00152f34 g     F .text	00000000 key_int_installer
00155c08 g     F .text	000001a0 __call_exitprocs
001501b8 g     F .text	0000003c _start
0015953c g     O .bss	00000780 trace_L
00157e74 g     O .bss	00000004 level
00157e94 g     O .bss	00000004 saved_pos_y
00155660 g     F .text	00000208 alt_avalon_spi_command
0015162c g     F .text	00000054 trg_slope_toggle
00154208 g     F .text	00000034 alt_sys_init
00155ad8 g     F .text	00000130 __register_exitproc
001565a0 g       *ABS*	00000000 __ram_rwdata_start
00155de4 g       *ABS*	00000000 __ram_rodata_start
00154bcc g     F .text	0000005c epcs_read_status_register
00157e98 g     O .bss	00000004 sample_size
001562b4 g     O .rodata	000000a8 sweep_rates
0015378c g     F .text	00000000 clear_display
00157e9c g     O .bss	00000004 saved_end_x
001550c0 g     F .text	00000080 epcs_read_device_id
001559d0 g     F .text	0000007c memcmp
00153394 g     F .text	00000000 adc_int_handler
0015b480 g       *ABS*	00000000 __alt_stack_base
001524c8 g     F .text	00000104 restore_menu_trace
001553a0 g     F .text	000000a0 alt_dev_llist_insert
001571f4 g     O .rwdata	00000008 alt_flash_dev_list
00151f30 g     F .text	0000002c set_trace_size
00150690 g     F .text	00000098 plot_string
00157e68 g       *ABS*	00000000 __bss_start
00157ea0 g     O .bss	00000004 saved_pos_x
00150728 g     F .text	0000013c main
00157eb4 g     O .bss	00000004 alt_envp
001517d0 g     F .text	000000b8 adjust_trg_delay
001527e4 g     F .text	00000750 plot_trace
0015b2f0 g     O .bss	00000190 _atexit0
001512f4 g     F .text	00000080 sweep_down
001571f0 g     O .rwdata	00000004 alt_errno
00157e78 g     O .bss	00000004 sweep
00150fbc g     F .text	00000064 mode_down
0015325c g     F .text	00000000 adc_int_installer
00153844 g     F .text	00000000 set_sample_rate
00153900 g     F .text	00000000 set_trigger
00155de4 g       *ABS*	00000000 __CTOR_END__
00150000 g       *ABS*	00000000 __alt_mem_ONCHIP_mem
0015463c g     F .text	00000260 alt_epcs_flash_write
00150a48 g     F .text	00000038 refresh_menu
00155de4 g       *ABS*	00000000 __flash_rodata_start
00155de4 g       *ABS*	00000000 __DTOR_LIST__
00150268 g     F .text	00000030 menu_up
00150ca4 g     F .text	000000ec menu_entry_right
00157e7c g     O .bss	00000004 delay
001541d4 g     F .text	00000034 alt_irq_init
001555e0 g     F .text	00000060 alt_release_fd
00155984 g     F .text	00000014 atexit
00151ec8 g     F .text	00000040 trace_done
00157200 g     O .rwdata	00000004 _impure_ptr
00157eac g     O .bss	00000004 alt_argc
001515e4 g     F .text	00000048 set_trg_slope
001514a8 g     F .text	00000050 trg_level_down
0015549c g     F .text	0000005c _do_dtors
001531e0 g     F .text	00000000 getkey
00150528 g     F .text	00000168 plot_char
00159cbc g     O .bss	000002a0 saved_menu
00150020 g       .exceptions	00000000 alt_irq_entry
00150bb8 g     F .text	000000ec menu_entry_left
001571dc g     O .rwdata	00000008 alt_fs_list
00152328 g     F .text	000001a0 clear_saved_areas
001503d0 g     F .text	000000ac plot_hline
00161000 g       *ABS*	00000000 __alt_mem_EPCS_ctrl
00150020 g       *ABS*	00000000 __ram_exceptions_start
00154d90 g     F .text	000000f4 epcs_read_buffer
00154274 g     F .text	00000054 alt_epcs_flash_init
00159f5c g     O .bss	00000780 trace_B
00151108 g     F .text	00000040 set_scale
00153dc4 g     F .text	00000050 alt_ic_isr_register
0015a6dc g     O .bss	00000176 saved_axis_y
00153c14 g     F .text	00000000 test_vram
00157204 g       *ABS*	00000000 _edata
00150f24 g     F .text	0000003c set_trigger_auto
0015b480 g       *ABS*	00000000 _end
001554f8 g     F .text	00000068 alt_flash_open_dev
00151020 g     F .text	00000064 mode_up
001501b8 g       *ABS*	00000000 __ram_exceptions_end
00150f60 g     F .text	0000003c set_trigger_single
00153eb0 g     F .text	000000a0 alt_ic_irq_disable
00155140 g     F .text	00000058 epcs_enter_4_bytes_mode
0015a852 g     O .bss	0000012c saved_axis_x
00155640 g     F .text	00000020 altera_nios2_qsys_irq_init
00155998 g     F .text	00000038 exit
00150eec g     F .text	00000038 set_trigger_normal
00155560 g     F .text	00000050 alt_flash_close_dev
00151888 g     F .text	0000028c display_trg_delay
00153adc g     F .text	00000000 test_disp
0015c000 g       *ABS*	00000000 __alt_data_end
00150020 g     F .exceptions	00000000 alt_exception
00151680 g     F .text	00000078 display_trg_slope
0015a97e g     O .bss	000000f0 saved_area
00157ea4 g     O .bss	00000004 sampling
00155da8 g     F .text	0000003c _exit
00080000 g       *ABS*	00000000 __alt_mem_VRAM_ctrl
0015aa70 g     O .bss	00000780 saved_trace_L
00157e80 g     O .bss	00000004 scale
00155a4c g     F .text	0000008c strlen
00154e84 g     F .text	00000050 epcs_write_enable
00150864 g     F .text	000000dc key_lookup
001555b0 g     F .text	00000030 alt_icache_flush_all
001571d8 g     O .rwdata	00000004 alt_priority_mask
00153e14 g     F .text	0000009c alt_ic_irq_enable
0015047c g     F .text	000000ac plot_vline
001509c8 g     F .text	00000080 display_menu
00154b34 g     F .text	00000098 alt_epcs_flash_read
00155440 g     F .text	0000005c _do_ctors
00150adc g     F .text	00000070 next_entry
00155240 g     F .text	000000c8 close
00151e90 g     F .text	00000038 trace_rdy
00157e84 g     O .bss	00000004 slope
001540f8 g     F .text	00000080 alt_load
00151294 g     F .text	00000060 set_sweep
001511ac g     F .text	00000064 scale_up
00150218 g     F .text	00000050 menu_key
00000000  w      *UND*	00000000 free
00154f3c g     F .text	0000011c epcs_write_buffer



Disassembly of section .entry:

00150000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  150000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  150004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  150008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  15000c:	00bffd16 	blt	zero,r2,150004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  150010:	00400574 	movhi	at,21
    ori r1, r1, %lo(_start)
  150014:	08406e14 	ori	at,at,440
    jmp r1
  150018:	0800683a 	jmp	at
  15001c:	00000000 	call	0 <PIO_IRQ_MASK-0x8>

Disassembly of section .exceptions:

00150020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  150020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  150024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  150028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  15002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  150030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  150034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  150038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  15003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  150040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  150044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  150048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  15004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  150050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  150054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  150058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  15005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  150060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  150064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  150068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  15006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  150070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  150074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  150078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  15007c:	10000326 	beq	r2,zero,15008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  150080:	20000226 	beq	r4,zero,15008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  150084:	01500ec0 	call	1500ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  150088:	00000306 	br	150098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  15008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  150090:	e8bfff17 	ldw	r2,-4(ea)

00150094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  150094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  150098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  15009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1500a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1500a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1500a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1500ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1500b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1500b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1500b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1500bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1500c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1500c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1500c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1500cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1500d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1500d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1500d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1500dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1500e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1500e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1500e8:	ef80083a 	eret

001500ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1500ec:	defff904 	addi	sp,sp,-28
  1500f0:	dfc00615 	stw	ra,24(sp)
  1500f4:	df000515 	stw	fp,20(sp)
  1500f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  1500fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  150100:	0005313a 	rdctl	r2,ipending
  150104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  150108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  15010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  150110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  150114:	00800044 	movi	r2,1
  150118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  15011c:	e0fffb17 	ldw	r3,-20(fp)
  150120:	e0bffc17 	ldw	r2,-16(fp)
  150124:	1884703a 	and	r2,r3,r2
  150128:	10001726 	beq	r2,zero,150188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  15012c:	00c005b4 	movhi	r3,22
  150130:	18ec7c04 	addi	r3,r3,-19984
  150134:	e0bffd17 	ldw	r2,-12(fp)
  150138:	100490fa 	slli	r2,r2,3
  15013c:	1885883a 	add	r2,r3,r2
  150140:	10c00017 	ldw	r3,0(r2)
  150144:	010005b4 	movhi	r4,22
  150148:	212c7c04 	addi	r4,r4,-19984
  15014c:	e0bffd17 	ldw	r2,-12(fp)
  150150:	100490fa 	slli	r2,r2,3
  150154:	2085883a 	add	r2,r4,r2
  150158:	10800104 	addi	r2,r2,4
  15015c:	10800017 	ldw	r2,0(r2)
  150160:	1009883a 	mov	r4,r2
  150164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  150168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  15016c:	0005313a 	rdctl	r2,ipending
  150170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  150174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  150178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  15017c:	e0bffb17 	ldw	r2,-20(fp)
  150180:	103fe31e 	bne	r2,zero,150110 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  150184:	00000706 	br	1501a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  150188:	e0bffc17 	ldw	r2,-16(fp)
  15018c:	1085883a 	add	r2,r2,r2
  150190:	e0bffc15 	stw	r2,-16(fp)
      i++;
  150194:	e0bffd17 	ldw	r2,-12(fp)
  150198:	10800044 	addi	r2,r2,1
  15019c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  1501a0:	003fde06 	br	15011c <alt_irq_handler+0x30>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  1501a4:	e037883a 	mov	sp,fp
  1501a8:	dfc00117 	ldw	ra,4(sp)
  1501ac:	df000017 	ldw	fp,0(sp)
  1501b0:	dec00204 	addi	sp,sp,8
  1501b4:	f800283a 	ret

Disassembly of section .text:

001501b8 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  1501b8:	06c00574 	movhi	sp,21
    ori sp, sp, %lo(__alt_stack_pointer)
  1501bc:	def00014 	ori	sp,sp,49152
    movhi gp, %hi(_gp)
  1501c0:	06800574 	movhi	gp,21
    ori gp, gp, %lo(_gp)
  1501c4:	d6bc7614 	ori	gp,gp,61912
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  1501c8:	00800574 	movhi	r2,21
    ori r2, r2, %lo(__bss_start)
  1501cc:	109f9a14 	ori	r2,r2,32360

    movhi r3, %hi(__bss_end)
  1501d0:	00c00574 	movhi	r3,21
    ori r3, r3, %lo(__bss_end)
  1501d4:	18ed2014 	ori	r3,r3,46208

    beq r2, r3, 1f
  1501d8:	10c00326 	beq	r2,r3,1501e8 <_start+0x30>

0:
    stw zero, (r2)
  1501dc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  1501e0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  1501e4:	10fffd36 	bltu	r2,r3,1501dc <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  1501e8:	01540f80 	call	1540f8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  1501ec:	01541780 	call	154178 <alt_main>

001501f0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  1501f0:	003fff06 	br	1501f0 <alt_after_alt_main>

001501f4 <no_action>:
   Last Modified:    Mar. 8, 1994

*/

enum status  no_action(enum status cur_state)
{
  1501f4:	defffe04 	addi	sp,sp,-8
  1501f8:	df000115 	stw	fp,4(sp)
  1501fc:	df000104 	addi	fp,sp,4
  150200:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* return the current state */
    return  cur_state;
  150204:	e0bfff17 	ldw	r2,-4(fp)

}
  150208:	e037883a 	mov	sp,fp
  15020c:	df000017 	ldw	fp,0(sp)
  150210:	dec00104 	addi	sp,sp,4
  150214:	f800283a 	ret

00150218 <menu_key>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_key(enum status cur_state)
{
  150218:	defffd04 	addi	sp,sp,-12
  15021c:	dfc00215 	stw	ra,8(sp)
  150220:	df000115 	stw	fp,4(sp)
  150224:	df000104 	addi	fp,sp,4
  150228:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* check if need to turn the menu on or off */
    if (cur_state == MENU_ON)
  15022c:	e0bfff17 	ldw	r2,-4(fp)
  150230:	1000021e 	bne	r2,zero,15023c <menu_key+0x24>
        /* currently the menu is on, turn it off */
	clear_menu();
  150234:	01509a40 	call	1509a4 <clear_menu>
  150238:	00000106 	br	150240 <menu_key+0x28>
    else
        /* currently the menu is off, turn it on */
	display_menu();
  15023c:	01509c80 	call	1509c8 <display_menu>


    /* all done, return the "opposite" of the current state */
    if (cur_state == MENU_ON)
  150240:	e0bfff17 	ldw	r2,-4(fp)
  150244:	1000021e 	bne	r2,zero,150250 <menu_key+0x38>
        /* state was MENU_ON, change it to MENU_OFF */
        return  MENU_OFF;
  150248:	00800044 	movi	r2,1
  15024c:	00000106 	br	150254 <menu_key+0x3c>
    else
        /* state was MENU_OFF, change it to MENU_ON */
        return  MENU_ON;
  150250:	0005883a 	mov	r2,zero

}
  150254:	e037883a 	mov	sp,fp
  150258:	dfc00117 	ldw	ra,4(sp)
  15025c:	df000017 	ldw	fp,0(sp)
  150260:	dec00204 	addi	sp,sp,8
  150264:	f800283a 	ret

00150268 <menu_up>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_up(enum status cur_state)
{
  150268:	defffd04 	addi	sp,sp,-12
  15026c:	dfc00215 	stw	ra,8(sp)
  150270:	df000115 	stw	fp,4(sp)
  150274:	df000104 	addi	fp,sp,4
  150278:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the previous menu entry */
    previous_entry();
  15027c:	0150b4c0 	call	150b4c <previous_entry>


    /* return the current state */
    return  cur_state;
  150280:	e0bfff17 	ldw	r2,-4(fp)

}
  150284:	e037883a 	mov	sp,fp
  150288:	dfc00117 	ldw	ra,4(sp)
  15028c:	df000017 	ldw	fp,0(sp)
  150290:	dec00204 	addi	sp,sp,8
  150294:	f800283a 	ret

00150298 <menu_down>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_down(enum status cur_state)
{
  150298:	defffd04 	addi	sp,sp,-12
  15029c:	dfc00215 	stw	ra,8(sp)
  1502a0:	df000115 	stw	fp,4(sp)
  1502a4:	df000104 	addi	fp,sp,4
  1502a8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the next menu entry */
    next_entry();
  1502ac:	0150adc0 	call	150adc <next_entry>


    /* return the current state */
    return  cur_state;
  1502b0:	e0bfff17 	ldw	r2,-4(fp)

}
  1502b4:	e037883a 	mov	sp,fp
  1502b8:	dfc00117 	ldw	ra,4(sp)
  1502bc:	df000017 	ldw	fp,0(sp)
  1502c0:	dec00204 	addi	sp,sp,8
  1502c4:	f800283a 	ret

001502c8 <menu_left>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_left(enum status cur_state)
{
  1502c8:	defffd04 	addi	sp,sp,-12
  1502cc:	dfc00215 	stw	ra,8(sp)
  1502d0:	df000115 	stw	fp,4(sp)
  1502d4:	df000104 	addi	fp,sp,4
  1502d8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Left> key function for the current menu entry */
    menu_entry_left();
  1502dc:	0150bb80 	call	150bb8 <menu_entry_left>


    /* return the current state */
    return  cur_state;
  1502e0:	e0bfff17 	ldw	r2,-4(fp)

}
  1502e4:	e037883a 	mov	sp,fp
  1502e8:	dfc00117 	ldw	ra,4(sp)
  1502ec:	df000017 	ldw	fp,0(sp)
  1502f0:	dec00204 	addi	sp,sp,8
  1502f4:	f800283a 	ret

001502f8 <menu_right>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_right(enum status cur_state)
{
  1502f8:	defffd04 	addi	sp,sp,-12
  1502fc:	dfc00215 	stw	ra,8(sp)
  150300:	df000115 	stw	fp,4(sp)
  150304:	df000104 	addi	fp,sp,4
  150308:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Right> key function for the current menu entry */
    menu_entry_right();
  15030c:	0150ca40 	call	150ca4 <menu_entry_right>


    /* return the current state */
    return  cur_state;
  150310:	e0bfff17 	ldw	r2,-4(fp)

}
  150314:	e037883a 	mov	sp,fp
  150318:	dfc00117 	ldw	ra,4(sp)
  15031c:	df000017 	ldw	fp,0(sp)
  150320:	dec00204 	addi	sp,sp,8
  150324:	f800283a 	ret

00150328 <clear_region>:
   Last Modified:    Mar. 8, 1994

*/

void  clear_region(int x_ul, int y_ul, int x_size, int y_size)
{
  150328:	defff804 	addi	sp,sp,-32
  15032c:	dfc00715 	stw	ra,28(sp)
  150330:	df000615 	stw	fp,24(sp)
  150334:	df000604 	addi	fp,sp,24
  150338:	e13ffc15 	stw	r4,-16(fp)
  15033c:	e17ffd15 	stw	r5,-12(fp)
  150340:	e1bffe15 	stw	r6,-8(fp)
  150344:	e1ffff15 	stw	r7,-4(fp)
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  150348:	e0bffc17 	ldw	r2,-16(fp)
  15034c:	e0bffa15 	stw	r2,-24(fp)
  150350:	00001406 	br	1503a4 <clear_region+0x7c>
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  150354:	e0bffd17 	ldw	r2,-12(fp)
  150358:	e0bffb15 	stw	r2,-20(fp)
  15035c:	00000906 	br	150384 <clear_region+0x5c>

	    /* clear this pixel */
	    plot_pixel(x, y, PIXEL_BGND);
  150360:	e0fffa17 	ldw	r3,-24(fp)
  150364:	e0bffb17 	ldw	r2,-20(fp)
  150368:	1809883a 	mov	r4,r3
  15036c:	100b883a 	mov	r5,r2
  150370:	01800704 	movi	r6,28
  150374:	01537dc0 	call	1537dc <plot_pixel>



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  150378:	e0bffb17 	ldw	r2,-20(fp)
  15037c:	10800044 	addi	r2,r2,1
  150380:	e0bffb15 	stw	r2,-20(fp)
  150384:	e0fffd17 	ldw	r3,-12(fp)
  150388:	e0bfff17 	ldw	r2,-4(fp)
  15038c:	1885883a 	add	r2,r3,r2
  150390:	e0fffb17 	ldw	r3,-20(fp)
  150394:	18bff216 	blt	r3,r2,150360 <clear_region+0x38>
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  150398:	e0bffa17 	ldw	r2,-24(fp)
  15039c:	10800044 	addi	r2,r2,1
  1503a0:	e0bffa15 	stw	r2,-24(fp)
  1503a4:	e0fffc17 	ldw	r3,-16(fp)
  1503a8:	e0bffe17 	ldw	r2,-8(fp)
  1503ac:	1885883a 	add	r2,r3,r2
  1503b0:	e0fffa17 	ldw	r3,-24(fp)
  1503b4:	18bfe716 	blt	r3,r2,150354 <clear_region+0x2c>
        }
    }


    /* done clearing the display region - return */
    return;
  1503b8:	0001883a 	nop

}
  1503bc:	e037883a 	mov	sp,fp
  1503c0:	dfc00117 	ldw	ra,4(sp)
  1503c4:	df000017 	ldw	fp,0(sp)
  1503c8:	dec00204 	addi	sp,sp,8
  1503cc:	f800283a 	ret

001503d0 <plot_hline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_hline(int start_x, int start_y, int length)
{
  1503d0:	defff804 	addi	sp,sp,-32
  1503d4:	dfc00715 	stw	ra,28(sp)
  1503d8:	df000615 	stw	fp,24(sp)
  1503dc:	df000604 	addi	fp,sp,24
  1503e0:	e13ffd15 	stw	r4,-12(fp)
  1503e4:	e17ffe15 	stw	r5,-8(fp)
  1503e8:	e1bfff15 	stw	r6,-4(fp)
    int  end_x;		/* ending x position to plot */



    /* check if a line to the "right" or "left" */
    if (length > 0)  {
  1503ec:	e0bfff17 	ldw	r2,-4(fp)
  1503f0:	0080070e 	bge	zero,r2,150410 <plot_hline+0x40>

        /* line to the "right" - start at start_x, end at start_x + length */
	init_x = start_x;
  1503f4:	e0bffd17 	ldw	r2,-12(fp)
  1503f8:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x + length;
  1503fc:	e0fffd17 	ldw	r3,-12(fp)
  150400:	e0bfff17 	ldw	r2,-4(fp)
  150404:	1885883a 	add	r2,r3,r2
  150408:	e0bffc15 	stw	r2,-16(fp)
  15040c:	00000606 	br	150428 <plot_hline+0x58>
    }
    else  {

        /* line to the "left" - start at start_x + length, end at start_x */
	init_x = start_x + length;
  150410:	e0fffd17 	ldw	r3,-12(fp)
  150414:	e0bfff17 	ldw	r2,-4(fp)
  150418:	1885883a 	add	r2,r3,r2
  15041c:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x;
  150420:	e0bffd17 	ldw	r2,-12(fp)
  150424:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  150428:	e0bffb17 	ldw	r2,-20(fp)
  15042c:	e0bffa15 	stw	r2,-24(fp)
  150430:	00000906 	br	150458 <plot_hline+0x88>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_GREEN);
  150434:	e0fffa17 	ldw	r3,-24(fp)
  150438:	e0bffe17 	ldw	r2,-8(fp)
  15043c:	1809883a 	mov	r4,r3
  150440:	100b883a 	mov	r5,r2
  150444:	01b800d4 	movui	r6,57347
  150448:	01537dc0 	call	1537dc <plot_pixel>
	end_x = start_x;
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  15044c:	e0bffa17 	ldw	r2,-24(fp)
  150450:	10800044 	addi	r2,r2,1
  150454:	e0bffa15 	stw	r2,-24(fp)
  150458:	e0fffa17 	ldw	r3,-24(fp)
  15045c:	e0bffc17 	ldw	r2,-16(fp)
  150460:	18bff416 	blt	r3,r2,150434 <plot_hline+0x64>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_GREEN);


    /* done plotting the line - return */
    return;
  150464:	0001883a 	nop

}
  150468:	e037883a 	mov	sp,fp
  15046c:	dfc00117 	ldw	ra,4(sp)
  150470:	df000017 	ldw	fp,0(sp)
  150474:	dec00204 	addi	sp,sp,8
  150478:	f800283a 	ret

0015047c <plot_vline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_vline(int start_x, int start_y, int length)
{
  15047c:	defff804 	addi	sp,sp,-32
  150480:	dfc00715 	stw	ra,28(sp)
  150484:	df000615 	stw	fp,24(sp)
  150488:	df000604 	addi	fp,sp,24
  15048c:	e13ffd15 	stw	r4,-12(fp)
  150490:	e17ffe15 	stw	r5,-8(fp)
  150494:	e1bfff15 	stw	r6,-4(fp)
    int  end_y;		/* ending y position to plot */



    /* check if an "up" or "down" line */
    if (length > 0)  {
  150498:	e0bfff17 	ldw	r2,-4(fp)
  15049c:	0080070e 	bge	zero,r2,1504bc <plot_vline+0x40>

        /* line going "down" - start at start_y, end at start_y + length */
	init_y = start_y;
  1504a0:	e0bffe17 	ldw	r2,-8(fp)
  1504a4:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y + length;
  1504a8:	e0fffe17 	ldw	r3,-8(fp)
  1504ac:	e0bfff17 	ldw	r2,-4(fp)
  1504b0:	1885883a 	add	r2,r3,r2
  1504b4:	e0bffc15 	stw	r2,-16(fp)
  1504b8:	00000606 	br	1504d4 <plot_vline+0x58>
    }
    else  {

        /* line going "up" - start at start_y + length, end at start_y */
	init_y = start_y + length;
  1504bc:	e0fffe17 	ldw	r3,-8(fp)
  1504c0:	e0bfff17 	ldw	r2,-4(fp)
  1504c4:	1885883a 	add	r2,r3,r2
  1504c8:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y;
  1504cc:	e0bffe17 	ldw	r2,-8(fp)
  1504d0:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  1504d4:	e0bffb17 	ldw	r2,-20(fp)
  1504d8:	e0bffa15 	stw	r2,-24(fp)
  1504dc:	00000906 	br	150504 <plot_vline+0x88>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_GREEN);
  1504e0:	e0fffd17 	ldw	r3,-12(fp)
  1504e4:	e0bffa17 	ldw	r2,-24(fp)
  1504e8:	1809883a 	mov	r4,r3
  1504ec:	100b883a 	mov	r5,r2
  1504f0:	01b800d4 	movui	r6,57347
  1504f4:	01537dc0 	call	1537dc <plot_pixel>
	end_y = start_y;
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  1504f8:	e0bffa17 	ldw	r2,-24(fp)
  1504fc:	10800044 	addi	r2,r2,1
  150500:	e0bffa15 	stw	r2,-24(fp)
  150504:	e0fffa17 	ldw	r3,-24(fp)
  150508:	e0bffc17 	ldw	r2,-16(fp)
  15050c:	18bff416 	blt	r3,r2,1504e0 <plot_vline+0x64>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_GREEN);


    /* done plotting the line - return */
    return;
  150510:	0001883a 	nop

}
  150514:	e037883a 	mov	sp,fp
  150518:	dfc00117 	ldw	ra,4(sp)
  15051c:	df000017 	ldw	fp,0(sp)
  150520:	dec00204 	addi	sp,sp,8
  150524:	f800283a 	ret

00150528 <plot_char>:
   Last Modified:    May 27, 2008

*/

void  plot_char(int pos_x, int pos_y, char c, enum char_style style)
{
  150528:	defff504 	addi	sp,sp,-44
  15052c:	dfc00a15 	stw	ra,40(sp)
  150530:	df000915 	stw	fp,36(sp)
  150534:	df000904 	addi	fp,sp,36
  150538:	e13ffc15 	stw	r4,-16(fp)
  15053c:	e17ffd15 	stw	r5,-12(fp)
  150540:	3005883a 	mov	r2,r6
  150544:	e1ffff15 	stw	r7,-4(fp)
  150548:	e0bffe05 	stb	r2,-8(fp)
    int  y;		/* y pixel position for the character */



    /* setup the pixel positions for the character */
    x = pos_x * HORIZ_SIZE;
  15054c:	e0bffc17 	ldw	r2,-16(fp)
  150550:	108001a4 	muli	r2,r2,6
  150554:	e0bffb15 	stw	r2,-20(fp)
    y = pos_y * VERT_SIZE;
  150558:	e0bffd17 	ldw	r2,-12(fp)
  15055c:	100490fa 	slli	r2,r2,3
  150560:	e0bffa15 	stw	r2,-24(fp)


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  150564:	e03ff915 	stw	zero,-28(fp)
  150568:	00004006 	br	15066c <plot_char+0x144>

        /* get the character bits for this row from the character table */
	if (row == (VERT_SIZE - 1))
  15056c:	e0bff917 	ldw	r2,-28(fp)
  150570:	108001d8 	cmpnei	r2,r2,7
  150574:	1000021e 	bne	r2,zero,150580 <plot_char+0x58>
	    /* last row - blank it */
	    bits = 0;
  150578:	e03ff715 	stw	zero,-36(fp)
  15057c:	00000a06 	br	1505a8 <plot_char+0x80>
	else
	    /* in middle of character, get the row from the bit patterns */
            bits = char_patterns[(c * (VERT_SIZE - 1)) + row];
  150580:	e0bffe07 	ldb	r2,-8(fp)
  150584:	10c001e4 	muli	r3,r2,7
  150588:	e0bff917 	ldw	r2,-28(fp)
  15058c:	1885883a 	add	r2,r3,r2
  150590:	00c00574 	movhi	r3,21
  150594:	18d77904 	addi	r3,r3,24036
  150598:	1885883a 	add	r2,r3,r2
  15059c:	10800003 	ldbu	r2,0(r2)
  1505a0:	10803fcc 	andi	r2,r2,255
  1505a4:	e0bff715 	stw	r2,-36(fp)

	/* take care of "normal/reverse video" */
	if (style == REVERSE)
  1505a8:	e0bfff17 	ldw	r2,-4(fp)
  1505ac:	10800058 	cmpnei	r2,r2,1
  1505b0:	1000031e 	bne	r2,zero,1505c0 <plot_char+0x98>
	    /* invert the bits for "reverse video" */
	    bits = ~bits;
  1505b4:	e0bff717 	ldw	r2,-36(fp)
  1505b8:	0084303a 	nor	r2,zero,r2
  1505bc:	e0bff715 	stw	r2,-36(fp)

        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);
  1505c0:	e0bff717 	ldw	r2,-36(fp)
  1505c4:	1085883a 	add	r2,r2,r2
  1505c8:	1085883a 	add	r2,r2,r2
  1505cc:	e0bff715 	stw	r2,-36(fp)


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  1505d0:	e03ff815 	stw	zero,-32(fp)
  1505d4:	00001c06 	br	150648 <plot_char+0x120>

            /* output this pixel in the appropriate color */
	    if ((bits & 0x80) == 0)
  1505d8:	e0bff717 	ldw	r2,-36(fp)
  1505dc:	1080200c 	andi	r2,r2,128
  1505e0:	10000a1e 	bne	r2,zero,15060c <plot_char+0xe4>
	        /* blank pixel - output in PIXEL_WHITE */
		plot_pixel(x + col, y, PIXEL_BGND);
  1505e4:	e0fffb17 	ldw	r3,-20(fp)
  1505e8:	e0bff817 	ldw	r2,-32(fp)
  1505ec:	1885883a 	add	r2,r3,r2
  1505f0:	1007883a 	mov	r3,r2
  1505f4:	e0bffa17 	ldw	r2,-24(fp)
  1505f8:	1809883a 	mov	r4,r3
  1505fc:	100b883a 	mov	r5,r2
  150600:	01800704 	movi	r6,28
  150604:	01537dc0 	call	1537dc <plot_pixel>
  150608:	00000906 	br	150630 <plot_char+0x108>
	    else
	        /* black pixel - output in PIXEL_BLACK */
		plot_pixel(x + col, y, PIXEL_GREEN);
  15060c:	e0fffb17 	ldw	r3,-20(fp)
  150610:	e0bff817 	ldw	r2,-32(fp)
  150614:	1885883a 	add	r2,r3,r2
  150618:	1007883a 	mov	r3,r2
  15061c:	e0bffa17 	ldw	r2,-24(fp)
  150620:	1809883a 	mov	r4,r3
  150624:	100b883a 	mov	r5,r2
  150628:	01b800d4 	movui	r6,57347
  15062c:	01537dc0 	call	1537dc <plot_pixel>

	    /* shift the next bit into position */
	    bits <<= 1;
  150630:	e0bff717 	ldw	r2,-36(fp)
  150634:	1085883a 	add	r2,r2,r2
  150638:	e0bff715 	stw	r2,-36(fp)
        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  15063c:	e0bff817 	ldw	r2,-32(fp)
  150640:	10800044 	addi	r2,r2,1
  150644:	e0bff815 	stw	r2,-32(fp)
  150648:	e0bff817 	ldw	r2,-32(fp)
  15064c:	10800190 	cmplti	r2,r2,6
  150650:	103fe11e 	bne	r2,zero,1505d8 <plot_char+0xb0>
	    bits <<= 1;
        }


	/* next row - update the y position */
	y++;
  150654:	e0bffa17 	ldw	r2,-24(fp)
  150658:	10800044 	addi	r2,r2,1
  15065c:	e0bffa15 	stw	r2,-24(fp)
    x = pos_x * HORIZ_SIZE;
    y = pos_y * VERT_SIZE;


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  150660:	e0bff917 	ldw	r2,-28(fp)
  150664:	10800044 	addi	r2,r2,1
  150668:	e0bff915 	stw	r2,-28(fp)
  15066c:	e0bff917 	ldw	r2,-28(fp)
  150670:	10800210 	cmplti	r2,r2,8
  150674:	103fbd1e 	bne	r2,zero,15056c <plot_char+0x44>
	y++;
    }


    /* all done, return */
    return;
  150678:	0001883a 	nop

}
  15067c:	e037883a 	mov	sp,fp
  150680:	dfc00117 	ldw	ra,4(sp)
  150684:	df000017 	ldw	fp,0(sp)
  150688:	dec00204 	addi	sp,sp,8
  15068c:	f800283a 	ret

00150690 <plot_string>:
   Last Modified:    Mar. 17, 1997

*/

void  plot_string(int pos_x, int pos_y, const char *s, enum char_style style)
{
  150690:	defffa04 	addi	sp,sp,-24
  150694:	dfc00515 	stw	ra,20(sp)
  150698:	df000415 	stw	fp,16(sp)
  15069c:	df000404 	addi	fp,sp,16
  1506a0:	e13ffc15 	stw	r4,-16(fp)
  1506a4:	e17ffd15 	stw	r5,-12(fp)
  1506a8:	e1bffe15 	stw	r6,-8(fp)
  1506ac:	e1ffff15 	stw	r7,-4(fp)
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  1506b0:	00001106 	br	1506f8 <plot_string+0x68>

        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);
  1506b4:	e0fffc17 	ldw	r3,-16(fp)
  1506b8:	e0bffc17 	ldw	r2,-16(fp)
  1506bc:	10800044 	addi	r2,r2,1
  1506c0:	e0bffc15 	stw	r2,-16(fp)
  1506c4:	e0bffe17 	ldw	r2,-8(fp)
  1506c8:	10800003 	ldbu	r2,0(r2)
  1506cc:	10803fcc 	andi	r2,r2,255
  1506d0:	1080201c 	xori	r2,r2,128
  1506d4:	10bfe004 	addi	r2,r2,-128
  1506d8:	e13ffe17 	ldw	r4,-8(fp)
  1506dc:	21000044 	addi	r4,r4,1
  1506e0:	e13ffe15 	stw	r4,-8(fp)
  1506e4:	1809883a 	mov	r4,r3
  1506e8:	e17ffd17 	ldw	r5,-12(fp)
  1506ec:	100d883a 	mov	r6,r2
  1506f0:	e1ffff17 	ldw	r7,-4(fp)
  1506f4:	01505280 	call	150528 <plot_char>
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  1506f8:	e0bffe17 	ldw	r2,-8(fp)
  1506fc:	10800003 	ldbu	r2,0(r2)
  150700:	10803fcc 	andi	r2,r2,255
  150704:	1080201c 	xori	r2,r2,128
  150708:	10bfe004 	addi	r2,r2,-128
  15070c:	103fe91e 	bne	r2,zero,1506b4 <plot_string+0x24>
        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);


    /* all done, return */
    return;
  150710:	0001883a 	nop

}
  150714:	e037883a 	mov	sp,fp
  150718:	dfc00117 	ldw	ra,4(sp)
  15071c:	df000017 	ldw	fp,0(sp)
  150720:	dec00204 	addi	sp,sp,8
  150724:	f800283a 	ret

00150728 <main>:

   Author:           Glen George
   Last Modified:    May 27, 2008
*/

int  main() {
  150728:	deffef04 	addi	sp,sp,-68
  15072c:	dfc01015 	stw	ra,64(sp)
  150730:	df000f15 	stw	fp,60(sp)
  150734:	df000f04 	addi	fp,sp,60
    	srampt++;
    	c++;
    	if(c >= 100) c = 0;
    }*/

	key_int_installer();
  150738:	0152f340 	call	152f34 <key_int_installer>
	adc_int_installer();
  15073c:	015325c0 	call	15325c <adc_int_installer>
	}*/

	/* variables */
    enum keycode        key;		    /* an input key */

    enum status         state = MENU_ON;    /* current program state */
  150740:	e03ff115 	stw	zero,-60(fp)

    unsigned char      *sample;		    /* a captured trace */

    /* key processing functions (one for each system state type and key) */
    enum status  (* const process_key[NUM_KEYCODES][NUM_STATES])(enum status) =
  150744:	00800574 	movhi	r2,21
  150748:	10808604 	addi	r2,r2,536
  15074c:	e0bff415 	stw	r2,-48(fp)
  150750:	00800574 	movhi	r2,21
  150754:	10808604 	addi	r2,r2,536
  150758:	e0bff515 	stw	r2,-44(fp)
  15075c:	00800574 	movhi	r2,21
  150760:	10809a04 	addi	r2,r2,616
  150764:	e0bff615 	stw	r2,-40(fp)
  150768:	00800574 	movhi	r2,21
  15076c:	10807d04 	addi	r2,r2,500
  150770:	e0bff715 	stw	r2,-36(fp)
  150774:	00800574 	movhi	r2,21
  150778:	1080a604 	addi	r2,r2,664
  15077c:	e0bff815 	stw	r2,-32(fp)
  150780:	00800574 	movhi	r2,21
  150784:	10807d04 	addi	r2,r2,500
  150788:	e0bff915 	stw	r2,-28(fp)
  15078c:	00800574 	movhi	r2,21
  150790:	1080b204 	addi	r2,r2,712
  150794:	e0bffa15 	stw	r2,-24(fp)
  150798:	00800574 	movhi	r2,21
  15079c:	10807d04 	addi	r2,r2,500
  1507a0:	e0bffb15 	stw	r2,-20(fp)
  1507a4:	00800574 	movhi	r2,21
  1507a8:	1080be04 	addi	r2,r2,760
  1507ac:	e0bffc15 	stw	r2,-16(fp)
  1507b0:	00800574 	movhi	r2,21
  1507b4:	10807d04 	addi	r2,r2,500
  1507b8:	e0bffd15 	stw	r2,-12(fp)
  1507bc:	00800574 	movhi	r2,21
  1507c0:	10807d04 	addi	r2,r2,500
  1507c4:	e0bffe15 	stw	r2,-8(fp)
  1507c8:	00800574 	movhi	r2,21
  1507cc:	10807d04 	addi	r2,r2,500
  1507d0:	e0bfff15 	stw	r2,-4(fp)
        {  no_action,   no_action   } }; /* illegal key */



    /* first initialize everything */
    clear_display();		/* clear the display */
  1507d4:	015378c0 	call	15378c <clear_display>

    init_trace();		/* initialize the trace routines */
  1507d8:	0151dd40 	call	151dd4 <init_trace>
    init_menu();		/* initialize the menu system */
  1507dc:	01509400 	call	150940 <init_menu>
  1507e0:	00000106 	br	1507e8 <main+0xc0>
			key = key_lookup();

			//execute processing routine for that key
			state = process_key[key][state](state);
		}
    }
  1507e4:	0001883a 	nop
    // infinite loop processing input
	//int x = 0;
    while(TRUE)  {
    	//x += 1;
		// if ready to do a trace, do it
		if (trace_rdy()) do_trace();
  1507e8:	0151e900 	call	151e90 <trace_rdy>
  1507ec:	10000126 	beq	r2,zero,1507f4 <main+0xcc>
  1507f0:	015279c0 	call	15279c <do_trace>

		//check if have a trace to display
		if (is_sampling() && ((sample = sample_done()) != NULL))  {
  1507f4:	0151e700 	call	151e70 <is_sampling>
  1507f8:	10000726 	beq	r2,zero,150818 <main+0xf0>
  1507fc:	0153a800 	call	153a80 <sample_done>
  150800:	e0bff215 	stw	r2,-56(fp)
  150804:	e0bff217 	ldw	r2,-56(fp)
  150808:	10000326 	beq	r2,zero,150818 <main+0xf0>

			//have a trace - output it
			plot_trace(sample);
  15080c:	e13ff217 	ldw	r4,-56(fp)
  150810:	01527e40 	call	1527e4 <plot_trace>
			//done processing this trace
			trace_done();
  150814:	0151ec80 	call	151ec8 <trace_done>
		}

		//now check for keypad input
		if (key_available())  {
  150818:	01531a80 	call	1531a8 <key_available>
  15081c:	10803fcc 	andi	r2,r2,255
  150820:	103ff026 	beq	r2,zero,1507e4 <main+0xbc>

			//have keypad input - get the key
			key = key_lookup();
  150824:	01508640 	call	150864 <key_lookup>
  150828:	e0bff315 	stw	r2,-52(fp)

			//execute processing routine for that key
			state = process_key[key][state](state);
  15082c:	e0bff317 	ldw	r2,-52(fp)
  150830:	1087883a 	add	r3,r2,r2
  150834:	e0bff117 	ldw	r2,-60(fp)
  150838:	1885883a 	add	r2,r3,r2
  15083c:	1085883a 	add	r2,r2,r2
  150840:	1085883a 	add	r2,r2,r2
  150844:	e0fff104 	addi	r3,fp,-60
  150848:	1885883a 	add	r2,r3,r2
  15084c:	10800304 	addi	r2,r2,12
  150850:	10800017 	ldw	r2,0(r2)
  150854:	e13ff117 	ldw	r4,-60(fp)
  150858:	103ee83a 	callr	r2
  15085c:	e0bff115 	stw	r2,-60(fp)
		}
    }
  150860:	003fe006 	br	1507e4 <main+0xbc>

00150864 <key_lookup>:
   Last Modified:    Mar. 17, 1997

*/

enum keycode  	key_lookup()
{
  150864:	defff104 	addi	sp,sp,-60
  150868:	dfc00e15 	stw	ra,56(sp)
  15086c:	df000d15 	stw	fp,52(sp)
  150870:	df000d04 	addi	fp,sp,52
    /* variables */

    const enum keycode  keycodes[] = /* array of keycodes */
  150874:	e03ff515 	stw	zero,-44(fp)
  150878:	00800044 	movi	r2,1
  15087c:	e0bff615 	stw	r2,-40(fp)
  150880:	00800084 	movi	r2,2
  150884:	e0bff715 	stw	r2,-36(fp)
  150888:	008000c4 	movi	r2,3
  15088c:	e0bff815 	stw	r2,-32(fp)
  150890:	00800104 	movi	r2,4
  150894:	e0bff915 	stw	r2,-28(fp)
  150898:	00800144 	movi	r2,5
  15089c:	e0bffa15 	stw	r2,-24(fp)
           KEYCODE_LEFT,      /* <Left>     */
           KEYCODE_RIGHT,     /* <Right>    */
           KEYCODE_ILLEGAL    /* other keys */
        }; 

    const int  keys[] =   /* array of key values */
  1508a0:	e03ffb15 	stw	zero,-20(fp)
  1508a4:	00800044 	movi	r2,1
  1508a8:	e0bffc15 	stw	r2,-16(fp)
  1508ac:	00800084 	movi	r2,2
  1508b0:	e0bffd15 	stw	r2,-12(fp)
  1508b4:	008000c4 	movi	r2,3
  1508b8:	e0bffe15 	stw	r2,-8(fp)
  1508bc:	00800104 	movi	r2,4
  1508c0:	e0bfff15 	stw	r2,-4(fp)
    int  i;           	/* general loop index */



    /* get a key */
    key = getkey();
  1508c4:	01531e00 	call	1531e0 <getkey>
  1508c8:	e0bff415 	stw	r2,-48(fp)


    /* lookup key in keys array */
    for (i = 0; ((i < (sizeof(keys)/sizeof(int))) && (key != keys[i])); i++);
  1508cc:	e03ff315 	stw	zero,-52(fp)
  1508d0:	00000306 	br	1508e0 <key_lookup+0x7c>
  1508d4:	e0bff317 	ldw	r2,-52(fp)
  1508d8:	10800044 	addi	r2,r2,1
  1508dc:	e0bff315 	stw	r2,-52(fp)
  1508e0:	e0bff317 	ldw	r2,-52(fp)
  1508e4:	10800168 	cmpgeui	r2,r2,5
  1508e8:	1000091e 	bne	r2,zero,150910 <key_lookup+0xac>
  1508ec:	e0bff317 	ldw	r2,-52(fp)
  1508f0:	1085883a 	add	r2,r2,r2
  1508f4:	1085883a 	add	r2,r2,r2
  1508f8:	e0fff304 	addi	r3,fp,-52
  1508fc:	1885883a 	add	r2,r3,r2
  150900:	10800804 	addi	r2,r2,32
  150904:	10c00017 	ldw	r3,0(r2)
  150908:	e0bff417 	ldw	r2,-48(fp)
  15090c:	18bff11e 	bne	r3,r2,1508d4 <key_lookup+0x70>


    /* return the appropriate key type */
    return  keycodes[i];
  150910:	e0bff317 	ldw	r2,-52(fp)
  150914:	1085883a 	add	r2,r2,r2
  150918:	1085883a 	add	r2,r2,r2
  15091c:	e0fff304 	addi	r3,fp,-52
  150920:	1885883a 	add	r2,r3,r2
  150924:	10800204 	addi	r2,r2,8
  150928:	10800017 	ldw	r2,0(r2)

}
  15092c:	e037883a 	mov	sp,fp
  150930:	dfc00117 	ldw	ra,4(sp)
  150934:	df000017 	ldw	fp,0(sp)
  150938:	dec00204 	addi	sp,sp,8
  15093c:	f800283a 	ret

00150940 <init_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  init_menu(void)
{
  150940:	defffe04 	addi	sp,sp,-8
  150944:	dfc00115 	stw	ra,4(sp)
  150948:	df000015 	stw	fp,0(sp)
  15094c:	d839883a 	mov	fp,sp
      /* none */



    /* set the menu parameters */
    menu_entry = 0;		/* first menu entry */
  150950:	d0232415 	stw	zero,-29552(gp)
    menu_display = FALSE;	/* menu is not currently displayed (but it will be shortly) */
  150954:	d0232515 	stw	zero,-29548(gp)


    /* set the scope (option) parameters */
    set_trigger_mode(NORMAL_TRIGGER);	/* normal triggering */
  150958:	0009883a 	mov	r4,zero
  15095c:	0150eac0 	call	150eac <set_trigger_mode>
    set_scale(SCALE_AXES);		/* scale is axes */
  150960:	01000044 	movi	r4,1
  150964:	01511080 	call	151108 <set_scale>
    set_sweep(0);			/* first sweep rate */
  150968:	0009883a 	mov	r4,zero
  15096c:	01512940 	call	151294 <set_sweep>
    set_trg_level((MIN_TRG_LEVEL_SET + MAX_TRG_LEVEL_SET) / 2);	/* middle trigger level */
  150970:	01000fc4 	movi	r4,63
  150974:	01514600 	call	151460 <set_trg_level>
    set_trg_slope(SLOPE_POSITIVE);	/* positive slope */
  150978:	0009883a 	mov	r4,zero
  15097c:	01515e40 	call	1515e4 <set_trg_slope>
    set_trg_delay(0);		/* default delay */
  150980:	0009883a 	mov	r4,zero
  150984:	01516f80 	call	1516f8 <set_trg_delay>


    /* now display the menu */
    display_menu();
  150988:	01509c80 	call	1509c8 <display_menu>


    /* done initializing, return */
    return;
  15098c:	0001883a 	nop

}
  150990:	e037883a 	mov	sp,fp
  150994:	dfc00117 	ldw	ra,4(sp)
  150998:	df000017 	ldw	fp,0(sp)
  15099c:	dec00204 	addi	sp,sp,8
  1509a0:	f800283a 	ret

001509a4 <clear_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  clear_menu(void)
{
  1509a4:	deffff04 	addi	sp,sp,-4
  1509a8:	df000015 	stw	fp,0(sp)
  1509ac:	d839883a 	mov	fp,sp
//	restore_menu_trace();
//    }


    /* no longer displaying the menu */
    menu_display = FALSE;
  1509b0:	d0232515 	stw	zero,-29548(gp)


    /* all done, return */
    return;
  1509b4:	0001883a 	nop

}
  1509b8:	e037883a 	mov	sp,fp
  1509bc:	df000017 	ldw	fp,0(sp)
  1509c0:	dec00104 	addi	sp,sp,4
  1509c4:	f800283a 	ret

001509c8 <display_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  display_menu(void)
{
  1509c8:	defffd04 	addi	sp,sp,-12
  1509cc:	dfc00215 	stw	ra,8(sp)
  1509d0:	df000115 	stw	fp,4(sp)
  1509d4:	df000104 	addi	fp,sp,4
    int  i;		/* loop index */



    /* check if the menu is currently being displayed */
    if (!menu_display)  {
  1509d8:	d0a32517 	ldw	r2,-29548(gp)
  1509dc:	1000121e 	bne	r2,zero,150a28 <display_menu+0x60>

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  1509e0:	e03fff15 	stw	zero,-4(fp)
  1509e4:	00000d06 	br	150a1c <display_menu+0x54>

	    /* display this entry - check if it should be highlighted */
	    if (i == menu_entry)
  1509e8:	d0a32417 	ldw	r2,-29552(gp)
  1509ec:	e0ffff17 	ldw	r3,-4(fp)
  1509f0:	1880041e 	bne	r3,r2,150a04 <display_menu+0x3c>
	        /* currently selected entry - highlight it */
	        display_entry(i, TRUE);
  1509f4:	e13fff17 	ldw	r4,-4(fp)
  1509f8:	01400044 	movi	r5,1
  1509fc:	0150d900 	call	150d90 <display_entry>
  150a00:	00000306 	br	150a10 <display_menu+0x48>
	    else
	        /* not the currently selected entry - "normal video" */
	        display_entry(i, FALSE);
  150a04:	e13fff17 	ldw	r4,-4(fp)
  150a08:	000b883a 	mov	r5,zero
  150a0c:	0150d900 	call	150d90 <display_entry>
    /* check if the menu is currently being displayed */
    if (!menu_display)  {

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  150a10:	e0bfff17 	ldw	r2,-4(fp)
  150a14:	10800044 	addi	r2,r2,1
  150a18:	e0bfff15 	stw	r2,-4(fp)
  150a1c:	e0bfff17 	ldw	r2,-4(fp)
  150a20:	108001f0 	cmpltui	r2,r2,7
  150a24:	103ff01e 	bne	r2,zero,1509e8 <display_menu+0x20>
        }
    }


    /* now are displaying the menu */
    menu_display = TRUE;
  150a28:	00800044 	movi	r2,1
  150a2c:	d0a32515 	stw	r2,-29548(gp)


    /* all done, return */
    return;
  150a30:	0001883a 	nop

}
  150a34:	e037883a 	mov	sp,fp
  150a38:	dfc00117 	ldw	ra,4(sp)
  150a3c:	df000017 	ldw	fp,0(sp)
  150a40:	dec00204 	addi	sp,sp,8
  150a44:	f800283a 	ret

00150a48 <refresh_menu>:
   Last Modified:    Mar. 8, 1994

*/

void  refresh_menu(void)
{
  150a48:	defffe04 	addi	sp,sp,-8
  150a4c:	dfc00115 	stw	ra,4(sp)
  150a50:	df000015 	stw	fp,0(sp)
  150a54:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  150a58:	d0a32517 	ldw	r2,-29548(gp)
  150a5c:	10000226 	beq	r2,zero,150a68 <refresh_menu+0x20>

    	/* menu is currently being displayed - need to refresh it */
	/* do this by turning off the display, then forcing it back on */
	menu_display = FALSE;
  150a60:	d0232515 	stw	zero,-29548(gp)
	display_menu();
  150a64:	01509c80 	call	1509c8 <display_menu>
    }


    /* refreshed the menu if it was displayed, now return */
    return;
  150a68:	0001883a 	nop

}
  150a6c:	e037883a 	mov	sp,fp
  150a70:	dfc00117 	ldw	ra,4(sp)
  150a74:	df000017 	ldw	fp,0(sp)
  150a78:	dec00204 	addi	sp,sp,8
  150a7c:	f800283a 	ret

00150a80 <reset_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  reset_menu(void)
{
  150a80:	defffe04 	addi	sp,sp,-8
  150a84:	dfc00115 	stw	ra,4(sp)
  150a88:	df000015 	stw	fp,0(sp)
  150a8c:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  150a90:	d0a32517 	ldw	r2,-29548(gp)
  150a94:	10000426 	beq	r2,zero,150aa8 <reset_menu+0x28>

        /* menu is being displayed */
	/* remove highlight from currently selected entry */
	display_entry(menu_entry, FALSE);
  150a98:	d0a32417 	ldw	r2,-29552(gp)
  150a9c:	1009883a 	mov	r4,r2
  150aa0:	000b883a 	mov	r5,zero
  150aa4:	0150d900 	call	150d90 <display_entry>
    }


    /* reset the currently selected entry */
    menu_entry = 0;
  150aa8:	d0232415 	stw	zero,-29552(gp)


    /* finally, highlight the first entry if the menu is being displayed */
    if (menu_display)
  150aac:	d0a32517 	ldw	r2,-29548(gp)
  150ab0:	10000426 	beq	r2,zero,150ac4 <reset_menu+0x44>
	display_entry(menu_entry, TRUE);
  150ab4:	d0a32417 	ldw	r2,-29552(gp)
  150ab8:	1009883a 	mov	r4,r2
  150abc:	01400044 	movi	r5,1
  150ac0:	0150d900 	call	150d90 <display_entry>



    /* all done, return */
    return;
  150ac4:	0001883a 	nop

}
  150ac8:	e037883a 	mov	sp,fp
  150acc:	dfc00117 	ldw	ra,4(sp)
  150ad0:	df000017 	ldw	fp,0(sp)
  150ad4:	dec00204 	addi	sp,sp,8
  150ad8:	f800283a 	ret

00150adc <next_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  next_entry(void)
{
  150adc:	defffe04 	addi	sp,sp,-8
  150ae0:	dfc00115 	stw	ra,4(sp)
  150ae4:	df000015 	stw	fp,0(sp)
  150ae8:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at end of the menu */
    if (menu_entry < (NO_MENU_ENTRIES - 1))  {
  150aec:	d0a32417 	ldw	r2,-29552(gp)
  150af0:	108001a8 	cmpgeui	r2,r2,6
  150af4:	10000f1e 	bne	r2,zero,150b34 <next_entry+0x58>

        /* not at the end of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  150af8:	d0a32517 	ldw	r2,-29548(gp)
  150afc:	10000426 	beq	r2,zero,150b10 <next_entry+0x34>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  150b00:	d0a32417 	ldw	r2,-29552(gp)
  150b04:	1009883a 	mov	r4,r2
  150b08:	000b883a 	mov	r5,zero
  150b0c:	0150d900 	call	150d90 <display_entry>

	/* update the menu entry to the next one */
	menu_entry++;
  150b10:	d0a32417 	ldw	r2,-29552(gp)
  150b14:	10800044 	addi	r2,r2,1
  150b18:	d0a32415 	stw	r2,-29552(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  150b1c:	d0a32517 	ldw	r2,-29548(gp)
  150b20:	10000426 	beq	r2,zero,150b34 <next_entry+0x58>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  150b24:	d0a32417 	ldw	r2,-29552(gp)
  150b28:	1009883a 	mov	r4,r2
  150b2c:	01400044 	movi	r5,1
  150b30:	0150d900 	call	150d90 <display_entry>
    }


    /* all done, return */
    return;
  150b34:	0001883a 	nop

}
  150b38:	e037883a 	mov	sp,fp
  150b3c:	dfc00117 	ldw	ra,4(sp)
  150b40:	df000017 	ldw	fp,0(sp)
  150b44:	dec00204 	addi	sp,sp,8
  150b48:	f800283a 	ret

00150b4c <previous_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  previous_entry(void)
{
  150b4c:	defffe04 	addi	sp,sp,-8
  150b50:	dfc00115 	stw	ra,4(sp)
  150b54:	df000015 	stw	fp,0(sp)
  150b58:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at the start of the menu */
    if (menu_entry > 0)  {
  150b5c:	d0a32417 	ldw	r2,-29552(gp)
  150b60:	00800f0e 	bge	zero,r2,150ba0 <previous_entry+0x54>

        /* not at the start of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  150b64:	d0a32517 	ldw	r2,-29548(gp)
  150b68:	10000426 	beq	r2,zero,150b7c <previous_entry+0x30>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  150b6c:	d0a32417 	ldw	r2,-29552(gp)
  150b70:	1009883a 	mov	r4,r2
  150b74:	000b883a 	mov	r5,zero
  150b78:	0150d900 	call	150d90 <display_entry>

	/* update the menu entry to the previous one */
	menu_entry--;
  150b7c:	d0a32417 	ldw	r2,-29552(gp)
  150b80:	10bfffc4 	addi	r2,r2,-1
  150b84:	d0a32415 	stw	r2,-29552(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  150b88:	d0a32517 	ldw	r2,-29548(gp)
  150b8c:	10000426 	beq	r2,zero,150ba0 <previous_entry+0x54>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  150b90:	d0a32417 	ldw	r2,-29552(gp)
  150b94:	1009883a 	mov	r4,r2
  150b98:	01400044 	movi	r5,1
  150b9c:	0150d900 	call	150d90 <display_entry>

    }


    /* all done, return */
    return;
  150ba0:	0001883a 	nop

}
  150ba4:	e037883a 	mov	sp,fp
  150ba8:	dfc00117 	ldw	ra,4(sp)
  150bac:	df000017 	ldw	fp,0(sp)
  150bb0:	dec00204 	addi	sp,sp,8
  150bb4:	f800283a 	ret

00150bb8 <menu_entry_left>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_left(void)
{
  150bb8:	defff704 	addi	sp,sp,-36
  150bbc:	dfc00815 	stw	ra,32(sp)
  150bc0:	df000715 	stw	fp,28(sp)
  150bc4:	df000704 	addi	fp,sp,28
    /* variables */

    /* key processing functions */
    void  (* const process[])(void) =
  150bc8:	00800574 	movhi	r2,21
  150bcc:	1083ef04 	addi	r2,r2,4028
  150bd0:	e0bff915 	stw	r2,-28(fp)
  150bd4:	00800574 	movhi	r2,21
  150bd8:	10845204 	addi	r2,r2,4424
  150bdc:	e0bffa15 	stw	r2,-24(fp)
  150be0:	00800574 	movhi	r2,21
  150be4:	1084bd04 	addi	r2,r2,4852
  150be8:	e0bffb15 	stw	r2,-20(fp)
  150bec:	00800574 	movhi	r2,21
  150bf0:	1087c204 	addi	r2,r2,7944
  150bf4:	e0bffc15 	stw	r2,-16(fp)
  150bf8:	00800574 	movhi	r2,21
  150bfc:	10852a04 	addi	r2,r2,5288
  150c00:	e0bffd15 	stw	r2,-12(fp)
  150c04:	00800574 	movhi	r2,21
  150c08:	10858b04 	addi	r2,r2,5676
  150c0c:	e0bffe15 	stw	r2,-8(fp)
  150c10:	00800574 	movhi	r2,21
  150c14:	1085ce04 	addi	r2,r2,5944
  150c18:	e0bfff15 	stw	r2,-4(fp)
       /*  Level           Slope             Delay                        */



    /* invoke the appropriate <Left> key function */
    process[menu_entry]();
  150c1c:	d0a32417 	ldw	r2,-29552(gp)
  150c20:	1085883a 	add	r2,r2,r2
  150c24:	1085883a 	add	r2,r2,r2
  150c28:	e0fff904 	addi	r3,fp,-28
  150c2c:	1885883a 	add	r2,r3,r2
  150c30:	10800017 	ldw	r2,0(r2)
  150c34:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  150c38:	d0a32517 	ldw	r2,-29548(gp)
  150c3c:	10001426 	beq	r2,zero,150c90 <menu_entry_left+0xd8>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  150c40:	d0a32417 	ldw	r2,-29552(gp)
  150c44:	00c00574 	movhi	r3,21
  150c48:	18d86704 	addi	r3,r3,24988
  150c4c:	1004913a 	slli	r2,r2,4
  150c50:	1885883a 	add	r2,r3,r2
  150c54:	10800304 	addi	r2,r2,12
  150c58:	11c00017 	ldw	r7,0(r2)
  150c5c:	d0a32417 	ldw	r2,-29552(gp)
  150c60:	00c00574 	movhi	r3,21
  150c64:	18d86704 	addi	r3,r3,24988
  150c68:	1004913a 	slli	r2,r2,4
  150c6c:	1885883a 	add	r2,r3,r2
  150c70:	10800204 	addi	r2,r2,8
  150c74:	10800017 	ldw	r2,0(r2)
  150c78:	10c00fc4 	addi	r3,r2,63
  150c7c:	d0a32417 	ldw	r2,-29552(gp)
  150c80:	1809883a 	mov	r4,r3
  150c84:	100b883a 	mov	r5,r2
  150c88:	000d883a 	mov	r6,zero
  150c8c:	383ee83a 	callr	r7


    /* all done, return */
    return;

}
  150c90:	e037883a 	mov	sp,fp
  150c94:	dfc00117 	ldw	ra,4(sp)
  150c98:	df000017 	ldw	fp,0(sp)
  150c9c:	dec00204 	addi	sp,sp,8
  150ca0:	f800283a 	ret

00150ca4 <menu_entry_right>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_right(void)
{
  150ca4:	defff704 	addi	sp,sp,-36
  150ca8:	dfc00815 	stw	ra,32(sp)
  150cac:	df000715 	stw	fp,28(sp)
  150cb0:	df000704 	addi	fp,sp,28
    /* variables */

    /* key processing functions */
    void  (* const process[])(void) =
  150cb4:	00800574 	movhi	r2,21
  150cb8:	10840804 	addi	r2,r2,4128
  150cbc:	e0bff915 	stw	r2,-28(fp)
  150cc0:	00800574 	movhi	r2,21
  150cc4:	10846b04 	addi	r2,r2,4524
  150cc8:	e0bffa15 	stw	r2,-24(fp)
  150ccc:	00800574 	movhi	r2,21
  150cd0:	1084dd04 	addi	r2,r2,4980
  150cd4:	e0bffb15 	stw	r2,-20(fp)
  150cd8:	00800574 	movhi	r2,21
  150cdc:	1087c204 	addi	r2,r2,7944
  150ce0:	e0bffc15 	stw	r2,-16(fp)
  150ce4:	00800574 	movhi	r2,21
  150ce8:	10853e04 	addi	r2,r2,5368
  150cec:	e0bffd15 	stw	r2,-12(fp)
  150cf0:	00800574 	movhi	r2,21
  150cf4:	10858b04 	addi	r2,r2,5676
  150cf8:	e0bffe15 	stw	r2,-8(fp)
  150cfc:	00800574 	movhi	r2,21
  150d00:	1085e104 	addi	r2,r2,6020
  150d04:	e0bfff15 	stw	r2,-4(fp)
       /*  Level         Slope             Delay                        */



    /* invoke the appropriate <Right> key function */
    process[menu_entry]();
  150d08:	d0a32417 	ldw	r2,-29552(gp)
  150d0c:	1085883a 	add	r2,r2,r2
  150d10:	1085883a 	add	r2,r2,r2
  150d14:	e0fff904 	addi	r3,fp,-28
  150d18:	1885883a 	add	r2,r3,r2
  150d1c:	10800017 	ldw	r2,0(r2)
  150d20:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  150d24:	d0a32517 	ldw	r2,-29548(gp)
  150d28:	10001426 	beq	r2,zero,150d7c <menu_entry_right+0xd8>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  150d2c:	d0a32417 	ldw	r2,-29552(gp)
  150d30:	00c00574 	movhi	r3,21
  150d34:	18d86704 	addi	r3,r3,24988
  150d38:	1004913a 	slli	r2,r2,4
  150d3c:	1885883a 	add	r2,r3,r2
  150d40:	10800304 	addi	r2,r2,12
  150d44:	11c00017 	ldw	r7,0(r2)
  150d48:	d0a32417 	ldw	r2,-29552(gp)
  150d4c:	00c00574 	movhi	r3,21
  150d50:	18d86704 	addi	r3,r3,24988
  150d54:	1004913a 	slli	r2,r2,4
  150d58:	1885883a 	add	r2,r3,r2
  150d5c:	10800204 	addi	r2,r2,8
  150d60:	10800017 	ldw	r2,0(r2)
  150d64:	10c00fc4 	addi	r3,r2,63
  150d68:	d0a32417 	ldw	r2,-29552(gp)
  150d6c:	1809883a 	mov	r4,r3
  150d70:	100b883a 	mov	r5,r2
  150d74:	000d883a 	mov	r6,zero
  150d78:	383ee83a 	callr	r7


    /* all done, return */
    return;

}
  150d7c:	e037883a 	mov	sp,fp
  150d80:	dfc00117 	ldw	ra,4(sp)
  150d84:	df000017 	ldw	fp,0(sp)
  150d88:	dec00204 	addi	sp,sp,8
  150d8c:	f800283a 	ret

00150d90 <display_entry>:
   Last Modified:    Aug. 13, 2004

*/

void  display_entry(int entry, int selected)
{
  150d90:	defffc04 	addi	sp,sp,-16
  150d94:	dfc00315 	stw	ra,12(sp)
  150d98:	df000215 	stw	fp,8(sp)
  150d9c:	df000204 	addi	fp,sp,8
  150da0:	e13ffe15 	stw	r4,-8(fp)
  150da4:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* output the menu entry with the appropriate color */
    plot_string((MENU_X + menu[entry].h_off), (MENU_Y + entry), menu[entry].s,
  150da8:	00c00574 	movhi	r3,21
  150dac:	18d86704 	addi	r3,r3,24988
  150db0:	e0bffe17 	ldw	r2,-8(fp)
  150db4:	1004913a 	slli	r2,r2,4
  150db8:	1885883a 	add	r2,r3,r2
  150dbc:	10800104 	addi	r2,r2,4
  150dc0:	10800017 	ldw	r2,0(r2)
  150dc4:	11000fc4 	addi	r4,r2,63
  150dc8:	00c00574 	movhi	r3,21
  150dcc:	18d86704 	addi	r3,r3,24988
  150dd0:	e0bffe17 	ldw	r2,-8(fp)
  150dd4:	1004913a 	slli	r2,r2,4
  150dd8:	1885883a 	add	r2,r3,r2
  150ddc:	10c00017 	ldw	r3,0(r2)
  150de0:	e0bfff17 	ldw	r2,-4(fp)
  150de4:	1004c03a 	cmpne	r2,r2,zero
  150de8:	10803fcc 	andi	r2,r2,255
  150dec:	e17ffe17 	ldw	r5,-8(fp)
  150df0:	180d883a 	mov	r6,r3
  150df4:	100f883a 	mov	r7,r2
  150df8:	01506900 	call	150690 <plot_string>
    		(selected ? SELECTED : NORMAL));
    /* also output the menu option with the appropriate color */
    menu[entry].display((MENU_X + menu[entry].opt_off), (MENU_Y + entry),
  150dfc:	00c00574 	movhi	r3,21
  150e00:	18d86704 	addi	r3,r3,24988
  150e04:	e0bffe17 	ldw	r2,-8(fp)
  150e08:	1004913a 	slli	r2,r2,4
  150e0c:	1885883a 	add	r2,r3,r2
  150e10:	10800304 	addi	r2,r2,12
  150e14:	10c00017 	ldw	r3,0(r2)
  150e18:	01000574 	movhi	r4,21
  150e1c:	21186704 	addi	r4,r4,24988
  150e20:	e0bffe17 	ldw	r2,-8(fp)
  150e24:	1004913a 	slli	r2,r2,4
  150e28:	2085883a 	add	r2,r4,r2
  150e2c:	10800204 	addi	r2,r2,8
  150e30:	10800017 	ldw	r2,0(r2)
  150e34:	10800fc4 	addi	r2,r2,63
  150e38:	1009883a 	mov	r4,r2
  150e3c:	e17ffe17 	ldw	r5,-8(fp)
  150e40:	000d883a 	mov	r6,zero
  150e44:	183ee83a 	callr	r3
    			(selected ? OPTION_SELECTED : OPTION_NORMAL));


    /* all done outputting this menu entry - return */
    return;
  150e48:	0001883a 	nop

}
  150e4c:	e037883a 	mov	sp,fp
  150e50:	dfc00117 	ldw	ra,4(sp)
  150e54:	df000017 	ldw	fp,0(sp)
  150e58:	dec00204 	addi	sp,sp,8
  150e5c:	f800283a 	ret

00150e60 <no_menu_action>:
   Last Modified:    Mar. 8, 1994

*/

void  no_menu_action()
{
  150e60:	deffff04 	addi	sp,sp,-4
  150e64:	df000015 	stw	fp,0(sp)
  150e68:	d839883a 	mov	fp,sp
      /* none */



    /* nothing to do - return */
    return;
  150e6c:	0001883a 	nop

}
  150e70:	e037883a 	mov	sp,fp
  150e74:	df000017 	ldw	fp,0(sp)
  150e78:	dec00104 	addi	sp,sp,4
  150e7c:	f800283a 	ret

00150e80 <no_display>:
   Last Modified:    Mar. 8, 1994

*/

void  no_display(int x_pos, int y_pos, int style)
{
  150e80:	defffc04 	addi	sp,sp,-16
  150e84:	df000315 	stw	fp,12(sp)
  150e88:	df000304 	addi	fp,sp,12
  150e8c:	e13ffd15 	stw	r4,-12(fp)
  150e90:	e17ffe15 	stw	r5,-8(fp)
  150e94:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* nothing to do - return */
    return;
  150e98:	0001883a 	nop

}
  150e9c:	e037883a 	mov	sp,fp
  150ea0:	df000017 	ldw	fp,0(sp)
  150ea4:	dec00104 	addi	sp,sp,4
  150ea8:	f800283a 	ret

00150eac <set_trigger_mode>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trigger_mode(enum trigger_type m)
{
  150eac:	defffd04 	addi	sp,sp,-12
  150eb0:	dfc00215 	stw	ra,8(sp)
  150eb4:	df000115 	stw	fp,4(sp)
  150eb8:	df000104 	addi	fp,sp,4
  150ebc:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger mode */
    trigger_mode = m;
  150ec0:	e0bfff17 	ldw	r2,-4(fp)
  150ec4:	d0a32615 	stw	r2,-29544(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150ec8:	d0a32617 	ldw	r2,-29544(gp)
  150ecc:	1009883a 	mov	r4,r2
  150ed0:	0151e380 	call	151e38 <set_mode>


    /* all done setting the trigger mode - return */
    return;
  150ed4:	0001883a 	nop

}
  150ed8:	e037883a 	mov	sp,fp
  150edc:	dfc00117 	ldw	ra,4(sp)
  150ee0:	df000017 	ldw	fp,0(sp)
  150ee4:	dec00204 	addi	sp,sp,8
  150ee8:	f800283a 	ret

00150eec <set_trigger_normal>:
   Last Modified:    Jun. 13, 2014

*/

void  set_trigger_normal()
{
  150eec:	defffe04 	addi	sp,sp,-8
  150ef0:	dfc00115 	stw	ra,4(sp)
  150ef4:	df000015 	stw	fp,0(sp)
  150ef8:	d839883a 	mov	fp,sp
      /* none */



    /* set the trigger mode */
    trigger_mode = NORMAL_TRIGGER;
  150efc:	d0232615 	stw	zero,-29544(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150f00:	d0a32617 	ldw	r2,-29544(gp)
  150f04:	1009883a 	mov	r4,r2
  150f08:	0151e380 	call	151e38 <set_mode>


    /* all done setting the trigger mode - return */
    return;
  150f0c:	0001883a 	nop

}
  150f10:	e037883a 	mov	sp,fp
  150f14:	dfc00117 	ldw	ra,4(sp)
  150f18:	df000017 	ldw	fp,0(sp)
  150f1c:	dec00204 	addi	sp,sp,8
  150f20:	f800283a 	ret

00150f24 <set_trigger_auto>:
   Last Modified:    Jun. 13, 2014

*/

void  set_trigger_auto()
{
  150f24:	defffe04 	addi	sp,sp,-8
  150f28:	dfc00115 	stw	ra,4(sp)
  150f2c:	df000015 	stw	fp,0(sp)
  150f30:	d839883a 	mov	fp,sp
      /* none */



    /* set the trigger mode */
    trigger_mode = AUTO_TRIGGER;
  150f34:	00800044 	movi	r2,1
  150f38:	d0a32615 	stw	r2,-29544(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150f3c:	d0a32617 	ldw	r2,-29544(gp)
  150f40:	1009883a 	mov	r4,r2
  150f44:	0151e380 	call	151e38 <set_mode>


    /* all done setting the trigger mode - return */
    return;
  150f48:	0001883a 	nop

}
  150f4c:	e037883a 	mov	sp,fp
  150f50:	dfc00117 	ldw	ra,4(sp)
  150f54:	df000017 	ldw	fp,0(sp)
  150f58:	dec00204 	addi	sp,sp,8
  150f5c:	f800283a 	ret

00150f60 <set_trigger_single>:
   Last Modified:    Jun. 13, 2014

*/

void  set_trigger_single()
{
  150f60:	defffe04 	addi	sp,sp,-8
  150f64:	dfc00115 	stw	ra,4(sp)
  150f68:	df000015 	stw	fp,0(sp)
  150f6c:	d839883a 	mov	fp,sp
      /* none */



    /* set the trigger mode */
    trigger_mode = ONESHOT_TRIGGER;
  150f70:	00800084 	movi	r2,2
  150f74:	d0a32615 	stw	r2,-29544(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150f78:	d0a32617 	ldw	r2,-29544(gp)
  150f7c:	1009883a 	mov	r4,r2
  150f80:	0151e380 	call	151e38 <set_mode>


    /* all done setting the trigger mode - return */
    return;
  150f84:	0001883a 	nop

}
  150f88:	e037883a 	mov	sp,fp
  150f8c:	dfc00117 	ldw	ra,4(sp)
  150f90:	df000017 	ldw	fp,0(sp)
  150f94:	dec00204 	addi	sp,sp,8
  150f98:	f800283a 	ret

00150f9c <get_trigger_mode>:
   Last Modified:    May 9, 2006

*/

enum trigger_type  get_trigger_mode()
{
  150f9c:	deffff04 	addi	sp,sp,-4
  150fa0:	df000015 	stw	fp,0(sp)
  150fa4:	d839883a 	mov	fp,sp
      /* none */



    /* return the current trigger mode */
    return  trigger_mode;
  150fa8:	d0a32617 	ldw	r2,-29544(gp)

}
  150fac:	e037883a 	mov	sp,fp
  150fb0:	df000017 	ldw	fp,0(sp)
  150fb4:	dec00104 	addi	sp,sp,4
  150fb8:	f800283a 	ret

00150fbc <mode_down>:
   Last Modified:    May 9, 2006

*/

void  mode_down()
{
  150fbc:	defffe04 	addi	sp,sp,-8
  150fc0:	dfc00115 	stw	ra,4(sp)
  150fc4:	df000015 	stw	fp,0(sp)
  150fc8:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "next" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  150fcc:	d0a32617 	ldw	r2,-29544(gp)
  150fd0:	1000031e 	bne	r2,zero,150fe0 <mode_down+0x24>
        trigger_mode = AUTO_TRIGGER;
  150fd4:	00800044 	movi	r2,1
  150fd8:	d0a32615 	stw	r2,-29544(gp)
  150fdc:	00000706 	br	150ffc <mode_down+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  150fe0:	d0a32617 	ldw	r2,-29544(gp)
  150fe4:	10800058 	cmpnei	r2,r2,1
  150fe8:	1000031e 	bne	r2,zero,150ff8 <mode_down+0x3c>
        trigger_mode = ONESHOT_TRIGGER;
  150fec:	00800084 	movi	r2,2
  150ff0:	d0a32615 	stw	r2,-29544(gp)
  150ff4:	00000106 	br	150ffc <mode_down+0x40>
    else
        trigger_mode = NORMAL_TRIGGER;
  150ff8:	d0232615 	stw	zero,-29544(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150ffc:	d0a32617 	ldw	r2,-29544(gp)
  151000:	1009883a 	mov	r4,r2
  151004:	0151e380 	call	151e38 <set_mode>


    /* all done with the trigger mode - return */
    return;
  151008:	0001883a 	nop

}
  15100c:	e037883a 	mov	sp,fp
  151010:	dfc00117 	ldw	ra,4(sp)
  151014:	df000017 	ldw	fp,0(sp)
  151018:	dec00204 	addi	sp,sp,8
  15101c:	f800283a 	ret

00151020 <mode_up>:
   Last Modified:    May 9, 2006

*/

void  mode_up()
{
  151020:	defffe04 	addi	sp,sp,-8
  151024:	dfc00115 	stw	ra,4(sp)
  151028:	df000015 	stw	fp,0(sp)
  15102c:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "previous" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  151030:	d0a32617 	ldw	r2,-29544(gp)
  151034:	1000031e 	bne	r2,zero,151044 <mode_up+0x24>
        trigger_mode = ONESHOT_TRIGGER;
  151038:	00800084 	movi	r2,2
  15103c:	d0a32615 	stw	r2,-29544(gp)
  151040:	00000706 	br	151060 <mode_up+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  151044:	d0a32617 	ldw	r2,-29544(gp)
  151048:	10800058 	cmpnei	r2,r2,1
  15104c:	1000021e 	bne	r2,zero,151058 <mode_up+0x38>
        trigger_mode = NORMAL_TRIGGER;
  151050:	d0232615 	stw	zero,-29544(gp)
  151054:	00000206 	br	151060 <mode_up+0x40>
    else
        trigger_mode = AUTO_TRIGGER;
  151058:	00800044 	movi	r2,1
  15105c:	d0a32615 	stw	r2,-29544(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  151060:	d0a32617 	ldw	r2,-29544(gp)
  151064:	1009883a 	mov	r4,r2
  151068:	0151e380 	call	151e38 <set_mode>


    /* all done with the trigger mode - return */
    return;
  15106c:	0001883a 	nop

}
  151070:	e037883a 	mov	sp,fp
  151074:	dfc00117 	ldw	ra,4(sp)
  151078:	df000017 	ldw	fp,0(sp)
  15107c:	dec00204 	addi	sp,sp,8
  151080:	f800283a 	ret

00151084 <display_mode>:
   Last Modified:    May 9, 2006

*/

void  display_mode(int x_pos, int y_pos, int style)
{
  151084:	defff804 	addi	sp,sp,-32
  151088:	dfc00715 	stw	ra,28(sp)
  15108c:	df000615 	stw	fp,24(sp)
  151090:	df000604 	addi	fp,sp,24
  151094:	e13ffd15 	stw	r4,-12(fp)
  151098:	e17ffe15 	stw	r5,-8(fp)
  15109c:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* the mode strings (must match enumerated type) */
    const char * const  modes[] =  {  " Normal   ",
  1510a0:	00800574 	movhi	r2,21
  1510a4:	1098d704 	addi	r2,r2,25436
  1510a8:	e0bffa15 	stw	r2,-24(fp)
  1510ac:	00800574 	movhi	r2,21
  1510b0:	1098da04 	addi	r2,r2,25448
  1510b4:	e0bffb15 	stw	r2,-20(fp)
  1510b8:	00800574 	movhi	r2,21
  1510bc:	1098dd04 	addi	r2,r2,25460
  1510c0:	e0bffc15 	stw	r2,-16(fp)
                                             " One-Shot "  };



    /* display the trigger mode */
    plot_string(x_pos, y_pos, modes[trigger_mode], style);
  1510c4:	d0a32617 	ldw	r2,-29544(gp)
  1510c8:	1085883a 	add	r2,r2,r2
  1510cc:	1085883a 	add	r2,r2,r2
  1510d0:	e0fffa04 	addi	r3,fp,-24
  1510d4:	1885883a 	add	r2,r3,r2
  1510d8:	10c00017 	ldw	r3,0(r2)
  1510dc:	e0bfff17 	ldw	r2,-4(fp)
  1510e0:	e13ffd17 	ldw	r4,-12(fp)
  1510e4:	e17ffe17 	ldw	r5,-8(fp)
  1510e8:	180d883a 	mov	r6,r3
  1510ec:	100f883a 	mov	r7,r2
  1510f0:	01506900 	call	150690 <plot_string>


    /* all done displaying the trigger mode - return */
    return;

}
  1510f4:	e037883a 	mov	sp,fp
  1510f8:	dfc00117 	ldw	ra,4(sp)
  1510fc:	df000017 	ldw	fp,0(sp)
  151100:	dec00204 	addi	sp,sp,8
  151104:	f800283a 	ret

00151108 <set_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  set_scale(enum scale_type s)
{
  151108:	defffd04 	addi	sp,sp,-12
  15110c:	dfc00215 	stw	ra,8(sp)
  151110:	df000115 	stw	fp,4(sp)
  151114:	df000104 	addi	fp,sp,4
  151118:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the scale type */
    scale = s;
  15111c:	e0bfff17 	ldw	r2,-4(fp)
  151120:	d0a32a15 	stw	r2,-29528(gp)

    /* output the scale appropriately */
    set_display_scale(scale);
  151124:	d0a32a17 	ldw	r2,-29528(gp)
  151128:	1009883a 	mov	r4,r2
  15112c:	0151f5c0 	call	151f5c <set_display_scale>


    /* all done setting the scale type - return */
    return;
  151130:	0001883a 	nop

}
  151134:	e037883a 	mov	sp,fp
  151138:	dfc00117 	ldw	ra,4(sp)
  15113c:	df000017 	ldw	fp,0(sp)
  151140:	dec00204 	addi	sp,sp,8
  151144:	f800283a 	ret

00151148 <scale_down>:
   Last Modified:    May 9, 2006

*/

void  scale_down()
{
  151148:	defffe04 	addi	sp,sp,-8
  15114c:	dfc00115 	stw	ra,4(sp)
  151150:	df000015 	stw	fp,0(sp)
  151154:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "next" scale type */
    if (scale == SCALE_NONE)
  151158:	d0a32a17 	ldw	r2,-29528(gp)
  15115c:	1000031e 	bne	r2,zero,15116c <scale_down+0x24>
        scale = SCALE_AXES;
  151160:	00800044 	movi	r2,1
  151164:	d0a32a15 	stw	r2,-29528(gp)
  151168:	00000706 	br	151188 <scale_down+0x40>
    else if (scale == SCALE_AXES)
  15116c:	d0a32a17 	ldw	r2,-29528(gp)
  151170:	10800058 	cmpnei	r2,r2,1
  151174:	1000031e 	bne	r2,zero,151184 <scale_down+0x3c>
        scale = SCALE_GRID;
  151178:	00800084 	movi	r2,2
  15117c:	d0a32a15 	stw	r2,-29528(gp)
  151180:	00000106 	br	151188 <scale_down+0x40>
    else
        scale = SCALE_NONE;
  151184:	d0232a15 	stw	zero,-29528(gp)

    /* set the scale type */
    set_display_scale(scale);
  151188:	d0a32a17 	ldw	r2,-29528(gp)
  15118c:	1009883a 	mov	r4,r2
  151190:	0151f5c0 	call	151f5c <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  151194:	0001883a 	nop

}
  151198:	e037883a 	mov	sp,fp
  15119c:	dfc00117 	ldw	ra,4(sp)
  1511a0:	df000017 	ldw	fp,0(sp)
  1511a4:	dec00204 	addi	sp,sp,8
  1511a8:	f800283a 	ret

001511ac <scale_up>:
   Last Modified:    May 9, 2006

*/

void  scale_up()
{
  1511ac:	defffe04 	addi	sp,sp,-8
  1511b0:	dfc00115 	stw	ra,4(sp)
  1511b4:	df000015 	stw	fp,0(sp)
  1511b8:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "previous" scale type */
    if (scale == SCALE_NONE)
  1511bc:	d0a32a17 	ldw	r2,-29528(gp)
  1511c0:	1000031e 	bne	r2,zero,1511d0 <scale_up+0x24>
        scale = SCALE_GRID;
  1511c4:	00800084 	movi	r2,2
  1511c8:	d0a32a15 	stw	r2,-29528(gp)
  1511cc:	00000706 	br	1511ec <scale_up+0x40>
    else if (scale == SCALE_AXES)
  1511d0:	d0a32a17 	ldw	r2,-29528(gp)
  1511d4:	10800058 	cmpnei	r2,r2,1
  1511d8:	1000021e 	bne	r2,zero,1511e4 <scale_up+0x38>
        scale = SCALE_NONE;
  1511dc:	d0232a15 	stw	zero,-29528(gp)
  1511e0:	00000206 	br	1511ec <scale_up+0x40>
    else
        scale = SCALE_AXES;
  1511e4:	00800044 	movi	r2,1
  1511e8:	d0a32a15 	stw	r2,-29528(gp)

    /* set the scale type */
    set_display_scale(scale);
  1511ec:	d0a32a17 	ldw	r2,-29528(gp)
  1511f0:	1009883a 	mov	r4,r2
  1511f4:	0151f5c0 	call	151f5c <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  1511f8:	0001883a 	nop

}
  1511fc:	e037883a 	mov	sp,fp
  151200:	dfc00117 	ldw	ra,4(sp)
  151204:	df000017 	ldw	fp,0(sp)
  151208:	dec00204 	addi	sp,sp,8
  15120c:	f800283a 	ret

00151210 <display_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  display_scale(int x_pos, int y_pos, int style)
{
  151210:	defff804 	addi	sp,sp,-32
  151214:	dfc00715 	stw	ra,28(sp)
  151218:	df000615 	stw	fp,24(sp)
  15121c:	df000604 	addi	fp,sp,24
  151220:	e13ffd15 	stw	r4,-12(fp)
  151224:	e17ffe15 	stw	r5,-8(fp)
  151228:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* the scale type strings (must match enumerated type) */
    const char * const  scale_stat[] =  {  " None",
  15122c:	00800574 	movhi	r2,21
  151230:	1098e004 	addi	r2,r2,25472
  151234:	e0bffa15 	stw	r2,-24(fp)
  151238:	00800574 	movhi	r2,21
  15123c:	1098e204 	addi	r2,r2,25480
  151240:	e0bffb15 	stw	r2,-20(fp)
  151244:	00800574 	movhi	r2,21
  151248:	1098e404 	addi	r2,r2,25488
  15124c:	e0bffc15 	stw	r2,-16(fp)
                                                  " Grid"  };



    /* display the scale status */
    plot_string(x_pos, y_pos, scale_stat[scale], style);
  151250:	d0a32a17 	ldw	r2,-29528(gp)
  151254:	1085883a 	add	r2,r2,r2
  151258:	1085883a 	add	r2,r2,r2
  15125c:	e0fffa04 	addi	r3,fp,-24
  151260:	1885883a 	add	r2,r3,r2
  151264:	10c00017 	ldw	r3,0(r2)
  151268:	e0bfff17 	ldw	r2,-4(fp)
  15126c:	e13ffd17 	ldw	r4,-12(fp)
  151270:	e17ffe17 	ldw	r5,-8(fp)
  151274:	180d883a 	mov	r6,r3
  151278:	100f883a 	mov	r7,r2
  15127c:	01506900 	call	150690 <plot_string>


    /* all done displaying the scale status - return */
    return;

}
  151280:	e037883a 	mov	sp,fp
  151284:	dfc00117 	ldw	ra,4(sp)
  151288:	df000017 	ldw	fp,0(sp)
  15128c:	dec00204 	addi	sp,sp,8
  151290:	f800283a 	ret

00151294 <set_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  set_sweep(int s)
{
  151294:	defffc04 	addi	sp,sp,-16
  151298:	dfc00315 	stw	ra,12(sp)
  15129c:	df000215 	stw	fp,8(sp)
  1512a0:	df000204 	addi	fp,sp,8
  1512a4:	e13fff15 	stw	r4,-4(fp)
    int  sample_size;		/* sample size for this sweep rate */



    /* set the new sweep rate */
    sweep = s;
  1512a8:	e0bfff17 	ldw	r2,-4(fp)
  1512ac:	d0a32815 	stw	r2,-29536(gp)

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  1512b0:	d0a32817 	ldw	r2,-29536(gp)
  1512b4:	00c00574 	movhi	r3,21
  1512b8:	18d8ad04 	addi	r3,r3,25268
  1512bc:	100490fa 	slli	r2,r2,3
  1512c0:	1885883a 	add	r2,r3,r2
  1512c4:	10800017 	ldw	r2,0(r2)
  1512c8:	1009883a 	mov	r4,r2
  1512cc:	01538440 	call	153844 <set_sample_rate>
  1512d0:	e0bffe15 	stw	r2,-8(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  1512d4:	e13ffe17 	ldw	r4,-8(fp)
  1512d8:	0151f300 	call	151f30 <set_trace_size>


    /* all done initializing the sweep rate - return */
    return;
  1512dc:	0001883a 	nop

}
  1512e0:	e037883a 	mov	sp,fp
  1512e4:	dfc00117 	ldw	ra,4(sp)
  1512e8:	df000017 	ldw	fp,0(sp)
  1512ec:	dec00204 	addi	sp,sp,8
  1512f0:	f800283a 	ret

001512f4 <sweep_down>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_down()
{
  1512f4:	defffd04 	addi	sp,sp,-12
  1512f8:	dfc00215 	stw	ra,8(sp)
  1512fc:	df000115 	stw	fp,4(sp)
  151300:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* decrease the sweep rate, if not already the minimum */
    if (sweep > 0)  {
  151304:	d0a32817 	ldw	r2,-29536(gp)
  151308:	0080090e 	bge	zero,r2,151330 <sweep_down+0x3c>
        /* not at minimum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep - 1));
  15130c:	d0e32817 	ldw	r3,-29536(gp)
  151310:	d0a32817 	ldw	r2,-29536(gp)
  151314:	10bfffc4 	addi	r2,r2,-1
  151318:	1809883a 	mov	r4,r3
  15131c:	100b883a 	mov	r5,r2
  151320:	01517d00 	call	1517d0 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep--;
  151324:	d0a32817 	ldw	r2,-29536(gp)
  151328:	10bfffc4 	addi	r2,r2,-1
  15132c:	d0a32815 	stw	r2,-29536(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  151330:	d0a32817 	ldw	r2,-29536(gp)
  151334:	00c00574 	movhi	r3,21
  151338:	18d8ad04 	addi	r3,r3,25268
  15133c:	100490fa 	slli	r2,r2,3
  151340:	1885883a 	add	r2,r3,r2
  151344:	10800017 	ldw	r2,0(r2)
  151348:	1009883a 	mov	r4,r2
  15134c:	01538440 	call	153844 <set_sample_rate>
  151350:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  151354:	e13fff17 	ldw	r4,-4(fp)
  151358:	0151f300 	call	151f30 <set_trace_size>


    /* all done with lowering the sweep rate - return */
    return;
  15135c:	0001883a 	nop

}
  151360:	e037883a 	mov	sp,fp
  151364:	dfc00117 	ldw	ra,4(sp)
  151368:	df000017 	ldw	fp,0(sp)
  15136c:	dec00204 	addi	sp,sp,8
  151370:	f800283a 	ret

00151374 <sweep_up>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_up()
{
  151374:	defffd04 	addi	sp,sp,-12
  151378:	dfc00215 	stw	ra,8(sp)
  15137c:	df000115 	stw	fp,4(sp)
  151380:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* increase the sweep rate, if not already the maximum */
    if (sweep < (NO_SWEEP_RATES - 1))  {
  151384:	d0a32817 	ldw	r2,-29536(gp)
  151388:	10800528 	cmpgeui	r2,r2,20
  15138c:	1000091e 	bne	r2,zero,1513b4 <sweep_up+0x40>
        /* not at maximum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep + 1));
  151390:	d0e32817 	ldw	r3,-29536(gp)
  151394:	d0a32817 	ldw	r2,-29536(gp)
  151398:	10800044 	addi	r2,r2,1
  15139c:	1809883a 	mov	r4,r3
  1513a0:	100b883a 	mov	r5,r2
  1513a4:	01517d00 	call	1517d0 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep++;
  1513a8:	d0a32817 	ldw	r2,-29536(gp)
  1513ac:	10800044 	addi	r2,r2,1
  1513b0:	d0a32815 	stw	r2,-29536(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  1513b4:	d0a32817 	ldw	r2,-29536(gp)
  1513b8:	00c00574 	movhi	r3,21
  1513bc:	18d8ad04 	addi	r3,r3,25268
  1513c0:	100490fa 	slli	r2,r2,3
  1513c4:	1885883a 	add	r2,r3,r2
  1513c8:	10800017 	ldw	r2,0(r2)
  1513cc:	1009883a 	mov	r4,r2
  1513d0:	01538440 	call	153844 <set_sample_rate>
  1513d4:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  1513d8:	e13fff17 	ldw	r4,-4(fp)
  1513dc:	0151f300 	call	151f30 <set_trace_size>


    /* all done with raising the sweep rate - return */
    return;
  1513e0:	0001883a 	nop

}
  1513e4:	e037883a 	mov	sp,fp
  1513e8:	dfc00117 	ldw	ra,4(sp)
  1513ec:	df000017 	ldw	fp,0(sp)
  1513f0:	dec00204 	addi	sp,sp,8
  1513f4:	f800283a 	ret

001513f8 <display_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  display_sweep(int x_pos, int y_pos, int style)
{
  1513f8:	defffb04 	addi	sp,sp,-20
  1513fc:	dfc00415 	stw	ra,16(sp)
  151400:	df000315 	stw	fp,12(sp)
  151404:	df000304 	addi	fp,sp,12
  151408:	e13ffd15 	stw	r4,-12(fp)
  15140c:	e17ffe15 	stw	r5,-8(fp)
  151410:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* display the sweep rate */
    plot_string(x_pos, y_pos, sweep_rates[sweep].s, style);
  151414:	d0a32817 	ldw	r2,-29536(gp)
  151418:	00c00574 	movhi	r3,21
  15141c:	18d8ad04 	addi	r3,r3,25268
  151420:	100490fa 	slli	r2,r2,3
  151424:	1885883a 	add	r2,r3,r2
  151428:	10800104 	addi	r2,r2,4
  15142c:	10c00017 	ldw	r3,0(r2)
  151430:	e0bfff17 	ldw	r2,-4(fp)
  151434:	e13ffd17 	ldw	r4,-12(fp)
  151438:	e17ffe17 	ldw	r5,-8(fp)
  15143c:	180d883a 	mov	r6,r3
  151440:	100f883a 	mov	r7,r2
  151444:	01506900 	call	150690 <plot_string>


    /* all done displaying the sweep rate - return */
    return;
  151448:	0001883a 	nop

}
  15144c:	e037883a 	mov	sp,fp
  151450:	dfc00117 	ldw	ra,4(sp)
  151454:	df000017 	ldw	fp,0(sp)
  151458:	dec00204 	addi	sp,sp,8
  15145c:	f800283a 	ret

00151460 <set_trg_level>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_level(int l)
{
  151460:	defffd04 	addi	sp,sp,-12
  151464:	dfc00215 	stw	ra,8(sp)
  151468:	df000115 	stw	fp,4(sp)
  15146c:	df000104 	addi	fp,sp,4
  151470:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger level */
    level = l;
  151474:	e0bfff17 	ldw	r2,-4(fp)
  151478:	d0a32715 	stw	r2,-29540(gp)

    /* set the trigger level in hardware too */
    set_trigger(level, slope);
  15147c:	d0e32717 	ldw	r3,-29540(gp)
  151480:	d0a32b17 	ldw	r2,-29524(gp)
  151484:	1809883a 	mov	r4,r3
  151488:	100b883a 	mov	r5,r2
  15148c:	01539000 	call	153900 <set_trigger>


    /* all done initializing the trigger level - return */
    return;
  151490:	0001883a 	nop

}
  151494:	e037883a 	mov	sp,fp
  151498:	dfc00117 	ldw	ra,4(sp)
  15149c:	df000017 	ldw	fp,0(sp)
  1514a0:	dec00204 	addi	sp,sp,8
  1514a4:	f800283a 	ret

001514a8 <trg_level_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_down()
{
  1514a8:	defffe04 	addi	sp,sp,-8
  1514ac:	dfc00115 	stw	ra,4(sp)
  1514b0:	df000015 	stw	fp,0(sp)
  1514b4:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger level, if not already the minimum */
    if (level > MIN_TRG_LEVEL_SET)
  1514b8:	d0a32717 	ldw	r2,-29540(gp)
  1514bc:	0080030e 	bge	zero,r2,1514cc <trg_level_down+0x24>
        level--;
  1514c0:	d0a32717 	ldw	r2,-29540(gp)
  1514c4:	10bfffc4 	addi	r2,r2,-1
  1514c8:	d0a32715 	stw	r2,-29540(gp)

    /* set the trigger level for the hardware */
    set_trigger(level, slope);
  1514cc:	d0e32717 	ldw	r3,-29540(gp)
  1514d0:	d0a32b17 	ldw	r2,-29524(gp)
  1514d4:	1809883a 	mov	r4,r3
  1514d8:	100b883a 	mov	r5,r2
  1514dc:	01539000 	call	153900 <set_trigger>


    /* all done with lowering the trigger level - return */
    return;
  1514e0:	0001883a 	nop

}
  1514e4:	e037883a 	mov	sp,fp
  1514e8:	dfc00117 	ldw	ra,4(sp)
  1514ec:	df000017 	ldw	fp,0(sp)
  1514f0:	dec00204 	addi	sp,sp,8
  1514f4:	f800283a 	ret

001514f8 <trg_level_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_up()
{
  1514f8:	defffe04 	addi	sp,sp,-8
  1514fc:	dfc00115 	stw	ra,4(sp)
  151500:	df000015 	stw	fp,0(sp)
  151504:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger level, if not already the maximum */
    if (level < MAX_TRG_LEVEL_SET)
  151508:	d0a32717 	ldw	r2,-29540(gp)
  15150c:	10801fc8 	cmpgei	r2,r2,127
  151510:	1000031e 	bne	r2,zero,151520 <trg_level_up+0x28>
        level++;
  151514:	d0a32717 	ldw	r2,-29540(gp)
  151518:	10800044 	addi	r2,r2,1
  15151c:	d0a32715 	stw	r2,-29540(gp)

    /* tell the hardware the new trigger level */
    set_trigger(level, slope);
  151520:	d0e32717 	ldw	r3,-29540(gp)
  151524:	d0a32b17 	ldw	r2,-29524(gp)
  151528:	1809883a 	mov	r4,r3
  15152c:	100b883a 	mov	r5,r2
  151530:	01539000 	call	153900 <set_trigger>


    /* all done raising the trigger level - return */
    return;
  151534:	0001883a 	nop

}
  151538:	e037883a 	mov	sp,fp
  15153c:	dfc00117 	ldw	ra,4(sp)
  151540:	df000017 	ldw	fp,0(sp)
  151544:	dec00204 	addi	sp,sp,8
  151548:	f800283a 	ret

0015154c <display_trg_level>:
   Last Modified:    Mar. 10, 1995

*/

void  display_trg_level(int x_pos, int y_pos, int style)
{
  15154c:	defff704 	addi	sp,sp,-36
  151550:	dfc00815 	stw	ra,32(sp)
  151554:	df000715 	stw	fp,28(sp)
  151558:	df000704 	addi	fp,sp,28
  15155c:	e13ffd15 	stw	r4,-12(fp)
  151560:	e17ffe15 	stw	r5,-8(fp)
  151564:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      level_str[] = "        "; /* string containing the trigger level */
  151568:	00880834 	movhi	r2,8224
  15156c:	10880804 	addi	r2,r2,8224
  151570:	e0bffa15 	stw	r2,-24(fp)
  151574:	00880834 	movhi	r2,8224
  151578:	10880804 	addi	r2,r2,8224
  15157c:	e0bffb15 	stw	r2,-20(fp)
  151580:	e03ffc05 	stb	zero,-16(fp)
    long int  l;			/* trigger level in mV */



    /* compute the trigger level in millivolts */
    l = ((long int) MAX_LEVEL - MIN_LEVEL) * level / (MAX_TRG_LEVEL_SET - MIN_TRG_LEVEL_SET) + MIN_LEVEL;
  151584:	d0a32717 	ldw	r2,-29540(gp)
  151588:	10c4e224 	muli	r3,r2,5000
  15158c:	00801fc4 	movi	r2,127
  151590:	1885283a 	div	r2,r3,r2
  151594:	e0bff915 	stw	r2,-28(fp)

    /* convert the level to the string (leave first character blank) */
    cvt_num_field(l, &level_str[1]);
  151598:	e0bffa04 	addi	r2,fp,-24
  15159c:	10800044 	addi	r2,r2,1
  1515a0:	e13ff917 	ldw	r4,-28(fp)
  1515a4:	100b883a 	mov	r5,r2
  1515a8:	0151b140 	call	151b14 <cvt_num_field>

    /* add in the units */
    level_str[7] = 'V';
  1515ac:	00801584 	movi	r2,86
  1515b0:	e0bffbc5 	stb	r2,-17(fp)


    /* now finally display the trigger level */
    plot_string(x_pos, y_pos, level_str, style);
  1515b4:	e0bfff17 	ldw	r2,-4(fp)
  1515b8:	e0fffa04 	addi	r3,fp,-24
  1515bc:	e13ffd17 	ldw	r4,-12(fp)
  1515c0:	e17ffe17 	ldw	r5,-8(fp)
  1515c4:	180d883a 	mov	r6,r3
  1515c8:	100f883a 	mov	r7,r2
  1515cc:	01506900 	call	150690 <plot_string>


    /* all done displaying the trigger level - return */
    return;

}
  1515d0:	e037883a 	mov	sp,fp
  1515d4:	dfc00117 	ldw	ra,4(sp)
  1515d8:	df000017 	ldw	fp,0(sp)
  1515dc:	dec00204 	addi	sp,sp,8
  1515e0:	f800283a 	ret

001515e4 <set_trg_slope>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_slope(enum slope_type s)
{
  1515e4:	defffd04 	addi	sp,sp,-12
  1515e8:	dfc00215 	stw	ra,8(sp)
  1515ec:	df000115 	stw	fp,4(sp)
  1515f0:	df000104 	addi	fp,sp,4
  1515f4:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the slope type */
    slope = s;
  1515f8:	e0bfff17 	ldw	r2,-4(fp)
  1515fc:	d0a32b15 	stw	r2,-29524(gp)

    /* also tell the hardware what the slope is */
    set_trigger(level, slope);
  151600:	d0e32717 	ldw	r3,-29540(gp)
  151604:	d0a32b17 	ldw	r2,-29524(gp)
  151608:	1809883a 	mov	r4,r3
  15160c:	100b883a 	mov	r5,r2
  151610:	01539000 	call	153900 <set_trigger>


    /* all done setting the trigger slope - return */
    return;
  151614:	0001883a 	nop

}
  151618:	e037883a 	mov	sp,fp
  15161c:	dfc00117 	ldw	ra,4(sp)
  151620:	df000017 	ldw	fp,0(sp)
  151624:	dec00204 	addi	sp,sp,8
  151628:	f800283a 	ret

0015162c <trg_slope_toggle>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_slope_toggle()
{
  15162c:	defffe04 	addi	sp,sp,-8
  151630:	dfc00115 	stw	ra,4(sp)
  151634:	df000015 	stw	fp,0(sp)
  151638:	d839883a 	mov	fp,sp
      /* none */



    /* toggle the trigger slope */
    if (slope == SLOPE_POSITIVE)
  15163c:	d0a32b17 	ldw	r2,-29524(gp)
  151640:	1000031e 	bne	r2,zero,151650 <trg_slope_toggle+0x24>
        slope = SLOPE_NEGATIVE;
  151644:	00800044 	movi	r2,1
  151648:	d0a32b15 	stw	r2,-29524(gp)
  15164c:	00000106 	br	151654 <trg_slope_toggle+0x28>
    else
        slope = SLOPE_POSITIVE;
  151650:	d0232b15 	stw	zero,-29524(gp)

    /* set the new trigger slope */
    set_trigger(level, slope);
  151654:	d0e32717 	ldw	r3,-29540(gp)
  151658:	d0a32b17 	ldw	r2,-29524(gp)
  15165c:	1809883a 	mov	r4,r3
  151660:	100b883a 	mov	r5,r2
  151664:	01539000 	call	153900 <set_trigger>


    /* all done with the trigger slope - return */
    return;
  151668:	0001883a 	nop

}
  15166c:	e037883a 	mov	sp,fp
  151670:	dfc00117 	ldw	ra,4(sp)
  151674:	df000017 	ldw	fp,0(sp)
  151678:	dec00204 	addi	sp,sp,8
  15167c:	f800283a 	ret

00151680 <display_trg_slope>:
   Last Modified:    Mar. 13, 1994

*/

void  display_trg_slope(int x_pos, int y_pos, int style)
{
  151680:	defff904 	addi	sp,sp,-28
  151684:	dfc00615 	stw	ra,24(sp)
  151688:	df000515 	stw	fp,20(sp)
  15168c:	df000504 	addi	fp,sp,20
  151690:	e13ffd15 	stw	r4,-12(fp)
  151694:	e17ffe15 	stw	r5,-8(fp)
  151698:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* the trigger slope strings (must match enumerated type) */
    const char * const  slopes[] =  {  " +", " -"  };
  15169c:	00800574 	movhi	r2,21
  1516a0:	1098e604 	addi	r2,r2,25496
  1516a4:	e0bffb15 	stw	r2,-20(fp)
  1516a8:	00800574 	movhi	r2,21
  1516ac:	1098e704 	addi	r2,r2,25500
  1516b0:	e0bffc15 	stw	r2,-16(fp)



    /* display the trigger slope */
    plot_string(x_pos, y_pos, slopes[slope], style);
  1516b4:	d0a32b17 	ldw	r2,-29524(gp)
  1516b8:	1085883a 	add	r2,r2,r2
  1516bc:	1085883a 	add	r2,r2,r2
  1516c0:	e0fffb04 	addi	r3,fp,-20
  1516c4:	1885883a 	add	r2,r3,r2
  1516c8:	10c00017 	ldw	r3,0(r2)
  1516cc:	e0bfff17 	ldw	r2,-4(fp)
  1516d0:	e13ffd17 	ldw	r4,-12(fp)
  1516d4:	e17ffe17 	ldw	r5,-8(fp)
  1516d8:	180d883a 	mov	r6,r3
  1516dc:	100f883a 	mov	r7,r2
  1516e0:	01506900 	call	150690 <plot_string>


    /* all done displaying the trigger slope - return */
    return;

}
  1516e4:	e037883a 	mov	sp,fp
  1516e8:	dfc00117 	ldw	ra,4(sp)
  1516ec:	df000017 	ldw	fp,0(sp)
  1516f0:	dec00204 	addi	sp,sp,8
  1516f4:	f800283a 	ret

001516f8 <set_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_delay(long int d)
{
  1516f8:	defffd04 	addi	sp,sp,-12
  1516fc:	dfc00215 	stw	ra,8(sp)
  151700:	df000115 	stw	fp,4(sp)
  151704:	df000104 	addi	fp,sp,4
  151708:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger delay */
    delay = d;
  15170c:	e0bfff17 	ldw	r2,-4(fp)
  151710:	d0a32915 	stw	r2,-29532(gp)

    /* set the trigger delay in hardware too */
    set_delay(delay);
  151714:	d0a32917 	ldw	r2,-29532(gp)
  151718:	1009883a 	mov	r4,r2
  15171c:	015396c0 	call	15396c <set_delay>


    /* all done initializing the trigger delay - return */
    return;
  151720:	0001883a 	nop

}
  151724:	e037883a 	mov	sp,fp
  151728:	dfc00117 	ldw	ra,4(sp)
  15172c:	df000017 	ldw	fp,0(sp)
  151730:	dec00204 	addi	sp,sp,8
  151734:	f800283a 	ret

00151738 <trg_delay_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_down()
{
  151738:	defffe04 	addi	sp,sp,-8
  15173c:	dfc00115 	stw	ra,4(sp)
  151740:	df000015 	stw	fp,0(sp)
  151744:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger delay, if not already the minimum */
    if (delay > MIN_DELAY)
  151748:	d0a32917 	ldw	r2,-29532(gp)
  15174c:	10bfc450 	cmplti	r2,r2,-239
  151750:	1000031e 	bne	r2,zero,151760 <trg_delay_down+0x28>
        delay--;
  151754:	d0a32917 	ldw	r2,-29532(gp)
  151758:	10bfffc4 	addi	r2,r2,-1
  15175c:	d0a32915 	stw	r2,-29532(gp)

    /* set the trigger delay for the hardware */
    set_delay(delay);
  151760:	d0a32917 	ldw	r2,-29532(gp)
  151764:	1009883a 	mov	r4,r2
  151768:	015396c0 	call	15396c <set_delay>


    /* all done with lowering the trigger delay - return */
    return;
  15176c:	0001883a 	nop

}
  151770:	e037883a 	mov	sp,fp
  151774:	dfc00117 	ldw	ra,4(sp)
  151778:	df000017 	ldw	fp,0(sp)
  15177c:	dec00204 	addi	sp,sp,8
  151780:	f800283a 	ret

00151784 <trg_delay_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_up()
{
  151784:	defffe04 	addi	sp,sp,-8
  151788:	dfc00115 	stw	ra,4(sp)
  15178c:	df000015 	stw	fp,0(sp)
  151790:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger delay, if not already the maximum */
    if (delay < MAX_DELAY)
  151794:	d0a32917 	ldw	r2,-29532(gp)
  151798:	00f0d3d4 	movui	r3,49999
  15179c:	18800316 	blt	r3,r2,1517ac <trg_delay_up+0x28>
        delay++;
  1517a0:	d0a32917 	ldw	r2,-29532(gp)
  1517a4:	10800044 	addi	r2,r2,1
  1517a8:	d0a32915 	stw	r2,-29532(gp)

    /* tell the hardware the new trigger delay */
    set_delay(delay);
  1517ac:	d0a32917 	ldw	r2,-29532(gp)
  1517b0:	1009883a 	mov	r4,r2
  1517b4:	015396c0 	call	15396c <set_delay>


    /* all done raising the trigger delay - return */
    return;
  1517b8:	0001883a 	nop

}
  1517bc:	e037883a 	mov	sp,fp
  1517c0:	dfc00117 	ldw	ra,4(sp)
  1517c4:	df000017 	ldw	fp,0(sp)
  1517c8:	dec00204 	addi	sp,sp,8
  1517cc:	f800283a 	ret

001517d0 <adjust_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  adjust_trg_delay(int old_sweep, int new_sweep)
{
  1517d0:	defffc04 	addi	sp,sp,-16
  1517d4:	dfc00315 	stw	ra,12(sp)
  1517d8:	df000215 	stw	fp,8(sp)
  1517dc:	df000204 	addi	fp,sp,8
  1517e0:	e13ffe15 	stw	r4,-8(fp)
  1517e4:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* multiply by 10 times the ratio of sweep rates */
    delay *= (10 * sweep_rates[new_sweep].sample_rate) / sweep_rates[old_sweep].sample_rate;
  1517e8:	00c00574 	movhi	r3,21
  1517ec:	18d8ad04 	addi	r3,r3,25268
  1517f0:	e0bfff17 	ldw	r2,-4(fp)
  1517f4:	100490fa 	slli	r2,r2,3
  1517f8:	1885883a 	add	r2,r3,r2
  1517fc:	10800017 	ldw	r2,0(r2)
  151800:	10c002a4 	muli	r3,r2,10
  151804:	01000574 	movhi	r4,21
  151808:	2118ad04 	addi	r4,r4,25268
  15180c:	e0bffe17 	ldw	r2,-8(fp)
  151810:	100490fa 	slli	r2,r2,3
  151814:	2085883a 	add	r2,r4,r2
  151818:	10800017 	ldw	r2,0(r2)
  15181c:	1887283a 	div	r3,r3,r2
  151820:	d0a32917 	ldw	r2,-29532(gp)
  151824:	1885383a 	mul	r2,r3,r2
  151828:	d0a32915 	stw	r2,-29532(gp)
    /* now divide the factor of 10 back out */
    delay /= 10;
  15182c:	d0e32917 	ldw	r3,-29532(gp)
  151830:	00800284 	movi	r2,10
  151834:	1885283a 	div	r2,r3,r2
  151838:	d0a32915 	stw	r2,-29532(gp)

    /* make sure delay is not out of range */
    if (delay > MAX_DELAY)
  15183c:	d0a32917 	ldw	r2,-29532(gp)
  151840:	00f0d414 	movui	r3,50000
  151844:	1880020e 	bge	r3,r2,151850 <adjust_trg_delay+0x80>
        /* delay is too large - set to maximum */
        delay = MAX_DELAY;
  151848:	00b0d414 	movui	r2,50000
  15184c:	d0a32915 	stw	r2,-29532(gp)
    if (delay < MIN_DELAY)
  151850:	d0a32917 	ldw	r2,-29532(gp)
  151854:	10bfc408 	cmpgei	r2,r2,-240
  151858:	1000021e 	bne	r2,zero,151864 <adjust_trg_delay+0x94>
        /* delay is too small - set to minimum */
	delay = MIN_DELAY;
  15185c:	00bfc404 	movi	r2,-240
  151860:	d0a32915 	stw	r2,-29532(gp)


    /* tell the hardware the new trigger delay */
    set_delay(delay);
  151864:	d0a32917 	ldw	r2,-29532(gp)
  151868:	1009883a 	mov	r4,r2
  15186c:	015396c0 	call	15396c <set_delay>


    /* all done adjusting the trigger delay - return */
    return;
  151870:	0001883a 	nop

}
  151874:	e037883a 	mov	sp,fp
  151878:	dfc00117 	ldw	ra,4(sp)
  15187c:	df000017 	ldw	fp,0(sp)
  151880:	dec00204 	addi	sp,sp,8
  151884:	f800283a 	ret

00151888 <display_trg_delay>:
   Last Modified:    May 3, 2006

*/

void  display_trg_delay(int x_pos, int y_pos, int style)
{
  151888:	defff604 	addi	sp,sp,-40
  15188c:	dfc00915 	stw	ra,36(sp)
  151890:	df000815 	stw	fp,32(sp)
  151894:	df000804 	addi	fp,sp,32
  151898:	e13ffd15 	stw	r4,-12(fp)
  15189c:	e17ffe15 	stw	r5,-8(fp)
  1518a0:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      delay_str[] = "         "; /* string containing the trigger delay */
  1518a4:	00880834 	movhi	r2,8224
  1518a8:	10880804 	addi	r2,r2,8224
  1518ac:	e0bffa15 	stw	r2,-24(fp)
  1518b0:	00880834 	movhi	r2,8224
  1518b4:	10880804 	addi	r2,r2,8224
  1518b8:	e0bffb15 	stw	r2,-20(fp)
  1518bc:	00800804 	movi	r2,32
  1518c0:	e0bffc0d 	sth	r2,-16(fp)
    long int  d;                         /* delay in appropriate units */


    /* compute the delay in the appropriate units */
    /* have to watch out for overflow, so be careful */
    if (sweep_rates[sweep].sample_rate > 10000000L) {
  1518c4:	d0a32817 	ldw	r2,-29536(gp)
  1518c8:	00c00574 	movhi	r3,21
  1518cc:	18d8ad04 	addi	r3,r3,25268
  1518d0:	100490fa 	slli	r2,r2,3
  1518d4:	1885883a 	add	r2,r3,r2
  1518d8:	10800017 	ldw	r2,0(r2)
  1518dc:	00c02674 	movhi	r3,153
  1518e0:	18e5a004 	addi	r3,r3,-27008
  1518e4:	1880100e 	bge	r3,r2,151928 <display_trg_delay+0xa0>
    	d = delay * (1000000000L / sweep_rates[sweep].sample_rate);
  1518e8:	d0a32817 	ldw	r2,-29536(gp)
  1518ec:	00c00574 	movhi	r3,21
  1518f0:	18d8ad04 	addi	r3,r3,25268
  1518f4:	100490fa 	slli	r2,r2,3
  1518f8:	1885883a 	add	r2,r3,r2
  1518fc:	10800017 	ldw	r2,0(r2)
  151900:	00cee6f4 	movhi	r3,15259
  151904:	18f28004 	addi	r3,r3,-13824
  151908:	1887283a 	div	r3,r3,r2
  15190c:	d0a32917 	ldw	r2,-29532(gp)
  151910:	1885383a 	mul	r2,r3,r2
  151914:	e0bff915 	stw	r2,-28(fp)
    	/* need to divide by 1000000 to get milliseconds */
    	units_adj = 1000000;
  151918:	008003f4 	movhi	r2,15
  15191c:	10909004 	addi	r2,r2,16960
  151920:	e0bff815 	stw	r2,-32(fp)
  151924:	00002906 	br	1519cc <display_trg_delay+0x144>
    } else if (sweep_rates[sweep].sample_rate > 1000000L)  {
  151928:	d0a32817 	ldw	r2,-29536(gp)
  15192c:	00c00574 	movhi	r3,21
  151930:	18d8ad04 	addi	r3,r3,25268
  151934:	100490fa 	slli	r2,r2,3
  151938:	1885883a 	add	r2,r3,r2
  15193c:	10800017 	ldw	r2,0(r2)
  151940:	00c003f4 	movhi	r3,15
  151944:	18d09004 	addi	r3,r3,16960
  151948:	1880120e 	bge	r3,r2,151994 <display_trg_delay+0x10c>
        /* have a fast sweep rate, could overflow */
        /* first compute in units of 100 ns */
        d = delay * (10000000L / sweep_rates[sweep].sample_rate);
  15194c:	d0a32817 	ldw	r2,-29536(gp)
  151950:	00c00574 	movhi	r3,21
  151954:	18d8ad04 	addi	r3,r3,25268
  151958:	100490fa 	slli	r2,r2,3
  15195c:	1885883a 	add	r2,r3,r2
  151960:	10800017 	ldw	r2,0(r2)
  151964:	00c02674 	movhi	r3,153
  151968:	18e5a004 	addi	r3,r3,-27008
  15196c:	1887283a 	div	r3,r3,r2
  151970:	d0a32917 	ldw	r2,-29532(gp)
  151974:	1885383a 	mul	r2,r3,r2
  151978:	e0bff915 	stw	r2,-28(fp)
		/* now convert to nanoseconds */
		d *= 100L;
  15197c:	e0bff917 	ldw	r2,-28(fp)
  151980:	10801924 	muli	r2,r2,100
  151984:	e0bff915 	stw	r2,-28(fp)
		/* need to divide by 1000 to get to microseconds */
		units_adj = 1000;
  151988:	0080fa04 	movi	r2,1000
  15198c:	e0bff815 	stw	r2,-32(fp)
  151990:	00000e06 	br	1519cc <display_trg_delay+0x144>
    } else  {
        /* slow sweep rate, don't have to worry about overflow */
        d = delay * (1000000L / sweep_rates[sweep].sample_rate);
  151994:	d0a32817 	ldw	r2,-29536(gp)
  151998:	00c00574 	movhi	r3,21
  15199c:	18d8ad04 	addi	r3,r3,25268
  1519a0:	100490fa 	slli	r2,r2,3
  1519a4:	1885883a 	add	r2,r3,r2
  1519a8:	10800017 	ldw	r2,0(r2)
  1519ac:	00c003f4 	movhi	r3,15
  1519b0:	18d09004 	addi	r3,r3,16960
  1519b4:	1887283a 	div	r3,r3,r2
  1519b8:	d0a32917 	ldw	r2,-29532(gp)
  1519bc:	1885383a 	mul	r2,r3,r2
  1519c0:	e0bff915 	stw	r2,-28(fp)
		/* already in microseconds, so adjustment is 1 */
		units_adj = 1;
  1519c4:	00800044 	movi	r2,1
  1519c8:	e0bff815 	stw	r2,-32(fp)
    }

    /* convert it to the string (leave first character blank) */
    cvt_num_field(d, &delay_str[1]);
  1519cc:	e0bffa04 	addi	r2,fp,-24
  1519d0:	10800044 	addi	r2,r2,1
  1519d4:	e13ff917 	ldw	r4,-28(fp)
  1519d8:	100b883a 	mov	r5,r2
  1519dc:	0151b140 	call	151b14 <cvt_num_field>

    /* add in the units */
    if (units_adj == 1000000) {
  1519e0:	e0fff817 	ldw	r3,-32(fp)
  1519e4:	008003f4 	movhi	r2,15
  1519e8:	10909004 	addi	r2,r2,16960
  1519ec:	1880051e 	bne	r3,r2,151a04 <display_trg_delay+0x17c>
        /* delay is in nanoseconds */
		delay_str[7] = '\004';
  1519f0:	00800104 	movi	r2,4
  1519f4:	e0bffbc5 	stb	r2,-17(fp)
		delay_str[8] = 's';
  1519f8:	00801cc4 	movi	r2,115
  1519fc:	e0bffc05 	stb	r2,-16(fp)
  151a00:	00003806 	br	151ae4 <display_trg_delay+0x25c>
    } else if (((d / units_adj) < 1000) && ((d / units_adj) > -1000) && (units_adj == 1000)) {
  151a04:	e0fff917 	ldw	r3,-28(fp)
  151a08:	e0bff817 	ldw	r2,-32(fp)
  151a0c:	1885283a 	div	r2,r3,r2
  151a10:	1080fa08 	cmpgei	r2,r2,1000
  151a14:	10000d1e 	bne	r2,zero,151a4c <display_trg_delay+0x1c4>
  151a18:	e0fff917 	ldw	r3,-28(fp)
  151a1c:	e0bff817 	ldw	r2,-32(fp)
  151a20:	1885283a 	div	r2,r3,r2
  151a24:	10bf0650 	cmplti	r2,r2,-999
  151a28:	1000081e 	bne	r2,zero,151a4c <display_trg_delay+0x1c4>
  151a2c:	e0bff817 	ldw	r2,-32(fp)
  151a30:	1080fa18 	cmpnei	r2,r2,1000
  151a34:	1000051e 	bne	r2,zero,151a4c <display_trg_delay+0x1c4>
        /* delay is in microseconds */
		delay_str[7] = '\004';
  151a38:	00800104 	movi	r2,4
  151a3c:	e0bffbc5 	stb	r2,-17(fp)
		delay_str[8] = 's';
  151a40:	00801cc4 	movi	r2,115
  151a44:	e0bffc05 	stb	r2,-16(fp)
  151a48:	00002606 	br	151ae4 <display_trg_delay+0x25c>
    } else if (((d / units_adj) < 1000000) && ((d / units_adj) > -1000000)) {
  151a4c:	e0fff917 	ldw	r3,-28(fp)
  151a50:	e0bff817 	ldw	r2,-32(fp)
  151a54:	1885283a 	div	r2,r3,r2
  151a58:	00c003f4 	movhi	r3,15
  151a5c:	18d08fc4 	addi	r3,r3,16959
  151a60:	18800b16 	blt	r3,r2,151a90 <display_trg_delay+0x208>
  151a64:	e0fff917 	ldw	r3,-28(fp)
  151a68:	e0bff817 	ldw	r2,-32(fp)
  151a6c:	1887283a 	div	r3,r3,r2
  151a70:	00bffc74 	movhi	r2,65521
  151a74:	10af7044 	addi	r2,r2,-16959
  151a78:	18800516 	blt	r3,r2,151a90 <display_trg_delay+0x208>
        /* delay is in milliseconds */
		delay_str[7] = 'm';
  151a7c:	00801b44 	movi	r2,109
  151a80:	e0bffbc5 	stb	r2,-17(fp)
		delay_str[8] = 's';
  151a84:	00801cc4 	movi	r2,115
  151a88:	e0bffc05 	stb	r2,-16(fp)
  151a8c:	00001506 	br	151ae4 <display_trg_delay+0x25c>
    } else if (((d / units_adj) < 1000000000) && ((d / units_adj) > -1000000000))  {
  151a90:	e0fff917 	ldw	r3,-28(fp)
  151a94:	e0bff817 	ldw	r2,-32(fp)
  151a98:	1885283a 	div	r2,r3,r2
  151a9c:	00cee6f4 	movhi	r3,15259
  151aa0:	18f27fc4 	addi	r3,r3,-13825
  151aa4:	18800b16 	blt	r3,r2,151ad4 <display_trg_delay+0x24c>
  151aa8:	e0fff917 	ldw	r3,-28(fp)
  151aac:	e0bff817 	ldw	r2,-32(fp)
  151ab0:	1887283a 	div	r3,r3,r2
  151ab4:	00b11974 	movhi	r2,50277
  151ab8:	108d8044 	addi	r2,r2,13825
  151abc:	18800516 	blt	r3,r2,151ad4 <display_trg_delay+0x24c>
        /* delay is in seconds */
		delay_str[7] = 's';
  151ac0:	00801cc4 	movi	r2,115
  151ac4:	e0bffbc5 	stb	r2,-17(fp)
		delay_str[8] = ' ';
  151ac8:	00800804 	movi	r2,32
  151acc:	e0bffc05 	stb	r2,-16(fp)
  151ad0:	00000406 	br	151ae4 <display_trg_delay+0x25c>
    } else  {
        /* delay is in kiloseconds */
		delay_str[7] = 'k';
  151ad4:	00801ac4 	movi	r2,107
  151ad8:	e0bffbc5 	stb	r2,-17(fp)
		delay_str[8] = 's';
  151adc:	00801cc4 	movi	r2,115
  151ae0:	e0bffc05 	stb	r2,-16(fp)
    }


    /* now actually display the trigger delay */
    plot_string(x_pos, y_pos, delay_str, style);
  151ae4:	e0bfff17 	ldw	r2,-4(fp)
  151ae8:	e0fffa04 	addi	r3,fp,-24
  151aec:	e13ffd17 	ldw	r4,-12(fp)
  151af0:	e17ffe17 	ldw	r5,-8(fp)
  151af4:	180d883a 	mov	r6,r3
  151af8:	100f883a 	mov	r7,r2
  151afc:	01506900 	call	150690 <plot_string>


    /* all done displaying the trigger delay - return */
    return;

}
  151b00:	e037883a 	mov	sp,fp
  151b04:	dfc00117 	ldw	ra,4(sp)
  151b08:	df000017 	ldw	fp,0(sp)
  151b0c:	dec00204 	addi	sp,sp,8
  151b10:	f800283a 	ret

00151b14 <cvt_num_field>:
   Last Modified:    Mar. 8, 1994

*/

void  cvt_num_field(long int n, char *s)
{
  151b14:	defffa04 	addi	sp,sp,-24
  151b18:	df000515 	stw	fp,20(sp)
  151b1c:	df000504 	addi	fp,sp,20
  151b20:	e13ffe15 	stw	r4,-8(fp)
  151b24:	e17fff15 	stw	r5,-4(fp)
    /* variables */
    int  dp = 3;		/* digits to right of decimal point */
  151b28:	008000c4 	movi	r2,3
  151b2c:	e0bffb15 	stw	r2,-20(fp)
    int  d;			/* digit weight (power of 10) */

    int  i = 0;			/* string index */
  151b30:	e03ffd15 	stw	zero,-12(fp)



    /* first get the sign (and make n positive for conversion) */
    if (n < 0)  {
  151b34:	e0bffe17 	ldw	r2,-8(fp)
  151b38:	10000c0e 	bge	r2,zero,151b6c <cvt_num_field+0x58>
        /* n is negative, set sign and convert to positive */
	s[i++] = '-';
  151b3c:	e0bffd17 	ldw	r2,-12(fp)
  151b40:	e0ffff17 	ldw	r3,-4(fp)
  151b44:	1885883a 	add	r2,r3,r2
  151b48:	00c00b44 	movi	r3,45
  151b4c:	10c00005 	stb	r3,0(r2)
  151b50:	e0bffd17 	ldw	r2,-12(fp)
  151b54:	10800044 	addi	r2,r2,1
  151b58:	e0bffd15 	stw	r2,-12(fp)
	n = -n;
  151b5c:	e0bffe17 	ldw	r2,-8(fp)
  151b60:	0085c83a 	sub	r2,zero,r2
  151b64:	e0bffe15 	stw	r2,-8(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  151b68:	00001006 	br	151bac <cvt_num_field+0x98>
	s[i++] = '-';
	n = -n;
    }
    else  {
        /* n is positive, set sign only */
	s[i++] = '+';
  151b6c:	e0bffd17 	ldw	r2,-12(fp)
  151b70:	e0ffff17 	ldw	r3,-4(fp)
  151b74:	1885883a 	add	r2,r3,r2
  151b78:	00c00ac4 	movi	r3,43
  151b7c:	10c00005 	stb	r3,0(r2)
  151b80:	e0bffd17 	ldw	r2,-12(fp)
  151b84:	10800044 	addi	r2,r2,1
  151b88:	e0bffd15 	stw	r2,-12(fp)
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  151b8c:	00000706 	br	151bac <cvt_num_field+0x98>
        /* have more than 4 digits - get rid of one */
	n /= 10;
  151b90:	e0fffe17 	ldw	r3,-8(fp)
  151b94:	00800284 	movi	r2,10
  151b98:	1885283a 	div	r2,r3,r2
  151b9c:	e0bffe15 	stw	r2,-8(fp)
	/* adjust the decimal point */
	dp--;
  151ba0:	e0bffb17 	ldw	r2,-20(fp)
  151ba4:	10bfffc4 	addi	r2,r2,-1
  151ba8:	e0bffb15 	stw	r2,-20(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  151bac:	e0bffe17 	ldw	r2,-8(fp)
  151bb0:	1089c408 	cmpgei	r2,r2,10000
  151bb4:	103ff61e 	bne	r2,zero,151b90 <cvt_num_field+0x7c>
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  151bb8:	00000306 	br	151bc8 <cvt_num_field+0xb4>
       dp += 3;
  151bbc:	e0bffb17 	ldw	r2,-20(fp)
  151bc0:	108000c4 	addi	r2,r2,3
  151bc4:	e0bffb15 	stw	r2,-20(fp)
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  151bc8:	e0bffb17 	ldw	r2,-20(fp)
  151bcc:	00bffb0e 	bge	zero,r2,151bbc <cvt_num_field+0xa8>
       dp += 3;


    /* adjust dp to be digits to the right of the decimal point */
    /* (assuming 4 digits) */
    dp = 4 - dp;
  151bd0:	00c00104 	movi	r3,4
  151bd4:	e0bffb17 	ldw	r2,-20(fp)
  151bd8:	1885c83a 	sub	r2,r3,r2
  151bdc:	e0bffb15 	stw	r2,-20(fp)


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  151be0:	0080fa04 	movi	r2,1000
  151be4:	e0bffc15 	stw	r2,-16(fp)
  151be8:	00002506 	br	151c80 <cvt_num_field+0x16c>

        /* check if need decimal the decimal point now */
	if (dp-- == 0)
  151bec:	e0bffb17 	ldw	r2,-20(fp)
  151bf0:	1005003a 	cmpeq	r2,r2,zero
  151bf4:	e0fffb17 	ldw	r3,-20(fp)
  151bf8:	18ffffc4 	addi	r3,r3,-1
  151bfc:	e0fffb15 	stw	r3,-20(fp)
  151c00:	10803fcc 	andi	r2,r2,255
  151c04:	10000826 	beq	r2,zero,151c28 <cvt_num_field+0x114>
	    /* time for decimal point */
	    s[i++] = '.';
  151c08:	e0bffd17 	ldw	r2,-12(fp)
  151c0c:	e0ffff17 	ldw	r3,-4(fp)
  151c10:	1885883a 	add	r2,r3,r2
  151c14:	00c00b84 	movi	r3,46
  151c18:	10c00005 	stb	r3,0(r2)
  151c1c:	e0bffd17 	ldw	r2,-12(fp)
  151c20:	10800044 	addi	r2,r2,1
  151c24:	e0bffd15 	stw	r2,-12(fp)

	/* get and convert this digit */
	s[i++] = (n / d) + '0';
  151c28:	e0bffd17 	ldw	r2,-12(fp)
  151c2c:	e0ffff17 	ldw	r3,-4(fp)
  151c30:	1885883a 	add	r2,r3,r2
  151c34:	e13ffe17 	ldw	r4,-8(fp)
  151c38:	e0fffc17 	ldw	r3,-16(fp)
  151c3c:	20c7283a 	div	r3,r4,r3
  151c40:	18c00c04 	addi	r3,r3,48
  151c44:	10c00005 	stb	r3,0(r2)
  151c48:	e0bffd17 	ldw	r2,-12(fp)
  151c4c:	10800044 	addi	r2,r2,1
  151c50:	e0bffd15 	stw	r2,-12(fp)
	/* remove this digit from n */
	n %= d;
  151c54:	e0bffe17 	ldw	r2,-8(fp)
  151c58:	e0fffc17 	ldw	r3,-16(fp)
  151c5c:	10c9283a 	div	r4,r2,r3
  151c60:	e0fffc17 	ldw	r3,-16(fp)
  151c64:	20c7383a 	mul	r3,r4,r3
  151c68:	10c5c83a 	sub	r2,r2,r3
  151c6c:	e0bffe15 	stw	r2,-8(fp)
    /* (assuming 4 digits) */
    dp = 4 - dp;


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  151c70:	e0fffc17 	ldw	r3,-16(fp)
  151c74:	00800284 	movi	r2,10
  151c78:	1885283a 	div	r2,r3,r2
  151c7c:	e0bffc15 	stw	r2,-16(fp)
  151c80:	e0bffc17 	ldw	r2,-16(fp)
  151c84:	00bfd916 	blt	zero,r2,151bec <cvt_num_field+0xd8>
	n %= d;
    }


    /* all done converting the number, return */
    return;
  151c88:	0001883a 	nop

}
  151c8c:	e037883a 	mov	sp,fp
  151c90:	df000017 	ldw	fp,0(sp)
  151c94:	dec00104 	addi	sp,sp,4
  151c98:	f800283a 	ret

00151c9c <get_test_sample>:
   Last Modified:    May 3, 2006

*/

void  get_test_sample(long int sample_rate, int sample_size, unsigned char *sample)
{
  151c9c:	deff8104 	addi	sp,sp,-508
  151ca0:	dfc07e15 	stw	ra,504(sp)
  151ca4:	df007d15 	stw	fp,500(sp)
  151ca8:	df007d04 	addi	fp,sp,500
  151cac:	e13ffd15 	stw	r4,-12(fp)
  151cb0:	e17ffe15 	stw	r5,-8(fp)
  151cb4:	e1bfff15 	stw	r6,-4(fp)
    /* variables */

    /* a half-cycle of the ringing square wave */
    const unsigned char  waveform[] =
  151cb8:	00800574 	movhi	r2,21
  151cbc:	1098e804 	addi	r2,r2,25504
  151cc0:	e13f8504 	addi	r4,fp,-492
  151cc4:	1007883a 	mov	r3,r2
  151cc8:	00807804 	movi	r2,480
  151ccc:	180b883a 	mov	r5,r3
  151cd0:	100d883a 	mov	r6,r2
  151cd4:	0153ccc0 	call	153ccc <memcpy>
	    63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
	    63,  63,  63,  63,  63,  63,  64,  64,  64,  64,  64,  64,  64,
	    64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64
	  };

    long int  sample_pt = 0;	/* current sample within the waveform */
  151cd8:	e03f8315 	stw	zero,-500(fp)

    int       sample_sign = 1;	/* sample waveform sign */
  151cdc:	00800044 	movi	r2,1
  151ce0:	e0bf8415 	stw	r2,-496(fp)



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  151ce4:	00002f06 	br	151da4 <get_test_sample+0x108>

        /* get this sample point (value based on sign) */
	if (sample_sign > 0)
  151ce8:	e0bf8417 	ldw	r2,-496(fp)
  151cec:	00800e0e 	bge	zero,r2,151d28 <get_test_sample+0x8c>
	    *sample++ = waveform[sample_pt/20] + 127;
  151cf0:	e0ff8317 	ldw	r3,-500(fp)
  151cf4:	00800504 	movi	r2,20
  151cf8:	1885283a 	div	r2,r3,r2
  151cfc:	e0ff8504 	addi	r3,fp,-492
  151d00:	1885883a 	add	r2,r3,r2
  151d04:	10800003 	ldbu	r2,0(r2)
  151d08:	10801fc4 	addi	r2,r2,127
  151d0c:	1007883a 	mov	r3,r2
  151d10:	e0bfff17 	ldw	r2,-4(fp)
  151d14:	10c00005 	stb	r3,0(r2)
  151d18:	e0bfff17 	ldw	r2,-4(fp)
  151d1c:	10800044 	addi	r2,r2,1
  151d20:	e0bfff15 	stw	r2,-4(fp)
  151d24:	00000e06 	br	151d60 <get_test_sample+0xc4>
	else
	    *sample++ = 128 - waveform[sample_pt/20];
  151d28:	e0ff8317 	ldw	r3,-500(fp)
  151d2c:	00800504 	movi	r2,20
  151d30:	1885283a 	div	r2,r3,r2
  151d34:	e0ff8504 	addi	r3,fp,-492
  151d38:	1885883a 	add	r2,r3,r2
  151d3c:	10800003 	ldbu	r2,0(r2)
  151d40:	00ffe004 	movi	r3,-128
  151d44:	1885c83a 	sub	r2,r3,r2
  151d48:	1007883a 	mov	r3,r2
  151d4c:	e0bfff17 	ldw	r2,-4(fp)
  151d50:	10c00005 	stb	r3,0(r2)
  151d54:	e0bfff17 	ldw	r2,-4(fp)
  151d58:	10800044 	addi	r2,r2,1
  151d5c:	e0bfff15 	stw	r2,-4(fp)

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
  151d60:	00c02674 	movhi	r3,153
  151d64:	18e5a004 	addi	r3,r3,-27008
  151d68:	e0bffd17 	ldw	r2,-12(fp)
  151d6c:	1885283a 	div	r2,r3,r2
  151d70:	e0ff8317 	ldw	r3,-500(fp)
  151d74:	1885883a 	add	r2,r3,r2
  151d78:	e0bf8315 	stw	r2,-500(fp)
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  151d7c:	00000606 	br	151d98 <get_test_sample+0xfc>
	    /* keep sample_pt within the test waveform */
	    sample_pt -= (20 * NO_TEST_PTS);
  151d80:	e0bf8317 	ldw	r2,-500(fp)
  151d84:	10b6a004 	addi	r2,r2,-9600
  151d88:	e0bf8315 	stw	r2,-500(fp)
	    /* each time through the waveform, invert it */
	    sample_sign = -sample_sign;
  151d8c:	e0bf8417 	ldw	r2,-496(fp)
  151d90:	0085c83a 	sub	r2,zero,r2
  151d94:	e0bf8415 	stw	r2,-496(fp)
	    *sample++ = 128 - waveform[sample_pt/20];

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  151d98:	e0bf8317 	ldw	r2,-500(fp)
  151d9c:	10896028 	cmpgeui	r2,r2,9600
  151da0:	103ff71e 	bne	r2,zero,151d80 <get_test_sample+0xe4>
    int       sample_sign = 1;	/* sample waveform sign */



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  151da4:	e0bffe17 	ldw	r2,-8(fp)
  151da8:	0084803a 	cmplt	r2,zero,r2
  151dac:	e0fffe17 	ldw	r3,-8(fp)
  151db0:	18ffffc4 	addi	r3,r3,-1
  151db4:	e0fffe15 	stw	r3,-8(fp)
  151db8:	10803fcc 	andi	r2,r2,255
  151dbc:	103fca1e 	bne	r2,zero,151ce8 <get_test_sample+0x4c>


    /* done getting the sample - return */
    return;

}
  151dc0:	e037883a 	mov	sp,fp
  151dc4:	dfc00117 	ldw	ra,4(sp)
  151dc8:	df000017 	ldw	fp,0(sp)
  151dcc:	dec00204 	addi	sp,sp,8
  151dd0:	f800283a 	ret

00151dd4 <init_trace>:
   Last Modified:    May 9, 2006

*/

void  init_trace()
{
  151dd4:	defffe04 	addi	sp,sp,-8
  151dd8:	dfc00115 	stw	ra,4(sp)
  151ddc:	df000015 	stw	fp,0(sp)
  151de0:	d839883a 	mov	fp,sp


    /* initialize system status variables */

    /* ready for a trace */
    trace_status = TRUE;
  151de4:	00800044 	movi	r2,1
  151de8:	d0a32d15 	stw	r2,-29516(gp)

    /* not currently sampling data */
    sampling = FALSE;
  151dec:	d0233315 	stw	zero,-29492(gp)

    /* turn off the displayed scale */
    cur_scale = SCALE_NONE;
  151df0:	d0232c15 	stw	zero,-29520(gp)

    /* sample size is the screen size */
    sample_size = SIZE_X;
  151df4:	00807804 	movi	r2,480
  151df8:	d0a33015 	stw	r2,-29504(gp)


    /* clear save areas */
    clear_saved_areas();
  151dfc:	01523280 	call	152328 <clear_saved_areas>

    /* also clear the general saved area location variables (off-screen) */
    saved_pos_x = SIZE_X + 1;
  151e00:	00807844 	movi	r2,481
  151e04:	d0a33215 	stw	r2,-29496(gp)
    saved_pos_y = SIZE_Y + 1;
  151e08:	00804444 	movi	r2,273
  151e0c:	d0a32f15 	stw	r2,-29508(gp)
    saved_end_x = SIZE_X + 1;
  151e10:	00807844 	movi	r2,481
  151e14:	d0a33115 	stw	r2,-29500(gp)
    saved_end_y = SIZE_Y + 1;
  151e18:	00804444 	movi	r2,273
  151e1c:	d0a32e15 	stw	r2,-29512(gp)


    /* done initializing, return */
    return;
  151e20:	0001883a 	nop

}
  151e24:	e037883a 	mov	sp,fp
  151e28:	dfc00117 	ldw	ra,4(sp)
  151e2c:	df000017 	ldw	fp,0(sp)
  151e30:	dec00204 	addi	sp,sp,8
  151e34:	f800283a 	ret

00151e38 <set_mode>:
   Last Modified:    May 27, 2008

*/

void  set_mode(enum trigger_type trigger_mode)
{
  151e38:	defffe04 	addi	sp,sp,-8
  151e3c:	df000115 	stw	fp,4(sp)
  151e40:	df000104 	addi	fp,sp,4
  151e44:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* if not one-shot triggering - ready for trace too */
    trace_status = (trigger_mode != ONESHOT_TRIGGER);
  151e48:	e0bfff17 	ldw	r2,-4(fp)
  151e4c:	10800098 	cmpnei	r2,r2,2
  151e50:	10803fcc 	andi	r2,r2,255
  151e54:	d0a32d15 	stw	r2,-29516(gp)


    /* turn off the sampling flag so will start a new sample */
    sampling = FALSE;
  151e58:	d0233315 	stw	zero,-29492(gp)


    /* all done, return */
    return;
  151e5c:	0001883a 	nop

}
  151e60:	e037883a 	mov	sp,fp
  151e64:	df000017 	ldw	fp,0(sp)
  151e68:	dec00104 	addi	sp,sp,4
  151e6c:	f800283a 	ret

00151e70 <is_sampling>:
   Last Modified:    May 27, 2008

*/

int  is_sampling()
{
  151e70:	deffff04 	addi	sp,sp,-4
  151e74:	df000015 	stw	fp,0(sp)
  151e78:	d839883a 	mov	fp,sp
      /* none */



    /* currently sampling if sampling flag is set */
    return  sampling;
  151e7c:	d0a33317 	ldw	r2,-29492(gp)

}
  151e80:	e037883a 	mov	sp,fp
  151e84:	df000017 	ldw	fp,0(sp)
  151e88:	dec00104 	addi	sp,sp,4
  151e8c:	f800283a 	ret

00151e90 <trace_rdy>:
   Last Modified:    Mar. 13, 1994

*/

int  trace_rdy()
{
  151e90:	deffff04 	addi	sp,sp,-4
  151e94:	df000015 	stw	fp,0(sp)
  151e98:	d839883a 	mov	fp,sp
      /* none */



    /* ready for another trace if not sampling and trace is ready */
    return  (!sampling && trace_status);
  151e9c:	d0a33317 	ldw	r2,-29492(gp)
  151ea0:	1000041e 	bne	r2,zero,151eb4 <trace_rdy+0x24>
  151ea4:	d0a32d17 	ldw	r2,-29516(gp)
  151ea8:	10000226 	beq	r2,zero,151eb4 <trace_rdy+0x24>
  151eac:	00800044 	movi	r2,1
  151eb0:	00000106 	br	151eb8 <trace_rdy+0x28>
  151eb4:	0005883a 	mov	r2,zero

}
  151eb8:	e037883a 	mov	sp,fp
  151ebc:	df000017 	ldw	fp,0(sp)
  151ec0:	dec00104 	addi	sp,sp,4
  151ec4:	f800283a 	ret

00151ec8 <trace_done>:
   Last Modified:    May 9, 2006

*/

void  trace_done()
{
  151ec8:	defffe04 	addi	sp,sp,-8
  151ecc:	dfc00115 	stw	ra,4(sp)
  151ed0:	df000015 	stw	fp,0(sp)
  151ed4:	d839883a 	mov	fp,sp
      /* none */



    /* done with a trace - if retriggering, ready for another one */
    if (get_trigger_mode() != ONESHOT_TRIGGER)
  151ed8:	0150f9c0 	call	150f9c <get_trigger_mode>
  151edc:	108000a0 	cmpeqi	r2,r2,2
  151ee0:	1000021e 	bne	r2,zero,151eec <trace_done+0x24>
        /* in a retriggering mode - set trace_status to TRUE (ready) */
	trace_status = TRUE;
  151ee4:	00800044 	movi	r2,1
  151ee8:	d0a32d15 	stw	r2,-29516(gp)

    /* no longer sampling data */
    sampling = FALSE;
  151eec:	d0233315 	stw	zero,-29492(gp)


    /* done so return */
    return;
  151ef0:	0001883a 	nop

}
  151ef4:	e037883a 	mov	sp,fp
  151ef8:	dfc00117 	ldw	ra,4(sp)
  151efc:	df000017 	ldw	fp,0(sp)
  151f00:	dec00204 	addi	sp,sp,8
  151f04:	f800283a 	ret

00151f08 <trace_rearm>:
   Last Modified:    Mar. 8, 1994

*/

void  trace_rearm()
{
  151f08:	deffff04 	addi	sp,sp,-4
  151f0c:	df000015 	stw	fp,0(sp)
  151f10:	d839883a 	mov	fp,sp
      /* none */



    /* rearm the trace - set status to ready (TRUE) */
    trace_status = TRUE;
  151f14:	00800044 	movi	r2,1
  151f18:	d0a32d15 	stw	r2,-29516(gp)


    /* all done - return */
    return;
  151f1c:	0001883a 	nop

}
  151f20:	e037883a 	mov	sp,fp
  151f24:	df000017 	ldw	fp,0(sp)
  151f28:	dec00104 	addi	sp,sp,4
  151f2c:	f800283a 	ret

00151f30 <set_trace_size>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trace_size(int size)
{
  151f30:	defffe04 	addi	sp,sp,-8
  151f34:	df000115 	stw	fp,4(sp)
  151f38:	df000104 	addi	fp,sp,4
  151f3c:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the locally global sample size */
    sample_size = size;
  151f40:	e0bfff17 	ldw	r2,-4(fp)
  151f44:	d0a33015 	stw	r2,-29504(gp)


    /* all done, return */
    return;
  151f48:	0001883a 	nop

}
  151f4c:	e037883a 	mov	sp,fp
  151f50:	df000017 	ldw	fp,0(sp)
  151f54:	dec00104 	addi	sp,sp,4
  151f58:	f800283a 	ret

00151f5c <set_display_scale>:
   Last Modified:    May 9, 2006

*/

void  set_display_scale(enum scale_type scale)
{
  151f5c:	defffa04 	addi	sp,sp,-24
  151f60:	dfc00515 	stw	ra,20(sp)
  151f64:	df000415 	stw	fp,16(sp)
  151f68:	df000404 	addi	fp,sp,16
  151f6c:	e13fff15 	stw	r4,-4(fp)



    /* whenever change scale type, need to clear out previous scale */
    /* unnecessary if going to SCALE_GRID or from SCALE_NONE or not changing the scale */
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {
  151f70:	e0bfff17 	ldw	r2,-4(fp)
  151f74:	108000a0 	cmpeqi	r2,r2,2
  151f78:	10008d1e 	bne	r2,zero,1521b0 <set_display_scale+0x254>
  151f7c:	d0a32c17 	ldw	r2,-29520(gp)
  151f80:	10008b26 	beq	r2,zero,1521b0 <set_display_scale+0x254>
  151f84:	d0a32c17 	ldw	r2,-29520(gp)
  151f88:	e0ffff17 	ldw	r3,-4(fp)
  151f8c:	18808826 	beq	r3,r2,1521b0 <set_display_scale+0x254>

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  151f90:	00bfff84 	movi	r2,-2
  151f94:	e0bffe15 	stw	r2,-8(fp)
  151f98:	00003e06 	br	152094 <set_display_scale+0x138>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  151f9c:	e0bffe17 	ldw	r2,-8(fp)
  151fa0:	10800c24 	muli	r2,r2,48
  151fa4:	10802204 	addi	r2,r2,136
  151fa8:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  151fac:	e0bffc17 	ldw	r2,-16(fp)
  151fb0:	10804410 	cmplti	r2,r2,272
  151fb4:	1000021e 	bne	r2,zero,151fc0 <set_display_scale+0x64>
	        p = PLOT_SIZE_Y - 1;
  151fb8:	008043c4 	movi	r2,271
  151fbc:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  151fc0:	e0bffc17 	ldw	r2,-16(fp)
  151fc4:	1000010e 	bge	r2,zero,151fcc <set_display_scale+0x70>
	        p = 0;
  151fc8:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  151fcc:	e03ffd15 	stw	zero,-12(fp)
  151fd0:	00002a06 	br	15207c <set_display_scale+0x120>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_x[j + Y_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  151fd4:	e0bffe17 	ldw	r2,-8(fp)
  151fd8:	11000084 	addi	r4,r2,2
  151fdc:	e0bffd17 	ldw	r2,-12(fp)
  151fe0:	1000010e 	bge	r2,zero,151fe8 <set_display_scale+0x8c>
  151fe4:	108001c4 	addi	r2,r2,7
  151fe8:	1005d0fa 	srai	r2,r2,3
  151fec:	00c005b4 	movhi	r3,22
  151ff0:	18ea1484 	addi	r3,r3,-22446
  151ff4:	21000f24 	muli	r4,r4,60
  151ff8:	2085883a 	add	r2,r4,r2
  151ffc:	1885883a 	add	r2,r3,r2
  152000:	10800003 	ldbu	r2,0(r2)
  152004:	10c03fcc 	andi	r3,r2,255
  152008:	e13ffd17 	ldw	r4,-12(fp)
  15200c:	00a00034 	movhi	r2,32768
  152010:	108001c4 	addi	r2,r2,7
  152014:	2084703a 	and	r2,r4,r2
  152018:	1000040e 	bge	r2,zero,15202c <set_display_scale+0xd0>
  15201c:	10bfffc4 	addi	r2,r2,-1
  152020:	013ffe04 	movi	r4,-8
  152024:	1104b03a 	or	r2,r2,r4
  152028:	10800044 	addi	r2,r2,1
  15202c:	01002004 	movi	r4,128
  152030:	2085d83a 	sra	r2,r4,r2
  152034:	1884703a 	and	r2,r3,r2
  152038:	1000071e 	bne	r2,zero,152058 <set_display_scale+0xfc>
		    /* saved pixel is off */
		    plot_pixel(i, p, PIXEL_BGND);
  15203c:	e0fffd17 	ldw	r3,-12(fp)
  152040:	e0bffc17 	ldw	r2,-16(fp)
  152044:	1809883a 	mov	r4,r3
  152048:	100b883a 	mov	r5,r2
  15204c:	01800704 	movi	r6,28
  152050:	01537dc0 	call	1537dc <plot_pixel>
  152054:	00000606 	br	152070 <set_display_scale+0x114>
		else
		    /* saved pixel is on */
		    plot_pixel(i, p, PIXEL_RED);
  152058:	e0fffd17 	ldw	r3,-12(fp)
  15205c:	e0bffc17 	ldw	r2,-16(fp)
  152060:	1809883a 	mov	r4,r3
  152064:	100b883a 	mov	r5,r2
  152068:	0187c004 	movi	r6,7936
  15206c:	01537dc0 	call	1537dc <plot_pixel>
	        p = PLOT_SIZE_Y - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  152070:	e0bffd17 	ldw	r2,-12(fp)
  152074:	10800044 	addi	r2,r2,1
  152078:	e0bffd15 	stw	r2,-12(fp)
  15207c:	e0bffd17 	ldw	r2,-12(fp)
  152080:	10807810 	cmplti	r2,r2,480
  152084:	103fd31e 	bne	r2,zero,151fd4 <set_display_scale+0x78>
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  152088:	e0bffe17 	ldw	r2,-8(fp)
  15208c:	10800044 	addi	r2,r2,1
  152090:	e0bffe15 	stw	r2,-8(fp)
  152094:	e0bffe17 	ldw	r2,-8(fp)
  152098:	108000d0 	cmplti	r2,r2,3
  15209c:	103fbf1e 	bne	r2,zero,151f9c <set_display_scale+0x40>
		    plot_pixel(i, p, PIXEL_RED);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  1520a0:	00bffec4 	movi	r2,-5
  1520a4:	e0bffe15 	stw	r2,-8(fp)
  1520a8:	00003e06 	br	1521a4 <set_display_scale+0x248>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  1520ac:	e0bffe17 	ldw	r2,-8(fp)
  1520b0:	10800c24 	muli	r2,r2,48
  1520b4:	10803c04 	addi	r2,r2,240
  1520b8:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  1520bc:	e0bffc17 	ldw	r2,-16(fp)
  1520c0:	10807810 	cmplti	r2,r2,480
  1520c4:	1000021e 	bne	r2,zero,1520d0 <set_display_scale+0x174>
	        p = PLOT_SIZE_X - 1;
  1520c8:	008077c4 	movi	r2,479
  1520cc:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  1520d0:	e0bffc17 	ldw	r2,-16(fp)
  1520d4:	1000010e 	bge	r2,zero,1520dc <set_display_scale+0x180>
	        p = 0;
  1520d8:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  1520dc:	e03ffd15 	stw	zero,-12(fp)
  1520e0:	00002a06 	br	15218c <set_display_scale+0x230>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_y[j + X_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  1520e4:	e0bffe17 	ldw	r2,-8(fp)
  1520e8:	11000144 	addi	r4,r2,5
  1520ec:	e0bffd17 	ldw	r2,-12(fp)
  1520f0:	1000010e 	bge	r2,zero,1520f8 <set_display_scale+0x19c>
  1520f4:	108001c4 	addi	r2,r2,7
  1520f8:	1005d0fa 	srai	r2,r2,3
  1520fc:	00c005b4 	movhi	r3,22
  152100:	18e9b704 	addi	r3,r3,-22820
  152104:	210008a4 	muli	r4,r4,34
  152108:	2085883a 	add	r2,r4,r2
  15210c:	1885883a 	add	r2,r3,r2
  152110:	10800003 	ldbu	r2,0(r2)
  152114:	10c03fcc 	andi	r3,r2,255
  152118:	e13ffd17 	ldw	r4,-12(fp)
  15211c:	00a00034 	movhi	r2,32768
  152120:	108001c4 	addi	r2,r2,7
  152124:	2084703a 	and	r2,r4,r2
  152128:	1000040e 	bge	r2,zero,15213c <set_display_scale+0x1e0>
  15212c:	10bfffc4 	addi	r2,r2,-1
  152130:	013ffe04 	movi	r4,-8
  152134:	1104b03a 	or	r2,r2,r4
  152138:	10800044 	addi	r2,r2,1
  15213c:	01002004 	movi	r4,128
  152140:	2085d83a 	sra	r2,r4,r2
  152144:	1884703a 	and	r2,r3,r2
  152148:	1000071e 	bne	r2,zero,152168 <set_display_scale+0x20c>
		    /* saved pixel is off */
		    plot_pixel(p, i, PIXEL_BGND);
  15214c:	e0fffc17 	ldw	r3,-16(fp)
  152150:	e0bffd17 	ldw	r2,-12(fp)
  152154:	1809883a 	mov	r4,r3
  152158:	100b883a 	mov	r5,r2
  15215c:	01800704 	movi	r6,28
  152160:	01537dc0 	call	1537dc <plot_pixel>
  152164:	00000606 	br	152180 <set_display_scale+0x224>
		else
		    /* saved pixel is on */
		    plot_pixel(p, i, PIXEL_RED);
  152168:	e0fffc17 	ldw	r3,-16(fp)
  15216c:	e0bffd17 	ldw	r2,-12(fp)
  152170:	1809883a 	mov	r4,r3
  152174:	100b883a 	mov	r5,r2
  152178:	0187c004 	movi	r6,7936
  15217c:	01537dc0 	call	1537dc <plot_pixel>
	        p = PLOT_SIZE_X - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  152180:	e0bffd17 	ldw	r2,-12(fp)
  152184:	10800044 	addi	r2,r2,1
  152188:	e0bffd15 	stw	r2,-12(fp)
  15218c:	e0bffd17 	ldw	r2,-12(fp)
  152190:	10804410 	cmplti	r2,r2,272
  152194:	103fd31e 	bne	r2,zero,1520e4 <set_display_scale+0x188>
		    plot_pixel(i, p, PIXEL_RED);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  152198:	e0bffe17 	ldw	r2,-8(fp)
  15219c:	10800044 	addi	r2,r2,1
  1521a0:	e0bffe15 	stw	r2,-8(fp)
  1521a4:	e0bffe17 	ldw	r2,-8(fp)
  1521a8:	10800190 	cmplti	r2,r2,6
  1521ac:	103fbf1e 	bne	r2,zero,1520ac <set_display_scale+0x150>
	}
    }


    /* now handle the scale type appropriately */
    switch (scale)  {
  1521b0:	e0bfff17 	ldw	r2,-4(fp)
  1521b4:	10005326 	beq	r2,zero,152304 <set_display_scale+0x3a8>
  1521b8:	108000e8 	cmpgeui	r2,r2,3
  1521bc:	1000521e 	bne	r2,zero,152308 <set_display_scale+0x3ac>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  1521c0:	00bfff84 	movi	r2,-2
  1521c4:	e0bffd15 	stw	r2,-12(fp)
  1521c8:	00002206 	br	152254 <set_display_scale+0x2f8>

				/* get y position of the line */
				p = X_AXIS_POS + i * Y_TICK_SIZE;
  1521cc:	e0bffd17 	ldw	r2,-12(fp)
  1521d0:	10800c24 	muli	r2,r2,48
  1521d4:	10802204 	addi	r2,r2,136
  1521d8:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_Y)
  1521dc:	e0bffc17 	ldw	r2,-16(fp)
  1521e0:	10804410 	cmplti	r2,r2,272
  1521e4:	1000021e 	bne	r2,zero,1521f0 <set_display_scale+0x294>
				    p = PLOT_SIZE_Y - 1;
  1521e8:	008043c4 	movi	r2,271
  1521ec:	e0bffc15 	stw	r2,-16(fp)
				if (p < 0)
  1521f0:	e0bffc17 	ldw	r2,-16(fp)
  1521f4:	1000010e 	bge	r2,zero,1521fc <set_display_scale+0x2a0>
				    p = 0;
  1521f8:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  1521fc:	e0bfff17 	ldw	r2,-4(fp)
  152200:	10800098 	cmpnei	r2,r2,2
  152204:	1000051e 	bne	r2,zero,15221c <set_display_scale+0x2c0>
				    /* drawing a grid line */
			            plot_hline(X_GRID_START, p, (X_GRID_END - X_GRID_START));
  152208:	0009883a 	mov	r4,zero
  15220c:	e17ffc17 	ldw	r5,-16(fp)
  152210:	018077c4 	movi	r6,479
  152214:	01503d00 	call	1503d0 <plot_hline>
  152218:	00000b06 	br	152248 <set_display_scale+0x2ec>
				else if (i == 0)
  15221c:	e0bffd17 	ldw	r2,-12(fp)
  152220:	1000051e 	bne	r2,zero,152238 <set_display_scale+0x2dc>
				    /* drawing the x axis */
			            plot_hline(X_AXIS_START, p, (X_AXIS_END - X_AXIS_START));
  152224:	0009883a 	mov	r4,zero
  152228:	e17ffc17 	ldw	r5,-16(fp)
  15222c:	018077c4 	movi	r6,479
  152230:	01503d00 	call	1503d0 <plot_hline>
  152234:	00000406 	br	152248 <set_display_scale+0x2ec>
				else
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
  152238:	01003b84 	movi	r4,238
  15223c:	e17ffc17 	ldw	r5,-16(fp)
  152240:	01800144 	movi	r6,5
  152244:	01503d00 	call	1503d0 <plot_hline>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  152248:	e0bffd17 	ldw	r2,-12(fp)
  15224c:	10800044 	addi	r2,r2,1
  152250:	e0bffd15 	stw	r2,-12(fp)
  152254:	e0bffd17 	ldw	r2,-12(fp)
  152258:	108000d0 	cmplti	r2,r2,3
  15225c:	103fdb1e 	bne	r2,zero,1521cc <set_display_scale+0x270>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  152260:	00bffec4 	movi	r2,-5
  152264:	e0bffd15 	stw	r2,-12(fp)
  152268:	00002206 	br	1522f4 <set_display_scale+0x398>

				/* get x position of the line */
				p = Y_AXIS_POS + i * X_TICK_SIZE;
  15226c:	e0bffd17 	ldw	r2,-12(fp)
  152270:	10800c24 	muli	r2,r2,48
  152274:	10803c04 	addi	r2,r2,240
  152278:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_X)
  15227c:	e0bffc17 	ldw	r2,-16(fp)
  152280:	10807810 	cmplti	r2,r2,480
  152284:	1000021e 	bne	r2,zero,152290 <set_display_scale+0x334>
				    p = PLOT_SIZE_X - 1;
  152288:	008077c4 	movi	r2,479
  15228c:	e0bffc15 	stw	r2,-16(fp)
			        if (p < 0)
  152290:	e0bffc17 	ldw	r2,-16(fp)
  152294:	1000010e 	bge	r2,zero,15229c <set_display_scale+0x340>
				    p = 0;
  152298:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  15229c:	e0bfff17 	ldw	r2,-4(fp)
  1522a0:	10800098 	cmpnei	r2,r2,2
  1522a4:	1000051e 	bne	r2,zero,1522bc <set_display_scale+0x360>
				    /* drawing a grid line */
			            plot_vline(p, Y_GRID_START, (Y_GRID_END - Y_GRID_START));
  1522a8:	e13ffc17 	ldw	r4,-16(fp)
  1522ac:	000b883a 	mov	r5,zero
  1522b0:	018043c4 	movi	r6,271
  1522b4:	015047c0 	call	15047c <plot_vline>
  1522b8:	00000b06 	br	1522e8 <set_display_scale+0x38c>
				else if (i == 0)
  1522bc:	e0bffd17 	ldw	r2,-12(fp)
  1522c0:	1000051e 	bne	r2,zero,1522d8 <set_display_scale+0x37c>
				    /* drawing the y axis */
			            plot_vline(p, Y_AXIS_START, (Y_AXIS_END - Y_AXIS_START));
  1522c4:	e13ffc17 	ldw	r4,-16(fp)
  1522c8:	000b883a 	mov	r5,zero
  1522cc:	018043c4 	movi	r6,271
  1522d0:	015047c0 	call	15047c <plot_vline>
  1522d4:	00000406 	br	1522e8 <set_display_scale+0x38c>
				else
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
  1522d8:	e13ffc17 	ldw	r4,-16(fp)
  1522dc:	01402184 	movi	r5,134
  1522e0:	01800144 	movi	r6,5
  1522e4:	015047c0 	call	15047c <plot_vline>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  1522e8:	e0bffd17 	ldw	r2,-12(fp)
  1522ec:	10800044 	addi	r2,r2,1
  1522f0:	e0bffd15 	stw	r2,-12(fp)
  1522f4:	e0bffd17 	ldw	r2,-12(fp)
  1522f8:	10800190 	cmplti	r2,r2,6
  1522fc:	103fdb1e 	bne	r2,zero,15226c <set_display_scale+0x310>
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
			    }

			    /* done with the axes */
			    break;
  152300:	00000106 	br	152308 <set_display_scale+0x3ac>

        case SCALE_NONE:    /* there is no scale */
			    /* already restored plot so nothing to do */
			    break;
  152304:	0001883a 	nop

    }


    /* now remember the new (now current) scale type */
    cur_scale = scale;
  152308:	e0bfff17 	ldw	r2,-4(fp)
  15230c:	d0a32c15 	stw	r2,-29520(gp)


    /* scale is taken care of, return */
    return;
  152310:	0001883a 	nop

}
  152314:	e037883a 	mov	sp,fp
  152318:	dfc00117 	ldw	ra,4(sp)
  15231c:	df000017 	ldw	fp,0(sp)
  152320:	dec00204 	addi	sp,sp,8
  152324:	f800283a 	ret

00152328 <clear_saved_areas>:
   Last Modified:    May 9, 2006

*/

void  clear_saved_areas()
{
  152328:	defffd04 	addi	sp,sp,-12
  15232c:	df000215 	stw	fp,8(sp)
  152330:	df000204 	addi	fp,sp,8
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  152334:	e03fff15 	stw	zero,-4(fp)
  152338:	00001306 	br	152388 <clear_saved_areas+0x60>
        for (i = 0; i < (SIZE_X / 8); i++)
  15233c:	e03ffe15 	stw	zero,-8(fp)
  152340:	00000b06 	br	152370 <clear_saved_areas+0x48>
            saved_axis_x[j][i] = 0;
  152344:	00c005b4 	movhi	r3,22
  152348:	18ea1484 	addi	r3,r3,-22446
  15234c:	e0bfff17 	ldw	r2,-4(fp)
  152350:	11000f24 	muli	r4,r2,60
  152354:	e0bffe17 	ldw	r2,-8(fp)
  152358:	2085883a 	add	r2,r4,r2
  15235c:	1885883a 	add	r2,r3,r2
  152360:	10000005 	stb	zero,0(r2)



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
  152364:	e0bffe17 	ldw	r2,-8(fp)
  152368:	10800044 	addi	r2,r2,1
  15236c:	e0bffe15 	stw	r2,-8(fp)
  152370:	e0bffe17 	ldw	r2,-8(fp)
  152374:	10800f10 	cmplti	r2,r2,60
  152378:	103ff21e 	bne	r2,zero,152344 <clear_saved_areas+0x1c>
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  15237c:	e0bfff17 	ldw	r2,-4(fp)
  152380:	10800044 	addi	r2,r2,1
  152384:	e0bfff15 	stw	r2,-4(fp)
  152388:	e0bfff17 	ldw	r2,-4(fp)
  15238c:	10800150 	cmplti	r2,r2,5
  152390:	103fea1e 	bne	r2,zero,15233c <clear_saved_areas+0x14>
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  152394:	e03fff15 	stw	zero,-4(fp)
  152398:	00001306 	br	1523e8 <clear_saved_areas+0xc0>
        for (i = 0; i < (SIZE_Y / 8); i++)
  15239c:	e03ffe15 	stw	zero,-8(fp)
  1523a0:	00000b06 	br	1523d0 <clear_saved_areas+0xa8>
            saved_axis_y[j][i] = 0;
  1523a4:	00c005b4 	movhi	r3,22
  1523a8:	18e9b704 	addi	r3,r3,-22820
  1523ac:	e0bfff17 	ldw	r2,-4(fp)
  1523b0:	110008a4 	muli	r4,r2,34
  1523b4:	e0bffe17 	ldw	r2,-8(fp)
  1523b8:	2085883a 	add	r2,r4,r2
  1523bc:	1885883a 	add	r2,r3,r2
  1523c0:	10000005 	stb	zero,0(r2)
    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
  1523c4:	e0bffe17 	ldw	r2,-8(fp)
  1523c8:	10800044 	addi	r2,r2,1
  1523cc:	e0bffe15 	stw	r2,-8(fp)
  1523d0:	e0bffe17 	ldw	r2,-8(fp)
  1523d4:	10800890 	cmplti	r2,r2,34
  1523d8:	103ff21e 	bne	r2,zero,1523a4 <clear_saved_areas+0x7c>

    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  1523dc:	e0bfff17 	ldw	r2,-4(fp)
  1523e0:	10800044 	addi	r2,r2,1
  1523e4:	e0bfff15 	stw	r2,-4(fp)
  1523e8:	e0bfff17 	ldw	r2,-4(fp)
  1523ec:	108002d0 	cmplti	r2,r2,11
  1523f0:	103fea1e 	bne	r2,zero,15239c <clear_saved_areas+0x74>
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  1523f4:	e03ffe15 	stw	zero,-8(fp)
  1523f8:	00001306 	br	152448 <clear_saved_areas+0x120>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  1523fc:	e03fff15 	stw	zero,-4(fp)
  152400:	00000b06 	br	152430 <clear_saved_areas+0x108>
	    saved_menu[i][j] = 0;
  152404:	00c005b4 	movhi	r3,22
  152408:	18e72f04 	addi	r3,r3,-25412
  15240c:	e0bffe17 	ldw	r2,-8(fp)
  152410:	11000324 	muli	r4,r2,12
  152414:	e0bfff17 	ldw	r2,-4(fp)
  152418:	2085883a 	add	r2,r4,r2
  15241c:	1885883a 	add	r2,r3,r2
  152420:	10000005 	stb	zero,0(r2)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  152424:	e0bfff17 	ldw	r2,-4(fp)
  152428:	10800044 	addi	r2,r2,1
  15242c:	e0bfff15 	stw	r2,-4(fp)
  152430:	e0bfff17 	ldw	r2,-4(fp)
  152434:	10800310 	cmplti	r2,r2,12
  152438:	103ff21e 	bne	r2,zero,152404 <clear_saved_areas+0xdc>
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  15243c:	e0bffe17 	ldw	r2,-8(fp)
  152440:	10800044 	addi	r2,r2,1
  152444:	e0bffe15 	stw	r2,-8(fp)
  152448:	e0bffe17 	ldw	r2,-8(fp)
  15244c:	10800e10 	cmplti	r2,r2,56
  152450:	103fea1e 	bne	r2,zero,1523fc <clear_saved_areas+0xd4>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  152454:	e03ffe15 	stw	zero,-8(fp)
  152458:	00001306 	br	1524a8 <clear_saved_areas+0x180>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  15245c:	e03fff15 	stw	zero,-4(fp)
  152460:	00000b06 	br	152490 <clear_saved_areas+0x168>
	    saved_area[i][j] = 0;
  152464:	00c005b4 	movhi	r3,22
  152468:	18ea5f84 	addi	r3,r3,-22146
  15246c:	e0bffe17 	ldw	r2,-8(fp)
  152470:	110003e4 	muli	r4,r2,15
  152474:	e0bfff17 	ldw	r2,-4(fp)
  152478:	2085883a 	add	r2,r4,r2
  15247c:	1885883a 	add	r2,r3,r2
  152480:	10000005 	stb	zero,0(r2)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  152484:	e0bfff17 	ldw	r2,-4(fp)
  152488:	10800044 	addi	r2,r2,1
  15248c:	e0bfff15 	stw	r2,-4(fp)
  152490:	e0bfff17 	ldw	r2,-4(fp)
  152494:	108003d0 	cmplti	r2,r2,15
  152498:	103ff21e 	bne	r2,zero,152464 <clear_saved_areas+0x13c>
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  15249c:	e0bffe17 	ldw	r2,-8(fp)
  1524a0:	10800044 	addi	r2,r2,1
  1524a4:	e0bffe15 	stw	r2,-8(fp)
  1524a8:	e0bffe17 	ldw	r2,-8(fp)
  1524ac:	10800410 	cmplti	r2,r2,16
  1524b0:	103fea1e 	bne	r2,zero,15245c <clear_saved_areas+0x134>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
	    saved_area[i][j] = 0;


    /* done clearing the saved areas - return */
    return;
  1524b4:	0001883a 	nop

}
  1524b8:	e037883a 	mov	sp,fp
  1524bc:	df000017 	ldw	fp,0(sp)
  1524c0:	dec00104 	addi	sp,sp,4
  1524c4:	f800283a 	ret

001524c8 <restore_menu_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_menu_trace()
{
  1524c8:	defffa04 	addi	sp,sp,-24
  1524cc:	dfc00515 	stw	ra,20(sp)
  1524d0:	df000415 	stw	fp,16(sp)
  1524d4:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  1524d8:	e03fff15 	stw	zero,-4(fp)
  1524dc:	00003206 	br	1525a8 <restore_menu_trace+0xe0>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  1524e0:	00802004 	movi	r2,128
  1524e4:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  1524e8:	e03ffd15 	stw	zero,-12(fp)

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  1524ec:	00805e84 	movi	r2,378
  1524f0:	e0bffe15 	stw	r2,-8(fp)
  1524f4:	00002606 	br	152590 <restore_menu_trace+0xc8>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_menu[y - MENU_UL_Y][bit_offset] & bit_position) == 0)
  1524f8:	00c005b4 	movhi	r3,22
  1524fc:	18e72f04 	addi	r3,r3,-25412
  152500:	e0bfff17 	ldw	r2,-4(fp)
  152504:	11000324 	muli	r4,r2,12
  152508:	e0bffd17 	ldw	r2,-12(fp)
  15250c:	2085883a 	add	r2,r4,r2
  152510:	1885883a 	add	r2,r3,r2
  152514:	10800003 	ldbu	r2,0(r2)
  152518:	10c03fcc 	andi	r3,r2,255
  15251c:	e0bffc17 	ldw	r2,-16(fp)
  152520:	1884703a 	and	r2,r3,r2
  152524:	1000071e 	bne	r2,zero,152544 <restore_menu_trace+0x7c>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_BGND);
  152528:	e0fffe17 	ldw	r3,-8(fp)
  15252c:	e0bfff17 	ldw	r2,-4(fp)
  152530:	1809883a 	mov	r4,r3
  152534:	100b883a 	mov	r5,r2
  152538:	01800704 	movi	r6,28
  15253c:	01537dc0 	call	1537dc <plot_pixel>
  152540:	00000606 	br	15255c <restore_menu_trace+0x94>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_RED);
  152544:	e0fffe17 	ldw	r3,-8(fp)
  152548:	e0bfff17 	ldw	r2,-4(fp)
  15254c:	1809883a 	mov	r4,r3
  152550:	100b883a 	mov	r5,r2
  152554:	0187c004 	movi	r6,7936
  152558:	01537dc0 	call	1537dc <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  15255c:	e0bffc17 	ldw	r2,-16(fp)
  152560:	1005d07a 	srai	r2,r2,1
  152564:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  152568:	e0bffc17 	ldw	r2,-16(fp)
  15256c:	1000051e 	bne	r2,zero,152584 <restore_menu_trace+0xbc>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  152570:	00802004 	movi	r2,128
  152574:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  152578:	e0bffd17 	ldw	r2,-12(fp)
  15257c:	10800044 	addi	r2,r2,1
  152580:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  152584:	e0bffe17 	ldw	r2,-8(fp)
  152588:	10800044 	addi	r2,r2,1
  15258c:	e0bffe15 	stw	r2,-8(fp)
  152590:	e0bffe17 	ldw	r2,-8(fp)
  152594:	10807690 	cmplti	r2,r2,474
  152598:	103fd71e 	bne	r2,zero,1524f8 <restore_menu_trace+0x30>
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  15259c:	e0bfff17 	ldw	r2,-4(fp)
  1525a0:	10800044 	addi	r2,r2,1
  1525a4:	e0bfff15 	stw	r2,-4(fp)
  1525a8:	e0bfff17 	ldw	r2,-4(fp)
  1525ac:	10800e10 	cmplti	r2,r2,56
  1525b0:	103fcb1e 	bne	r2,zero,1524e0 <restore_menu_trace+0x18>
        }
    }


    /* restored menu area - return */
    return;
  1525b4:	0001883a 	nop

}
  1525b8:	e037883a 	mov	sp,fp
  1525bc:	dfc00117 	ldw	ra,4(sp)
  1525c0:	df000017 	ldw	fp,0(sp)
  1525c4:	dec00204 	addi	sp,sp,8
  1525c8:	f800283a 	ret

001525cc <set_save_area>:
   Last Modified:    Mar. 8, 1994

*/

void  set_save_area(int pos_x, int pos_y, int size_x, int size_y)
{
  1525cc:	defff904 	addi	sp,sp,-28
  1525d0:	df000615 	stw	fp,24(sp)
  1525d4:	df000604 	addi	fp,sp,24
  1525d8:	e13ffc15 	stw	r4,-16(fp)
  1525dc:	e17ffd15 	stw	r5,-12(fp)
  1525e0:	e1bffe15 	stw	r6,-8(fp)
  1525e4:	e1ffff15 	stw	r7,-4(fp)
    int  y;



    /* just setup all the locally global variables from the passed values */
    saved_pos_x = pos_x;
  1525e8:	e0bffc17 	ldw	r2,-16(fp)
  1525ec:	d0a33215 	stw	r2,-29496(gp)
    saved_pos_y = pos_y;
  1525f0:	e0bffd17 	ldw	r2,-12(fp)
  1525f4:	d0a32f15 	stw	r2,-29508(gp)
    saved_end_x = pos_x + size_x;
  1525f8:	e0fffc17 	ldw	r3,-16(fp)
  1525fc:	e0bffe17 	ldw	r2,-8(fp)
  152600:	1885883a 	add	r2,r3,r2
  152604:	d0a33115 	stw	r2,-29500(gp)
    saved_end_y = pos_y + size_y;
  152608:	e0fffd17 	ldw	r3,-12(fp)
  15260c:	e0bfff17 	ldw	r2,-4(fp)
  152610:	1885883a 	add	r2,r3,r2
  152614:	d0a32e15 	stw	r2,-29512(gp)


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  152618:	e03ffb15 	stw	zero,-20(fp)
  15261c:	00001306 	br	15266c <set_save_area+0xa0>
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  152620:	e03ffa15 	stw	zero,-24(fp)
  152624:	00000b06 	br	152654 <set_save_area+0x88>
	    saved_area[y][x] = 0;
  152628:	00c005b4 	movhi	r3,22
  15262c:	18ea5f84 	addi	r3,r3,-22146
  152630:	e0bffb17 	ldw	r2,-20(fp)
  152634:	110003e4 	muli	r4,r2,15
  152638:	e0bffa17 	ldw	r2,-24(fp)
  15263c:	2085883a 	add	r2,r4,r2
  152640:	1885883a 	add	r2,r3,r2
  152644:	10000005 	stb	zero,0(r2)
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  152648:	e0bffa17 	ldw	r2,-24(fp)
  15264c:	10800044 	addi	r2,r2,1
  152650:	e0bffa15 	stw	r2,-24(fp)
  152654:	e0bffa17 	ldw	r2,-24(fp)
  152658:	108003d0 	cmplti	r2,r2,15
  15265c:	103ff21e 	bne	r2,zero,152628 <set_save_area+0x5c>
    saved_end_x = pos_x + size_x;
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  152660:	e0bffb17 	ldw	r2,-20(fp)
  152664:	10800044 	addi	r2,r2,1
  152668:	e0bffb15 	stw	r2,-20(fp)
  15266c:	e0bffb17 	ldw	r2,-20(fp)
  152670:	10800410 	cmplti	r2,r2,16
  152674:	103fea1e 	bne	r2,zero,152620 <set_save_area+0x54>
        }
    }


    /* setup the saved area - return */
    return;
  152678:	0001883a 	nop

}
  15267c:	e037883a 	mov	sp,fp
  152680:	df000017 	ldw	fp,0(sp)
  152684:	dec00104 	addi	sp,sp,4
  152688:	f800283a 	ret

0015268c <restore_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_trace()
{
  15268c:	defffa04 	addi	sp,sp,-24
  152690:	dfc00515 	stw	ra,20(sp)
  152694:	df000415 	stw	fp,16(sp)
  152698:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  15269c:	d0a32f17 	ldw	r2,-29508(gp)
  1526a0:	e0bfff15 	stw	r2,-4(fp)
  1526a4:	00003406 	br	152778 <restore_trace+0xec>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  1526a8:	00802004 	movi	r2,128
  1526ac:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  1526b0:	e03ffd15 	stw	zero,-12(fp)

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  1526b4:	d0a33217 	ldw	r2,-29496(gp)
  1526b8:	e0bffe15 	stw	r2,-8(fp)
  1526bc:	00002806 	br	152760 <restore_trace+0xd4>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_area[y - saved_pos_y][bit_offset] & bit_position) == 0)
  1526c0:	d0a32f17 	ldw	r2,-29508(gp)
  1526c4:	e0ffff17 	ldw	r3,-4(fp)
  1526c8:	1885c83a 	sub	r2,r3,r2
  1526cc:	00c005b4 	movhi	r3,22
  1526d0:	18ea5f84 	addi	r3,r3,-22146
  1526d4:	110003e4 	muli	r4,r2,15
  1526d8:	e0bffd17 	ldw	r2,-12(fp)
  1526dc:	2085883a 	add	r2,r4,r2
  1526e0:	1885883a 	add	r2,r3,r2
  1526e4:	10800003 	ldbu	r2,0(r2)
  1526e8:	10c03fcc 	andi	r3,r2,255
  1526ec:	e0bffc17 	ldw	r2,-16(fp)
  1526f0:	1884703a 	and	r2,r3,r2
  1526f4:	1000071e 	bne	r2,zero,152714 <restore_trace+0x88>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_BGND);
  1526f8:	e0fffe17 	ldw	r3,-8(fp)
  1526fc:	e0bfff17 	ldw	r2,-4(fp)
  152700:	1809883a 	mov	r4,r3
  152704:	100b883a 	mov	r5,r2
  152708:	01800704 	movi	r6,28
  15270c:	01537dc0 	call	1537dc <plot_pixel>
  152710:	00000606 	br	15272c <restore_trace+0xa0>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_RED);
  152714:	e0fffe17 	ldw	r3,-8(fp)
  152718:	e0bfff17 	ldw	r2,-4(fp)
  15271c:	1809883a 	mov	r4,r3
  152720:	100b883a 	mov	r5,r2
  152724:	0187c004 	movi	r6,7936
  152728:	01537dc0 	call	1537dc <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  15272c:	e0bffc17 	ldw	r2,-16(fp)
  152730:	1005d07a 	srai	r2,r2,1
  152734:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  152738:	e0bffc17 	ldw	r2,-16(fp)
  15273c:	1000051e 	bne	r2,zero,152754 <restore_trace+0xc8>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  152740:	00802004 	movi	r2,128
  152744:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  152748:	e0bffd17 	ldw	r2,-12(fp)
  15274c:	10800044 	addi	r2,r2,1
  152750:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  152754:	e0bffe17 	ldw	r2,-8(fp)
  152758:	10800044 	addi	r2,r2,1
  15275c:	e0bffe15 	stw	r2,-8(fp)
  152760:	d0a33117 	ldw	r2,-29500(gp)
  152764:	e0fffe17 	ldw	r3,-8(fp)
  152768:	18bfd516 	blt	r3,r2,1526c0 <restore_trace+0x34>
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  15276c:	e0bfff17 	ldw	r2,-4(fp)
  152770:	10800044 	addi	r2,r2,1
  152774:	e0bfff15 	stw	r2,-4(fp)
  152778:	d0a32e17 	ldw	r2,-29512(gp)
  15277c:	e0ffff17 	ldw	r3,-4(fp)
  152780:	18bfc916 	blt	r3,r2,1526a8 <restore_trace+0x1c>
        }
    }


    /* restored the saved area - return */
    return;
  152784:	0001883a 	nop

}
  152788:	e037883a 	mov	sp,fp
  15278c:	dfc00117 	ldw	ra,4(sp)
  152790:	df000017 	ldw	fp,0(sp)
  152794:	dec00204 	addi	sp,sp,8
  152798:	f800283a 	ret

0015279c <do_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  do_trace()
{
  15279c:	defffe04 	addi	sp,sp,-8
  1527a0:	dfc00115 	stw	ra,4(sp)
  1527a4:	df000015 	stw	fp,0(sp)
  1527a8:	d839883a 	mov	fp,sp



    /* start up the trace */
    /* indicate whether using automatic triggering or not */
    start_sample(get_trigger_mode() == AUTO_TRIGGER);
  1527ac:	0150f9c0 	call	150f9c <get_trigger_mode>
  1527b0:	10800060 	cmpeqi	r2,r2,1
  1527b4:	10803fcc 	andi	r2,r2,255
  1527b8:	1009883a 	mov	r4,r2
  1527bc:	01539a80 	call	1539a8 <start_sample>

    /* now not ready for another trace (currently doing one) */
    trace_status = FALSE;
  1527c0:	d0232d15 	stw	zero,-29516(gp)

    /* and are currently sampling data */
    sampling = TRUE;
  1527c4:	00800044 	movi	r2,1
  1527c8:	d0a33315 	stw	r2,-29492(gp)


    /* trace is going, return */
    return;
  1527cc:	0001883a 	nop

}
  1527d0:	e037883a 	mov	sp,fp
  1527d4:	dfc00117 	ldw	ra,4(sp)
  1527d8:	df000017 	ldw	fp,0(sp)
  1527dc:	dec00204 	addi	sp,sp,8
  1527e0:	f800283a 	ret

001527e4 <plot_trace>:
   Last Modified:    May 9, 2006

*/

void  plot_trace(unsigned char **sample)
{
  1527e4:	deffe504 	addi	sp,sp,-108
  1527e8:	dfc01a15 	stw	ra,104(sp)
  1527ec:	df001915 	stw	fp,100(sp)
  1527f0:	df001904 	addi	fp,sp,100
  1527f4:	e13fff15 	stw	r4,-4(fp)
    /* variables */
    int x = 0;						/* current x position to plot */
  1527f8:	e03fea15 	stw	zero,-88(fp)
    int x_pos = (PLOT_SIZE_X / 2);	/* "fine" x position for multiple point plotting */
  1527fc:	00803c04 	movi	r2,240
  152800:	e0bfeb15 	stw	r2,-84(fp)
    int i;							/* loop indices */
    int j;
    int ii;
    int jj;

    unsigned char *sample_A = sample[0];
  152804:	e0bfff17 	ldw	r2,-4(fp)
  152808:	10800017 	ldw	r2,0(r2)
  15280c:	e0bfec15 	stw	r2,-80(fp)
    unsigned char *sample_B = sample[1];
  152810:	e0bfff17 	ldw	r2,-4(fp)
  152814:	10800117 	ldw	r2,4(r2)
  152818:	e0bfed15 	stw	r2,-76(fp)
    unsigned char *sample_L = sample[2];
  15281c:	e0bfff17 	ldw	r2,-4(fp)
  152820:	10800217 	ldw	r2,8(r2)
  152824:	e0bfee15 	stw	r2,-72(fp)

    // Iterate through the points.
    for (i = 0; i < sample_size; i++) {
  152828:	e03fe715 	stw	zero,-100(fp)
  15282c:	00018206 	br	152e38 <plot_trace+0x654>
    	// Get the new screen coordinates.
    	trace_A[i] = 255 - sample_A[i] + 8;
  152830:	e0bfe717 	ldw	r2,-100(fp)
  152834:	e0ffec17 	ldw	r3,-80(fp)
  152838:	1885883a 	add	r2,r3,r2
  15283c:	10800003 	ldbu	r2,0(r2)
  152840:	10803fcc 	andi	r2,r2,255
  152844:	00c041c4 	movi	r3,263
  152848:	1887c83a 	sub	r3,r3,r2
  15284c:	010005b4 	movhi	r4,22
  152850:	21236f04 	addi	r4,r4,-29252
  152854:	e0bfe717 	ldw	r2,-100(fp)
  152858:	1085883a 	add	r2,r2,r2
  15285c:	1085883a 	add	r2,r2,r2
  152860:	2085883a 	add	r2,r4,r2
  152864:	10c00015 	stw	r3,0(r2)
    	trace_B[i] = 255 - sample_B[i] + 8;
  152868:	e0bfe717 	ldw	r2,-100(fp)
  15286c:	e0ffed17 	ldw	r3,-76(fp)
  152870:	1885883a 	add	r2,r3,r2
  152874:	10800003 	ldbu	r2,0(r2)
  152878:	10803fcc 	andi	r2,r2,255
  15287c:	00c041c4 	movi	r3,263
  152880:	1887c83a 	sub	r3,r3,r2
  152884:	010005b4 	movhi	r4,22
  152888:	2127d704 	addi	r4,r4,-24740
  15288c:	e0bfe717 	ldw	r2,-100(fp)
  152890:	1085883a 	add	r2,r2,r2
  152894:	1085883a 	add	r2,r2,r2
  152898:	2085883a 	add	r2,r4,r2
  15289c:	10c00015 	stw	r3,0(r2)
    	trace_L[i] = sample_L[i];
  1528a0:	e0bfe717 	ldw	r2,-100(fp)
  1528a4:	e0ffee17 	ldw	r3,-72(fp)
  1528a8:	1885883a 	add	r2,r3,r2
  1528ac:	10800003 	ldbu	r2,0(r2)
  1528b0:	10c03fcc 	andi	r3,r2,255
  1528b4:	010005b4 	movhi	r4,22
  1528b8:	21254f04 	addi	r4,r4,-27332
  1528bc:	e0bfe717 	ldw	r2,-100(fp)
  1528c0:	1085883a 	add	r2,r2,r2
  1528c4:	1085883a 	add	r2,r2,r2
  1528c8:	2085883a 	add	r2,r4,r2
  1528cc:	10c00015 	stw	r3,0(r2)

    	// Clear the analog trace.
    	if (i > 0) {
  1528d0:	e0bfe717 	ldw	r2,-100(fp)
  1528d4:	00806e0e 	bge	zero,r2,152a90 <plot_trace+0x2ac>
			for (j = min(saved_trace_A[i-1], saved_trace_A[i]); j <= max(saved_trace_A[i-1], saved_trace_A[i]); j++) {
  1528d8:	e0bfe717 	ldw	r2,-100(fp)
  1528dc:	10bfffc4 	addi	r2,r2,-1
  1528e0:	00c00574 	movhi	r3,21
  1528e4:	18dfaf04 	addi	r3,r3,32444
  1528e8:	1085883a 	add	r2,r2,r2
  1528ec:	1085883a 	add	r2,r2,r2
  1528f0:	1885883a 	add	r2,r3,r2
  1528f4:	10800017 	ldw	r2,0(r2)
  1528f8:	e0bfef15 	stw	r2,-68(fp)
  1528fc:	00c00574 	movhi	r3,21
  152900:	18dfaf04 	addi	r3,r3,32444
  152904:	e0bfe717 	ldw	r2,-100(fp)
  152908:	1085883a 	add	r2,r2,r2
  15290c:	1085883a 	add	r2,r2,r2
  152910:	1885883a 	add	r2,r3,r2
  152914:	10800017 	ldw	r2,0(r2)
  152918:	e0bff015 	stw	r2,-64(fp)
  15291c:	e0ffef17 	ldw	r3,-68(fp)
  152920:	e0bff017 	ldw	r2,-64(fp)
  152924:	1880010e 	bge	r3,r2,15292c <plot_trace+0x148>
  152928:	1805883a 	mov	r2,r3
  15292c:	e0bfe815 	stw	r2,-96(fp)
  152930:	00000906 	br	152958 <plot_trace+0x174>
				plot_pixel(i, j, PIXEL_BGND);
  152934:	e0ffe717 	ldw	r3,-100(fp)
  152938:	e0bfe817 	ldw	r2,-96(fp)
  15293c:	1809883a 	mov	r4,r3
  152940:	100b883a 	mov	r5,r2
  152944:	01800704 	movi	r6,28
  152948:	01537dc0 	call	1537dc <plot_pixel>
    	trace_B[i] = 255 - sample_B[i] + 8;
    	trace_L[i] = sample_L[i];

    	// Clear the analog trace.
    	if (i > 0) {
			for (j = min(saved_trace_A[i-1], saved_trace_A[i]); j <= max(saved_trace_A[i-1], saved_trace_A[i]); j++) {
  15294c:	e0bfe817 	ldw	r2,-96(fp)
  152950:	10800044 	addi	r2,r2,1
  152954:	e0bfe815 	stw	r2,-96(fp)
  152958:	e0bfe717 	ldw	r2,-100(fp)
  15295c:	10bfffc4 	addi	r2,r2,-1
  152960:	00c00574 	movhi	r3,21
  152964:	18dfaf04 	addi	r3,r3,32444
  152968:	1085883a 	add	r2,r2,r2
  15296c:	1085883a 	add	r2,r2,r2
  152970:	1885883a 	add	r2,r3,r2
  152974:	10800017 	ldw	r2,0(r2)
  152978:	e0bff115 	stw	r2,-60(fp)
  15297c:	00c00574 	movhi	r3,21
  152980:	18dfaf04 	addi	r3,r3,32444
  152984:	e0bfe717 	ldw	r2,-100(fp)
  152988:	1085883a 	add	r2,r2,r2
  15298c:	1085883a 	add	r2,r2,r2
  152990:	1885883a 	add	r2,r3,r2
  152994:	10800017 	ldw	r2,0(r2)
  152998:	e0bff215 	stw	r2,-56(fp)
  15299c:	e0fff117 	ldw	r3,-60(fp)
  1529a0:	e0bff217 	ldw	r2,-56(fp)
  1529a4:	10c0010e 	bge	r2,r3,1529ac <plot_trace+0x1c8>
  1529a8:	1805883a 	mov	r2,r3
  1529ac:	e0ffe817 	ldw	r3,-96(fp)
  1529b0:	10ffe00e 	bge	r2,r3,152934 <plot_trace+0x150>
				plot_pixel(i, j, PIXEL_BGND);
			}
			for (j = min(saved_trace_B[i-1], saved_trace_B[i]); j <= max(saved_trace_B[i-1], saved_trace_B[i]); j++) {
  1529b4:	e0bfe717 	ldw	r2,-100(fp)
  1529b8:	10bfffc4 	addi	r2,r2,-1
  1529bc:	00c005b4 	movhi	r3,22
  1529c0:	18e18f04 	addi	r3,r3,-31172
  1529c4:	1085883a 	add	r2,r2,r2
  1529c8:	1085883a 	add	r2,r2,r2
  1529cc:	1885883a 	add	r2,r3,r2
  1529d0:	10800017 	ldw	r2,0(r2)
  1529d4:	e0bff315 	stw	r2,-52(fp)
  1529d8:	00c005b4 	movhi	r3,22
  1529dc:	18e18f04 	addi	r3,r3,-31172
  1529e0:	e0bfe717 	ldw	r2,-100(fp)
  1529e4:	1085883a 	add	r2,r2,r2
  1529e8:	1085883a 	add	r2,r2,r2
  1529ec:	1885883a 	add	r2,r3,r2
  1529f0:	10800017 	ldw	r2,0(r2)
  1529f4:	e0bff415 	stw	r2,-48(fp)
  1529f8:	e0fff317 	ldw	r3,-52(fp)
  1529fc:	e0bff417 	ldw	r2,-48(fp)
  152a00:	1880010e 	bge	r3,r2,152a08 <plot_trace+0x224>
  152a04:	1805883a 	mov	r2,r3
  152a08:	e0bfe815 	stw	r2,-96(fp)
  152a0c:	00000906 	br	152a34 <plot_trace+0x250>
				plot_pixel(i, j, PIXEL_BGND);
  152a10:	e0ffe717 	ldw	r3,-100(fp)
  152a14:	e0bfe817 	ldw	r2,-96(fp)
  152a18:	1809883a 	mov	r4,r3
  152a1c:	100b883a 	mov	r5,r2
  152a20:	01800704 	movi	r6,28
  152a24:	01537dc0 	call	1537dc <plot_pixel>
    	// Clear the analog trace.
    	if (i > 0) {
			for (j = min(saved_trace_A[i-1], saved_trace_A[i]); j <= max(saved_trace_A[i-1], saved_trace_A[i]); j++) {
				plot_pixel(i, j, PIXEL_BGND);
			}
			for (j = min(saved_trace_B[i-1], saved_trace_B[i]); j <= max(saved_trace_B[i-1], saved_trace_B[i]); j++) {
  152a28:	e0bfe817 	ldw	r2,-96(fp)
  152a2c:	10800044 	addi	r2,r2,1
  152a30:	e0bfe815 	stw	r2,-96(fp)
  152a34:	e0bfe717 	ldw	r2,-100(fp)
  152a38:	10bfffc4 	addi	r2,r2,-1
  152a3c:	00c005b4 	movhi	r3,22
  152a40:	18e18f04 	addi	r3,r3,-31172
  152a44:	1085883a 	add	r2,r2,r2
  152a48:	1085883a 	add	r2,r2,r2
  152a4c:	1885883a 	add	r2,r3,r2
  152a50:	10800017 	ldw	r2,0(r2)
  152a54:	e0bff515 	stw	r2,-44(fp)
  152a58:	00c005b4 	movhi	r3,22
  152a5c:	18e18f04 	addi	r3,r3,-31172
  152a60:	e0bfe717 	ldw	r2,-100(fp)
  152a64:	1085883a 	add	r2,r2,r2
  152a68:	1085883a 	add	r2,r2,r2
  152a6c:	1885883a 	add	r2,r3,r2
  152a70:	10800017 	ldw	r2,0(r2)
  152a74:	e0bff615 	stw	r2,-40(fp)
  152a78:	e0fff517 	ldw	r3,-44(fp)
  152a7c:	e0bff617 	ldw	r2,-40(fp)
  152a80:	10c0010e 	bge	r2,r3,152a88 <plot_trace+0x2a4>
  152a84:	1805883a 	mov	r2,r3
  152a88:	e0ffe817 	ldw	r3,-96(fp)
  152a8c:	10ffe00e 	bge	r2,r3,152a10 <plot_trace+0x22c>
				plot_pixel(i, j, PIXEL_BGND);
			}
    	}

    	// Clear the logic analyzer trace.
    	unsigned char cur_log = saved_trace_L[i];
  152a90:	00c005b4 	movhi	r3,22
  152a94:	18ea9c04 	addi	r3,r3,-21904
  152a98:	e0bfe717 	ldw	r2,-100(fp)
  152a9c:	1085883a 	add	r2,r2,r2
  152aa0:	1085883a 	add	r2,r2,r2
  152aa4:	1885883a 	add	r2,r3,r2
  152aa8:	10800017 	ldw	r2,0(r2)
  152aac:	e0bfe905 	stb	r2,-92(fp)
    	for (j = 0; j < 8; j++) {
  152ab0:	e03fe815 	stw	zero,-96(fp)
  152ab4:	00001a06 	br	152b20 <plot_trace+0x33c>
    	    if (cur_log & 1) {
  152ab8:	e0bfe903 	ldbu	r2,-92(fp)
  152abc:	1080004c 	andi	r2,r2,1
  152ac0:	10000926 	beq	r2,zero,152ae8 <plot_trace+0x304>
    	    	plot_pixel(i, 270 - 5 * j - 3, PIXEL_BGND);
  152ac4:	e0ffe717 	ldw	r3,-100(fp)
  152ac8:	e0bfe817 	ldw	r2,-96(fp)
  152acc:	10bffee4 	muli	r2,r2,-5
  152ad0:	108042c4 	addi	r2,r2,267
  152ad4:	1809883a 	mov	r4,r3
  152ad8:	100b883a 	mov	r5,r2
  152adc:	01800704 	movi	r6,28
  152ae0:	01537dc0 	call	1537dc <plot_pixel>
  152ae4:	00000806 	br	152b08 <plot_trace+0x324>
    	    } else {
    	    	plot_pixel(i, 270 - 5 * j, PIXEL_BGND);
  152ae8:	e0ffe717 	ldw	r3,-100(fp)
  152aec:	e0bfe817 	ldw	r2,-96(fp)
  152af0:	10bffee4 	muli	r2,r2,-5
  152af4:	10804384 	addi	r2,r2,270
  152af8:	1809883a 	mov	r4,r3
  152afc:	100b883a 	mov	r5,r2
  152b00:	01800704 	movi	r6,28
  152b04:	01537dc0 	call	1537dc <plot_pixel>
    	    }
    	    cur_log = cur_log >> 1;
  152b08:	e0bfe903 	ldbu	r2,-92(fp)
  152b0c:	1004d07a 	srli	r2,r2,1
  152b10:	e0bfe905 	stb	r2,-92(fp)
			}
    	}

    	// Clear the logic analyzer trace.
    	unsigned char cur_log = saved_trace_L[i];
    	for (j = 0; j < 8; j++) {
  152b14:	e0bfe817 	ldw	r2,-96(fp)
  152b18:	10800044 	addi	r2,r2,1
  152b1c:	e0bfe815 	stw	r2,-96(fp)
  152b20:	e0bfe817 	ldw	r2,-96(fp)
  152b24:	10800210 	cmplti	r2,r2,8
  152b28:	103fe31e 	bne	r2,zero,152ab8 <plot_trace+0x2d4>
    	    }
    	    cur_log = cur_log >> 1;
    	}

    	//Draw the analog trace.
    	if (i > 1) {
  152b2c:	e0bfe717 	ldw	r2,-100(fp)
  152b30:	10800090 	cmplti	r2,r2,2
  152b34:	10006e1e 	bne	r2,zero,152cf0 <plot_trace+0x50c>
    		for (j = min(trace_A[i-1], trace_A[i]); j <= max(trace_A[i-1], trace_A[i]); j++) {
  152b38:	e0bfe717 	ldw	r2,-100(fp)
  152b3c:	10bfffc4 	addi	r2,r2,-1
  152b40:	00c005b4 	movhi	r3,22
  152b44:	18e36f04 	addi	r3,r3,-29252
  152b48:	1085883a 	add	r2,r2,r2
  152b4c:	1085883a 	add	r2,r2,r2
  152b50:	1885883a 	add	r2,r3,r2
  152b54:	10800017 	ldw	r2,0(r2)
  152b58:	e0bff715 	stw	r2,-36(fp)
  152b5c:	00c005b4 	movhi	r3,22
  152b60:	18e36f04 	addi	r3,r3,-29252
  152b64:	e0bfe717 	ldw	r2,-100(fp)
  152b68:	1085883a 	add	r2,r2,r2
  152b6c:	1085883a 	add	r2,r2,r2
  152b70:	1885883a 	add	r2,r3,r2
  152b74:	10800017 	ldw	r2,0(r2)
  152b78:	e0bff815 	stw	r2,-32(fp)
  152b7c:	e0fff717 	ldw	r3,-36(fp)
  152b80:	e0bff817 	ldw	r2,-32(fp)
  152b84:	1880010e 	bge	r3,r2,152b8c <plot_trace+0x3a8>
  152b88:	1805883a 	mov	r2,r3
  152b8c:	e0bfe815 	stw	r2,-96(fp)
  152b90:	00000906 	br	152bb8 <plot_trace+0x3d4>
    		    plot_pixel(i, j, PIXEL_A);
  152b94:	e0ffe717 	ldw	r3,-100(fp)
  152b98:	e0bfe817 	ldw	r2,-96(fp)
  152b9c:	1809883a 	mov	r4,r3
  152ba0:	100b883a 	mov	r5,r2
  152ba4:	01bfdfd4 	movui	r6,65407
  152ba8:	01537dc0 	call	1537dc <plot_pixel>
    	    cur_log = cur_log >> 1;
    	}

    	//Draw the analog trace.
    	if (i > 1) {
    		for (j = min(trace_A[i-1], trace_A[i]); j <= max(trace_A[i-1], trace_A[i]); j++) {
  152bac:	e0bfe817 	ldw	r2,-96(fp)
  152bb0:	10800044 	addi	r2,r2,1
  152bb4:	e0bfe815 	stw	r2,-96(fp)
  152bb8:	e0bfe717 	ldw	r2,-100(fp)
  152bbc:	10bfffc4 	addi	r2,r2,-1
  152bc0:	00c005b4 	movhi	r3,22
  152bc4:	18e36f04 	addi	r3,r3,-29252
  152bc8:	1085883a 	add	r2,r2,r2
  152bcc:	1085883a 	add	r2,r2,r2
  152bd0:	1885883a 	add	r2,r3,r2
  152bd4:	10800017 	ldw	r2,0(r2)
  152bd8:	e0bff915 	stw	r2,-28(fp)
  152bdc:	00c005b4 	movhi	r3,22
  152be0:	18e36f04 	addi	r3,r3,-29252
  152be4:	e0bfe717 	ldw	r2,-100(fp)
  152be8:	1085883a 	add	r2,r2,r2
  152bec:	1085883a 	add	r2,r2,r2
  152bf0:	1885883a 	add	r2,r3,r2
  152bf4:	10800017 	ldw	r2,0(r2)
  152bf8:	e0bffa15 	stw	r2,-24(fp)
  152bfc:	e0fff917 	ldw	r3,-28(fp)
  152c00:	e0bffa17 	ldw	r2,-24(fp)
  152c04:	10c0010e 	bge	r2,r3,152c0c <plot_trace+0x428>
  152c08:	1805883a 	mov	r2,r3
  152c0c:	e0ffe817 	ldw	r3,-96(fp)
  152c10:	10ffe00e 	bge	r2,r3,152b94 <plot_trace+0x3b0>
    		    plot_pixel(i, j, PIXEL_A);
    		}
    		for (j = min(trace_B[i-1], trace_B[i]); j <= max(trace_B[i-1], trace_B[i]); j++) {
  152c14:	e0bfe717 	ldw	r2,-100(fp)
  152c18:	10bfffc4 	addi	r2,r2,-1
  152c1c:	00c005b4 	movhi	r3,22
  152c20:	18e7d704 	addi	r3,r3,-24740
  152c24:	1085883a 	add	r2,r2,r2
  152c28:	1085883a 	add	r2,r2,r2
  152c2c:	1885883a 	add	r2,r3,r2
  152c30:	10800017 	ldw	r2,0(r2)
  152c34:	e0bffb15 	stw	r2,-20(fp)
  152c38:	00c005b4 	movhi	r3,22
  152c3c:	18e7d704 	addi	r3,r3,-24740
  152c40:	e0bfe717 	ldw	r2,-100(fp)
  152c44:	1085883a 	add	r2,r2,r2
  152c48:	1085883a 	add	r2,r2,r2
  152c4c:	1885883a 	add	r2,r3,r2
  152c50:	10800017 	ldw	r2,0(r2)
  152c54:	e0bffc15 	stw	r2,-16(fp)
  152c58:	e0fffb17 	ldw	r3,-20(fp)
  152c5c:	e0bffc17 	ldw	r2,-16(fp)
  152c60:	1880010e 	bge	r3,r2,152c68 <plot_trace+0x484>
  152c64:	1805883a 	mov	r2,r3
  152c68:	e0bfe815 	stw	r2,-96(fp)
  152c6c:	00000906 	br	152c94 <plot_trace+0x4b0>
    			plot_pixel(i, j, PIXEL_B);
  152c70:	e0ffe717 	ldw	r3,-100(fp)
  152c74:	e0bfe817 	ldw	r2,-96(fp)
  152c78:	1809883a 	mov	r4,r3
  152c7c:	100b883a 	mov	r5,r2
  152c80:	01801fc4 	movi	r6,127
  152c84:	01537dc0 	call	1537dc <plot_pixel>
    	//Draw the analog trace.
    	if (i > 1) {
    		for (j = min(trace_A[i-1], trace_A[i]); j <= max(trace_A[i-1], trace_A[i]); j++) {
    		    plot_pixel(i, j, PIXEL_A);
    		}
    		for (j = min(trace_B[i-1], trace_B[i]); j <= max(trace_B[i-1], trace_B[i]); j++) {
  152c88:	e0bfe817 	ldw	r2,-96(fp)
  152c8c:	10800044 	addi	r2,r2,1
  152c90:	e0bfe815 	stw	r2,-96(fp)
  152c94:	e0bfe717 	ldw	r2,-100(fp)
  152c98:	10bfffc4 	addi	r2,r2,-1
  152c9c:	00c005b4 	movhi	r3,22
  152ca0:	18e7d704 	addi	r3,r3,-24740
  152ca4:	1085883a 	add	r2,r2,r2
  152ca8:	1085883a 	add	r2,r2,r2
  152cac:	1885883a 	add	r2,r3,r2
  152cb0:	10800017 	ldw	r2,0(r2)
  152cb4:	e0bffd15 	stw	r2,-12(fp)
  152cb8:	00c005b4 	movhi	r3,22
  152cbc:	18e7d704 	addi	r3,r3,-24740
  152cc0:	e0bfe717 	ldw	r2,-100(fp)
  152cc4:	1085883a 	add	r2,r2,r2
  152cc8:	1085883a 	add	r2,r2,r2
  152ccc:	1885883a 	add	r2,r3,r2
  152cd0:	10800017 	ldw	r2,0(r2)
  152cd4:	e0bffe15 	stw	r2,-8(fp)
  152cd8:	e0fffd17 	ldw	r3,-12(fp)
  152cdc:	e0bffe17 	ldw	r2,-8(fp)
  152ce0:	10c0010e 	bge	r2,r3,152ce8 <plot_trace+0x504>
  152ce4:	1805883a 	mov	r2,r3
  152ce8:	e0ffe817 	ldw	r3,-96(fp)
  152cec:	10ffe00e 	bge	r2,r3,152c70 <plot_trace+0x48c>
    			plot_pixel(i, j, PIXEL_B);
    		}
    	}

    	// Draw the logic analyzer trace.
    	cur_log = trace_L[i];
  152cf0:	00c005b4 	movhi	r3,22
  152cf4:	18e54f04 	addi	r3,r3,-27332
  152cf8:	e0bfe717 	ldw	r2,-100(fp)
  152cfc:	1085883a 	add	r2,r2,r2
  152d00:	1085883a 	add	r2,r2,r2
  152d04:	1885883a 	add	r2,r3,r2
  152d08:	10800017 	ldw	r2,0(r2)
  152d0c:	e0bfe905 	stb	r2,-92(fp)
    	for (j = 0; j < 8; j++) {
  152d10:	e03fe815 	stw	zero,-96(fp)
  152d14:	00004206 	br	152e20 <plot_trace+0x63c>
    		if (cur_log & 1) {
  152d18:	e0bfe903 	ldbu	r2,-92(fp)
  152d1c:	1080004c 	andi	r2,r2,1
  152d20:	10001526 	beq	r2,zero,152d78 <plot_trace+0x594>
    			if (j % 2) plot_pixel(i, 270 - 5 * j - 3, PIXEL_L1);
  152d24:	e0bfe817 	ldw	r2,-96(fp)
  152d28:	1080004c 	andi	r2,r2,1
  152d2c:	10000926 	beq	r2,zero,152d54 <plot_trace+0x570>
  152d30:	e0ffe717 	ldw	r3,-100(fp)
  152d34:	e0bfe817 	ldw	r2,-96(fp)
  152d38:	10bffee4 	muli	r2,r2,-5
  152d3c:	108042c4 	addi	r2,r2,267
  152d40:	1809883a 	mov	r4,r3
  152d44:	100b883a 	mov	r5,r2
  152d48:	0187df04 	movi	r6,8060
  152d4c:	01537dc0 	call	1537dc <plot_pixel>
  152d50:	00001d06 	br	152dc8 <plot_trace+0x5e4>
    			else plot_pixel(i, 270 - 5 * j - 3, PIXEL_L2);
  152d54:	e0ffe717 	ldw	r3,-100(fp)
  152d58:	e0bfe817 	ldw	r2,-96(fp)
  152d5c:	10bffee4 	muli	r2,r2,-5
  152d60:	108042c4 	addi	r2,r2,267
  152d64:	1809883a 	mov	r4,r3
  152d68:	100b883a 	mov	r5,r2
  152d6c:	01851f04 	movi	r6,5244
  152d70:	01537dc0 	call	1537dc <plot_pixel>
  152d74:	00001406 	br	152dc8 <plot_trace+0x5e4>
    	    } else {
    	    	if (j % 2) plot_pixel(i, 270 - 5 * j, PIXEL_L1);
  152d78:	e0bfe817 	ldw	r2,-96(fp)
  152d7c:	1080004c 	andi	r2,r2,1
  152d80:	10000926 	beq	r2,zero,152da8 <plot_trace+0x5c4>
  152d84:	e0ffe717 	ldw	r3,-100(fp)
  152d88:	e0bfe817 	ldw	r2,-96(fp)
  152d8c:	10bffee4 	muli	r2,r2,-5
  152d90:	10804384 	addi	r2,r2,270
  152d94:	1809883a 	mov	r4,r3
  152d98:	100b883a 	mov	r5,r2
  152d9c:	0187df04 	movi	r6,8060
  152da0:	01537dc0 	call	1537dc <plot_pixel>
  152da4:	00000806 	br	152dc8 <plot_trace+0x5e4>
    	    	else plot_pixel(i, 270 - 5 * j, PIXEL_L2);
  152da8:	e0ffe717 	ldw	r3,-100(fp)
  152dac:	e0bfe817 	ldw	r2,-96(fp)
  152db0:	10bffee4 	muli	r2,r2,-5
  152db4:	10804384 	addi	r2,r2,270
  152db8:	1809883a 	mov	r4,r3
  152dbc:	100b883a 	mov	r5,r2
  152dc0:	01851f04 	movi	r6,5244
  152dc4:	01537dc0 	call	1537dc <plot_pixel>
    	    }
    		plot_pixel(i, 270 - 5 * j - 1, PIXEL_L3);
  152dc8:	e0ffe717 	ldw	r3,-100(fp)
  152dcc:	e0bfe817 	ldw	r2,-96(fp)
  152dd0:	10bffee4 	muli	r2,r2,-5
  152dd4:	10804344 	addi	r2,r2,269
  152dd8:	1809883a 	mov	r4,r3
  152ddc:	100b883a 	mov	r5,r2
  152de0:	01801f04 	movi	r6,124
  152de4:	01537dc0 	call	1537dc <plot_pixel>
    		plot_pixel(i, 270 - 5 * j - 2, PIXEL_L3);
  152de8:	e0ffe717 	ldw	r3,-100(fp)
  152dec:	e0bfe817 	ldw	r2,-96(fp)
  152df0:	10bffee4 	muli	r2,r2,-5
  152df4:	10804304 	addi	r2,r2,268
  152df8:	1809883a 	mov	r4,r3
  152dfc:	100b883a 	mov	r5,r2
  152e00:	01801f04 	movi	r6,124
  152e04:	01537dc0 	call	1537dc <plot_pixel>
    	    cur_log = cur_log >> 1;
  152e08:	e0bfe903 	ldbu	r2,-92(fp)
  152e0c:	1004d07a 	srli	r2,r2,1
  152e10:	e0bfe905 	stb	r2,-92(fp)
    		}
    	}

    	// Draw the logic analyzer trace.
    	cur_log = trace_L[i];
    	for (j = 0; j < 8; j++) {
  152e14:	e0bfe817 	ldw	r2,-96(fp)
  152e18:	10800044 	addi	r2,r2,1
  152e1c:	e0bfe815 	stw	r2,-96(fp)
  152e20:	e0bfe817 	ldw	r2,-96(fp)
  152e24:	10800210 	cmplti	r2,r2,8
  152e28:	103fbb1e 	bne	r2,zero,152d18 <plot_trace+0x534>
    unsigned char *sample_A = sample[0];
    unsigned char *sample_B = sample[1];
    unsigned char *sample_L = sample[2];

    // Iterate through the points.
    for (i = 0; i < sample_size; i++) {
  152e2c:	e0bfe717 	ldw	r2,-100(fp)
  152e30:	10800044 	addi	r2,r2,1
  152e34:	e0bfe715 	stw	r2,-100(fp)
  152e38:	d0a33017 	ldw	r2,-29504(gp)
  152e3c:	e0ffe717 	ldw	r3,-100(fp)
  152e40:	18be7b16 	blt	r3,r2,152830 <plot_trace+0x4c>
    	}

    }

    // Update the saved trace arrays.
    for (i = 0; i < sample_size; i++) {
  152e44:	e03fe715 	stw	zero,-100(fp)
  152e48:	00002d06 	br	152f00 <plot_trace+0x71c>
    	saved_trace_A[i] = trace_A[i];
  152e4c:	00c005b4 	movhi	r3,22
  152e50:	18e36f04 	addi	r3,r3,-29252
  152e54:	e0bfe717 	ldw	r2,-100(fp)
  152e58:	1085883a 	add	r2,r2,r2
  152e5c:	1085883a 	add	r2,r2,r2
  152e60:	1885883a 	add	r2,r3,r2
  152e64:	10c00017 	ldw	r3,0(r2)
  152e68:	01000574 	movhi	r4,21
  152e6c:	211faf04 	addi	r4,r4,32444
  152e70:	e0bfe717 	ldw	r2,-100(fp)
  152e74:	1085883a 	add	r2,r2,r2
  152e78:	1085883a 	add	r2,r2,r2
  152e7c:	2085883a 	add	r2,r4,r2
  152e80:	10c00015 	stw	r3,0(r2)
    	saved_trace_B[i] = trace_B[i];
  152e84:	00c005b4 	movhi	r3,22
  152e88:	18e7d704 	addi	r3,r3,-24740
  152e8c:	e0bfe717 	ldw	r2,-100(fp)
  152e90:	1085883a 	add	r2,r2,r2
  152e94:	1085883a 	add	r2,r2,r2
  152e98:	1885883a 	add	r2,r3,r2
  152e9c:	10c00017 	ldw	r3,0(r2)
  152ea0:	010005b4 	movhi	r4,22
  152ea4:	21218f04 	addi	r4,r4,-31172
  152ea8:	e0bfe717 	ldw	r2,-100(fp)
  152eac:	1085883a 	add	r2,r2,r2
  152eb0:	1085883a 	add	r2,r2,r2
  152eb4:	2085883a 	add	r2,r4,r2
  152eb8:	10c00015 	stw	r3,0(r2)
    	saved_trace_L[i] = trace_L[i];
  152ebc:	00c005b4 	movhi	r3,22
  152ec0:	18e54f04 	addi	r3,r3,-27332
  152ec4:	e0bfe717 	ldw	r2,-100(fp)
  152ec8:	1085883a 	add	r2,r2,r2
  152ecc:	1085883a 	add	r2,r2,r2
  152ed0:	1885883a 	add	r2,r3,r2
  152ed4:	10c00017 	ldw	r3,0(r2)
  152ed8:	010005b4 	movhi	r4,22
  152edc:	212a9c04 	addi	r4,r4,-21904
  152ee0:	e0bfe717 	ldw	r2,-100(fp)
  152ee4:	1085883a 	add	r2,r2,r2
  152ee8:	1085883a 	add	r2,r2,r2
  152eec:	2085883a 	add	r2,r4,r2
  152ef0:	10c00015 	stw	r3,0(r2)
    	}

    }

    // Update the saved trace arrays.
    for (i = 0; i < sample_size; i++) {
  152ef4:	e0bfe717 	ldw	r2,-100(fp)
  152ef8:	10800044 	addi	r2,r2,1
  152efc:	e0bfe715 	stw	r2,-100(fp)
  152f00:	d0a33017 	ldw	r2,-29504(gp)
  152f04:	e0ffe717 	ldw	r3,-100(fp)
  152f08:	18bfd016 	blt	r3,r2,152e4c <plot_trace+0x668>
    	saved_trace_B[i] = trace_B[i];
    	saved_trace_L[i] = trace_L[i];
    }

    // Output the scale if need be.
    set_display_scale(cur_scale);
  152f0c:	d0a32c17 	ldw	r2,-29520(gp)
  152f10:	1009883a 	mov	r4,r2
  152f14:	0151f5c0 	call	151f5c <set_display_scale>

    // Replace menu if need be.
    refresh_menu();
  152f18:	0150a480 	call	150a48 <refresh_menu>

    /* done with plot, return */
    return;
  152f1c:	0001883a 	nop

}
  152f20:	e037883a 	mov	sp,fp
  152f24:	dfc00117 	ldw	ra,4(sp)
  152f28:	df000017 	ldw	fp,0(sp)
  152f2c:	dec00204 	addi	sp,sp,8
  152f30:	f800283a 	ret

00152f34 <key_int_installer>:

.global key_int_installer
.type	key_int_installer, @function

key_int_installer:
	SAVE
  152f34:	deffff04 	addi	sp,sp,-4
  152f38:	dfc00015 	stw	ra,0(sp)
  152f3c:	deffff04 	addi	sp,sp,-4
  152f40:	df000015 	stw	fp,0(sp)
  152f44:	d839883a 	mov	fp,sp
  152f48:	02000574 	movhi	r8,21

	# asdf
	movia	r8, adc_speed
  152f4c:	42196c04 	addi	r8,r8,26032
	movi	r9, 0x040000
  152f50:	02400134 	movhi	r9,4
	stw		r9, (r8)
  152f54:	42400015 	stw	r9,0(r8)
  152f58:	02000574 	movhi	r8,21
	movia	r8, trig_level
  152f5c:	42196d84 	addi	r8,r8,26038
	movi	r9, 0
  152f60:	02400004 	movi	r9,0
	stb		r9, (r8)
  152f64:	42400005 	stb	r9,0(r8)
  152f68:	02000574 	movhi	r8,21
	movia	r8, trig_delay
  152f6c:	42196d04 	addi	r8,r8,26036
	movi	r9, 240
  152f70:	02403c04 	movi	r9,240
	sth		r9, (r8)
  152f74:	4240000d 	sth	r9,0(r8)
	# asdf

	# Enable all switch interrupts.
	movhi	r8, %hi(KEY_INPUT_BASE)
  152f78:	020005b4 	movhi	r8,22
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  152f7c:	42087c14 	ori	r8,r8,8688
	movhi	r9, %hi(SWITCH_ALL)
  152f80:	024003f4 	movhi	r9,15
	ori		r9, r9, %lo(SWITCH_ALL)
  152f84:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_IRQ_MASK(r8)
  152f88:	42400215 	stw	r9,8(r8)

	# Install the interrupt handler
	mov		r4, r0
  152f8c:	0009883a 	mov	r4,zero
	movi	r5, KEY_INPUT_IRQ
  152f90:	01400144 	movi	r5,5
	movhi	r6, %hi(key_handler)
  152f94:	01800574 	movhi	r6,21
	ori		r6, r6, %lo(key_handler)
  152f98:	318bf314 	ori	r6,r6,12236
	mov		r7, r0
  152f9c:	000f883a 	mov	r7,zero
	PUSH	r0
  152fa0:	deffff04 	addi	sp,sp,-4
  152fa4:	d8000015 	stw	zero,0(sp)
	call	alt_ic_isr_register
  152fa8:	0153dc40 	call	153dc4 <alt_ic_isr_register>
	POP		r0
  152fac:	d8000017 	ldw	zero,0(sp)
  152fb0:	dec00104 	addi	sp,sp,4

00152fb4 <key_int_installer_done>:

key_int_installer_done:
	RESTORE
  152fb4:	e037883a 	mov	sp,fp
  152fb8:	df000017 	ldw	fp,0(sp)
  152fbc:	dec00104 	addi	sp,sp,4
  152fc0:	dfc00017 	ldw	ra,0(sp)
  152fc4:	dec00104 	addi	sp,sp,4
	ret
  152fc8:	f800283a 	ret

00152fcc <key_handler>:
 */

.type key_handler,@function

key_handler:
	SAVE
  152fcc:	deffff04 	addi	sp,sp,-4
  152fd0:	dfc00015 	stw	ra,0(sp)
  152fd4:	deffff04 	addi	sp,sp,-4
  152fd8:	df000015 	stw	fp,0(sp)
  152fdc:	d839883a 	mov	fp,sp

	# Key should now be available. Update key_press.
	movi	r8, 1
  152fe0:	02000044 	movi	r8,1
  152fe4:	02400574 	movhi	r9,21
	movia	r9, key_press
  152fe8:	4a596804 	addi	r9,r9,26016
	stb		r8, (r9)
  152fec:	4a000005 	stb	r8,0(r9)

	# Clear interrupts.
	movhi	r8, %hi(KEY_INPUT_BASE)
  152ff0:	020005b4 	movhi	r8,22
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  152ff4:	42087c14 	ori	r8,r8,8688
	stw		r0, PIO_IRQ_MASK(r8)
  152ff8:	40000215 	stw	zero,8(r8)

	# Get the edge capture register.
	movhi	r8, %hi(KEY_INPUT_BASE)
  152ffc:	020005b4 	movhi	r8,22
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  153000:	42087c14 	ori	r8,r8,8688
	ldw		r8, PIO_EDGE_CAP(r8)
  153004:	42000317 	ldw	r8,12(r8)

	# Check each bit (starting at 0) and see if set.
	movi	r9, 1
  153008:	02400044 	movi	r9,1
	movi	r11, 0
  15300c:	02c00004 	movi	r11,0

00153010 <loop_keys>:

loop_keys:
	and		r10, r8, r9
  153010:	4254703a 	and	r10,r8,r9
	bne		r10, r0, key_lookup
  153014:	5000031e 	bne	r10,zero,153024 <key_lookup>
	slli	r9, r9, 1
  153018:	4812907a 	slli	r9,r9,1
	addi	r11, r11, 1
  15301c:	5ac00044 	addi	r11,r11,1
	br		loop_keys
  153020:	003ffb06 	br	153010 <loop_keys>

00153024 <key_lookup>:
  153024:	02000574 	movhi	r8,21

	# Once the key is found (r11), use the lookup table to set key_value.
key_lookup:
	movia	r8, key_map
  153028:	420c9104 	addi	r8,r8,12868
	add		r8, r8, r11
  15302c:	42d1883a 	add	r8,r8,r11
	ldb		r8,	(r8)
  153030:	42000007 	ldb	r8,0(r8)
  153034:	02800574 	movhi	r10,21

	movia	r10, key_value
  153038:	52996844 	addi	r10,r10,26017
	stb		r8, (r10)
  15303c:	52000005 	stb	r8,0(r10)
  153040:	01000574 	movhi	r4,21

	# Do a lookup (can't figure out how to get it to work with a table...).
	movia	r4, set_trigger_normal
  153044:	2103bb04 	addi	r4,r4,3820
	movi	r12, 5
  153048:	03000144 	movi	r12,5
	beq		r11, r12, call_action
  15304c:	5b003426 	beq	r11,r12,153120 <call_action>
  153050:	01000574 	movhi	r4,21
	movia	r4, set_trigger_single
  153054:	2103d804 	addi	r4,r4,3936
	movi	r12, 6
  153058:	03000184 	movi	r12,6
	beq		r11, r12, call_action
  15305c:	5b003026 	beq	r11,r12,153120 <call_action>
  153060:	01000574 	movhi	r4,21

	movia	r4, trg_slope_toggle
  153064:	21058b04 	addi	r4,r4,5676
	movi	r12, 7
  153068:	030001c4 	movi	r12,7
	beq		r11, r12, call_action
  15306c:	5b002c26 	beq	r11,r12,153120 <call_action>
  153070:	01000574 	movhi	r4,21
	movia	r4, trg_slope_toggle
  153074:	21058b04 	addi	r4,r4,5676
	movi	r12, 8
  153078:	03000204 	movi	r12,8
	beq		r11, r12, call_action
  15307c:	5b002826 	beq	r11,r12,153120 <call_action>
  153080:	01000574 	movhi	r4,21

	movia	r4, sweep_down
  153084:	2104bd04 	addi	r4,r4,4852
	movi	r12, 10
  153088:	03000284 	movi	r12,10
	beq		r11, r12, call_action
  15308c:	5b002426 	beq	r11,r12,153120 <call_action>
  153090:	01000574 	movhi	r4,21
	movia	r4, sweep_up
  153094:	2104dd04 	addi	r4,r4,4980
	movi	r12, 11
  153098:	030002c4 	movi	r12,11
	beq		r11, r12, call_action
  15309c:	5b002026 	beq	r11,r12,153120 <call_action>
  1530a0:	01000574 	movhi	r4,21

	movia	r4, trg_level_up
  1530a4:	21053e04 	addi	r4,r4,5368
	movi	r12, 16
  1530a8:	03000404 	movi	r12,16
	beq		r11, r12, call_action
  1530ac:	5b001c26 	beq	r11,r12,153120 <call_action>
  1530b0:	01000574 	movhi	r4,21
	movia	r4, trg_level_down
  1530b4:	21052a04 	addi	r4,r4,5288
	movi	r12, 17
  1530b8:	03000444 	movi	r12,17
	beq		r11, r12, call_action
  1530bc:	5b001826 	beq	r11,r12,153120 <call_action>
  1530c0:	01000574 	movhi	r4,21

	movia	r4, trg_delay_up
  1530c4:	2105e104 	addi	r4,r4,6020
	movi	r12, 18
  1530c8:	03000484 	movi	r12,18
	beq		r11, r12, call_action
  1530cc:	5b001426 	beq	r11,r12,153120 <call_action>
  1530d0:	01000574 	movhi	r4,21
	movia	r4, trg_delay_down
  1530d4:	2105ce04 	addi	r4,r4,5944
	movi	r12, 19
  1530d8:	030004c4 	movi	r12,19
	beq		r11, r12, call_action
  1530dc:	5b001026 	beq	r11,r12,153120 <call_action>

001530e0 <key_lookup_cont>:

key_lookup_cont:
	# Clear the edge capture register (write 1 to clear).
	movhi	r8, %hi(KEY_INPUT_BASE)
  1530e0:	020005b4 	movhi	r8,22
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  1530e4:	42087c14 	ori	r8,r8,8688
	movhi	r9, %hi(SWITCH_ALL)
  1530e8:	024003f4 	movhi	r9,15
	ori		r9, r9, %lo(SWITCH_ALL)
  1530ec:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_EDGE_CAP(r8)
  1530f0:	42400315 	stw	r9,12(r8)

	# Re-enable interrupts.
	movhi	r8, %hi(KEY_INPUT_BASE)
  1530f4:	020005b4 	movhi	r8,22
	ori		r8, r8, %lo(KEY_INPUT_BASE)
  1530f8:	42087c14 	ori	r8,r8,8688
	movhi	r9, %hi(SWITCH_ALL)
  1530fc:	024003f4 	movhi	r9,15
	ori		r9, r9, %lo(SWITCH_ALL)
  153100:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_IRQ_MASK(r8)
  153104:	42400215 	stw	r9,8(r8)

00153108 <key_handler_done>:

key_handler_done:
	RESTORE
  153108:	e037883a 	mov	sp,fp
  15310c:	df000017 	ldw	fp,0(sp)
  153110:	dec00104 	addi	sp,sp,4
  153114:	dfc00017 	ldw	ra,0(sp)
  153118:	dec00104 	addi	sp,sp,4
	ret
  15311c:	f800283a 	ret

00153120 <call_action>:


call_action:
	PUSH	r8
  153120:	deffff04 	addi	sp,sp,-4
  153124:	da000015 	stw	r8,0(sp)
	PUSH	r9
  153128:	deffff04 	addi	sp,sp,-4
  15312c:	da400015 	stw	r9,0(sp)
	PUSH	r10
  153130:	deffff04 	addi	sp,sp,-4
  153134:	da800015 	stw	r10,0(sp)
	PUSH	r11
  153138:	deffff04 	addi	sp,sp,-4
  15313c:	dac00015 	stw	r11,0(sp)
	PUSH	r12
  153140:	deffff04 	addi	sp,sp,-4
  153144:	db000015 	stw	r12,0(sp)
	PUSH	r13
  153148:	deffff04 	addi	sp,sp,-4
  15314c:	db400015 	stw	r13,0(sp)
	PUSH	r14
  153150:	deffff04 	addi	sp,sp,-4
  153154:	db800015 	stw	r14,0(sp)
	PUSH	r15
  153158:	deffff04 	addi	sp,sp,-4
  15315c:	dbc00015 	stw	r15,0(sp)

	callr	r4
  153160:	203ee83a 	callr	r4

	POP		r15
  153164:	dbc00017 	ldw	r15,0(sp)
  153168:	dec00104 	addi	sp,sp,4
	POP		r14
  15316c:	db800017 	ldw	r14,0(sp)
  153170:	dec00104 	addi	sp,sp,4
	POP		r13
  153174:	db400017 	ldw	r13,0(sp)
  153178:	dec00104 	addi	sp,sp,4
	POP		r12
  15317c:	db000017 	ldw	r12,0(sp)
  153180:	dec00104 	addi	sp,sp,4
	POP		r11
  153184:	dac00017 	ldw	r11,0(sp)
  153188:	dec00104 	addi	sp,sp,4
	POP		r10
  15318c:	da800017 	ldw	r10,0(sp)
  153190:	dec00104 	addi	sp,sp,4
	POP		r9
  153194:	da400017 	ldw	r9,0(sp)
  153198:	dec00104 	addi	sp,sp,4
	POP		r8
  15319c:	da000017 	ldw	r8,0(sp)
  1531a0:	dec00104 	addi	sp,sp,4
	br		key_lookup_cont
  1531a4:	003fce06 	br	1530e0 <key_lookup_cont>

001531a8 <key_available>:

.global key_available
.type	key_available, @function

key_available:
	SAVE
  1531a8:	deffff04 	addi	sp,sp,-4
  1531ac:	dfc00015 	stw	ra,0(sp)
  1531b0:	deffff04 	addi	sp,sp,-4
  1531b4:	df000015 	stw	fp,0(sp)
  1531b8:	d839883a 	mov	fp,sp
  1531bc:	00800574 	movhi	r2,21

	# Simply return the value in key_press.
	movia	r2, key_press
  1531c0:	10996804 	addi	r2,r2,26016
	ldb		r2, (r2)
  1531c4:	10800007 	ldb	r2,0(r2)

001531c8 <key_available_done>:

key_available_done:
	RESTORE
  1531c8:	e037883a 	mov	sp,fp
  1531cc:	df000017 	ldw	fp,0(sp)
  1531d0:	dec00104 	addi	sp,sp,4
  1531d4:	dfc00017 	ldw	ra,0(sp)
  1531d8:	dec00104 	addi	sp,sp,4
	ret
  1531dc:	f800283a 	ret

001531e0 <getkey>:

.global	getkey
.type	getkey, @function

getkey:
	SAVE
  1531e0:	deffff04 	addi	sp,sp,-4
  1531e4:	dfc00015 	stw	ra,0(sp)
  1531e8:	deffff04 	addi	sp,sp,-4
  1531ec:	df000015 	stw	fp,0(sp)
  1531f0:	d839883a 	mov	fp,sp
  1531f4:	02000574 	movhi	r8,21

	# Block until legal key arrives (which is also when key_press = TRUE).
	movia	r8, key_value
  1531f8:	42196844 	addi	r8,r8,26017
	ldb		r8, (r8)
  1531fc:	42000007 	ldb	r8,0(r8)
	movi	r9, KEY_ILLEGAL
  153200:	02400184 	movi	r9,6
	beq		r8, r9, getkey
  153204:	427ff626 	beq	r8,r9,1531e0 <getkey>
  153208:	00800574 	movhi	r2,21

	# Get return value.
	movia	r2, key_value
  15320c:	10996844 	addi	r2,r2,26017
	ldb		r2, (r2)
  153210:	10800007 	ldb	r2,0(r2)
  153214:	02800574 	movhi	r10,21

	# Update key_value with KEY_ILLEGAL.
	movia	r10, key_value
  153218:	52996844 	addi	r10,r10,26017
	stb		r9, (r10)
  15321c:	52400005 	stb	r9,0(r10)
  153220:	02800574 	movhi	r10,21

	# Update key_press with FALSE.
	movia	r10, key_press
  153224:	52996804 	addi	r10,r10,26016
	stb		r0, (r10)
  153228:	50000005 	stb	zero,0(r10)

0015322c <getkey_done>:

getkey_done:
	RESTORE
  15322c:	e037883a 	mov	sp,fp
  153230:	df000017 	ldw	fp,0(sp)
  153234:	dec00104 	addi	sp,sp,4
  153238:	dfc00017 	ldw	ra,0(sp)
  15323c:	dec00104 	addi	sp,sp,4
	ret
  153240:	f800283a 	ret

00153244 <key_map>:
  153244:	03020100 	call	302010 <__alt_mem_EPCS_ctrl+0x1a1010>
  153248:	00000004 	movi	zero,0
	...
  153258:	00000006 	br	15325c <adc_int_installer>

0015325c <adc_int_installer>:

.global adc_int_installer
.type	adc_int_installer, @function

adc_int_installer:
	SAVE
  15325c:	deffff04 	addi	sp,sp,-4
  153260:	dfc00015 	stw	ra,0(sp)
  153264:	deffff04 	addi	sp,sp,-4
  153268:	df000015 	stw	fp,0(sp)
  15326c:	d839883a 	mov	fp,sp

	# Set FIFO speed
	STWI	ADC_RATE_BASE, 0x040000
  153270:	deffff04 	addi	sp,sp,-4
  153274:	da400015 	stw	r9,0(sp)
  153278:	deffff04 	addi	sp,sp,-4
  15327c:	da800015 	stw	r10,0(sp)
  153280:	024005b4 	movhi	r9,22
  153284:	4a487414 	ori	r9,r9,8656
  153288:	02800134 	movhi	r10,4
  15328c:	52800134 	orhi	r10,r10,4
  153290:	4a800035 	stwio	r10,0(r9)
  153294:	da800017 	ldw	r10,0(sp)
  153298:	dec00104 	addi	sp,sp,4
  15329c:	da400017 	ldw	r9,0(sp)
  1532a0:	dec00104 	addi	sp,sp,4

	# Set Trigger default level (2's complement), delay
	STWI	TRIG_LEVEL_BASE, 0
  1532a4:	deffff04 	addi	sp,sp,-4
  1532a8:	da400015 	stw	r9,0(sp)
  1532ac:	deffff04 	addi	sp,sp,-4
  1532b0:	da800015 	stw	r10,0(sp)
  1532b4:	024005b4 	movhi	r9,22
  1532b8:	4a484014 	ori	r9,r9,8448
  1532bc:	02800034 	movhi	r10,0
  1532c0:	52800014 	ori	r10,r10,0
  1532c4:	4a800035 	stwio	r10,0(r9)
  1532c8:	da800017 	ldw	r10,0(sp)
  1532cc:	dec00104 	addi	sp,sp,4
  1532d0:	da400017 	ldw	r9,0(sp)
  1532d4:	dec00104 	addi	sp,sp,4
	STWI	TRIG_DELAY_BASE, 240
  1532d8:	deffff04 	addi	sp,sp,-4
  1532dc:	da400015 	stw	r9,0(sp)
  1532e0:	deffff04 	addi	sp,sp,-4
  1532e4:	da800015 	stw	r10,0(sp)
  1532e8:	024005b4 	movhi	r9,22
  1532ec:	4a483814 	ori	r9,r9,8416
  1532f0:	02800034 	movhi	r10,0
  1532f4:	52803c14 	ori	r10,r10,240
  1532f8:	4a800035 	stwio	r10,0(r9)
  1532fc:	da800017 	ldw	r10,0(sp)
  153300:	dec00104 	addi	sp,sp,4
  153304:	da400017 	ldw	r9,0(sp)
  153308:	dec00104 	addi	sp,sp,4
	STWI	TRIG_ERROR_BASE, 8
  15330c:	deffff04 	addi	sp,sp,-4
  153310:	da400015 	stw	r9,0(sp)
  153314:	deffff04 	addi	sp,sp,-4
  153318:	da800015 	stw	r10,0(sp)
  15331c:	024005b4 	movhi	r9,22
  153320:	4a487014 	ori	r9,r9,8640
  153324:	02800034 	movhi	r10,0
  153328:	52800214 	ori	r10,r10,8
  15332c:	4a800035 	stwio	r10,0(r9)
  153330:	da800017 	ldw	r10,0(sp)
  153334:	dec00104 	addi	sp,sp,4
  153338:	da400017 	ldw	r9,0(sp)
  15333c:	dec00104 	addi	sp,sp,4

	# Install the interrupt handler
	mov		r4, r0
  153340:	0009883a 	mov	r4,zero
	movi	r5, 6
  153344:	01400184 	movi	r5,6
	MOVWI	r6, adc_int_handler
  153348:	01800574 	movhi	r6,21
  15334c:	318ce514 	ori	r6,r6,13204
	mov		r7, r0
  153350:	000f883a 	mov	r7,zero
	PUSH	r0
  153354:	deffff04 	addi	sp,sp,-4
  153358:	d8000015 	stw	zero,0(sp)
	call	alt_ic_isr_register
  15335c:	0153dc40 	call	153dc4 <alt_ic_isr_register>
	POP		r0
  153360:	d8000017 	ldw	zero,0(sp)
  153364:	dec00104 	addi	sp,sp,4

	# Clear the edge capture register (write 1 to clear).
	MOVWI	r8, TRIG_INT_BASE
  153368:	020005b4 	movhi	r8,22
  15336c:	42085814 	ori	r8,r8,8544
	MOVWI	r9, 0xFFFFFFFF
  153370:	027ffff4 	movhi	r9,65535
  153374:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_EDGE_CAP(r8)
  153378:	42400315 	stw	r9,12(r8)

0015337c <adc_int_installer_done>:

adc_int_installer_done:
	RESTORE
  15337c:	e037883a 	mov	sp,fp
  153380:	df000017 	ldw	fp,0(sp)
  153384:	dec00104 	addi	sp,sp,4
  153388:	dfc00017 	ldw	ra,0(sp)
  15338c:	dec00104 	addi	sp,sp,4
	ret
  153390:	f800283a 	ret

00153394 <adc_int_handler>:

.global adc_int_handler
.type adc_int_handler, @function

adc_int_handler:
	SAVE
  153394:	deffff04 	addi	sp,sp,-4
  153398:	dfc00015 	stw	ra,0(sp)
  15339c:	deffff04 	addi	sp,sp,-4
  1533a0:	df000015 	stw	fp,0(sp)
  1533a4:	d839883a 	mov	fp,sp

	# Clear interrupts.
	MOVWI	r8, TRIG_INT_BASE
  1533a8:	020005b4 	movhi	r8,22
  1533ac:	42085814 	ori	r8,r8,8544
	stw		r0, PIO_IRQ_MASK(r8)
  1533b0:	40000215 	stw	zero,8(r8)

	# Get the edge capture register.
	ldw		r9, PIO_EDGE_CAP(r8)
  1533b4:	42400317 	ldw	r9,12(r8)

	# Pause FIFO write.
	STWI	ADC_CTRL_BASE, 0x00
  1533b8:	deffff04 	addi	sp,sp,-4
  1533bc:	da400015 	stw	r9,0(sp)
  1533c0:	deffff04 	addi	sp,sp,-4
  1533c4:	da800015 	stw	r10,0(sp)
  1533c8:	024005b4 	movhi	r9,22
  1533cc:	4a485014 	ori	r9,r9,8512
  1533d0:	02800034 	movhi	r10,0
  1533d4:	52800014 	ori	r10,r10,0
  1533d8:	4a800035 	stwio	r10,0(r9)
  1533dc:	da800017 	ldw	r10,0(sp)
  1533e0:	dec00104 	addi	sp,sp,4
  1533e4:	da400017 	ldw	r9,0(sp)
  1533e8:	dec00104 	addi	sp,sp,4

	# Loop variable to clear front of fifo
	mov		r10, r0
  1533ec:	0015883a 	mov	r10,zero
  1533f0:	02000574 	movhi	r8,21

	# Set specially-designed delay offsets based on which fifo source clock is being used.
	movia	r8, fifo_clk_src
  1533f4:	42197104 	addi	r8,r8,26052
	ldb		r9, (r8)
  1533f8:	42400007 	ldb	r9,0(r8)
	beq		r9, r0, adc_int_handler_fast_clk_offset
  1533fc:	48000226 	beq	r9,zero,153408 <adc_int_handler_fast_clk_offset>

00153400 <adc_int_handler_1M_clk_offset>:

adc_int_handler_1M_clk_offset:
	movi	r13, 15
  153400:	034003c4 	movi	r13,15
	br		adc_int_handler_clear_front
  153404:	00000106 	br	15340c <adc_int_handler_clear_front>

00153408 <adc_int_handler_fast_clk_offset>:

adc_int_handler_fast_clk_offset:
	movi	r13, 22
  153408:	03400584 	movi	r13,22

0015340c <adc_int_handler_clear_front>:

adc_int_handler_clear_front:
	# Bitbang clock pulse.
	STWI	ADC_CTRL_BASE, 0x01
  15340c:	deffff04 	addi	sp,sp,-4
  153410:	da400015 	stw	r9,0(sp)
  153414:	deffff04 	addi	sp,sp,-4
  153418:	da800015 	stw	r10,0(sp)
  15341c:	024005b4 	movhi	r9,22
  153420:	4a485014 	ori	r9,r9,8512
  153424:	02800034 	movhi	r10,0
  153428:	52800054 	ori	r10,r10,1
  15342c:	4a800035 	stwio	r10,0(r9)
  153430:	da800017 	ldw	r10,0(sp)
  153434:	dec00104 	addi	sp,sp,4
  153438:	da400017 	ldw	r9,0(sp)
  15343c:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x00
  153440:	deffff04 	addi	sp,sp,-4
  153444:	da400015 	stw	r9,0(sp)
  153448:	deffff04 	addi	sp,sp,-4
  15344c:	da800015 	stw	r10,0(sp)
  153450:	024005b4 	movhi	r9,22
  153454:	4a485014 	ori	r9,r9,8512
  153458:	02800034 	movhi	r10,0
  15345c:	52800014 	ori	r10,r10,0
  153460:	4a800035 	stwio	r10,0(r9)
  153464:	da800017 	ldw	r10,0(sp)
  153468:	dec00104 	addi	sp,sp,4
  15346c:	da400017 	ldw	r9,0(sp)
  153470:	dec00104 	addi	sp,sp,4

	# Keep going until 480 good remaining points (for display)
	addi	r10, r10, 1
  153474:	52800044 	addi	r10,r10,1
	bltu	r10, r13, adc_int_handler_clear_front
  153478:	537fe436 	bltu	r10,r13,15340c <adc_int_handler_clear_front>
  15347c:	02000574 	movhi	r8,21

	movia	r8, sample_buffer_A
  153480:	42197204 	addi	r8,r8,26056
	mov		r10, r0
  153484:	0015883a 	mov	r10,zero

00153488 <adc_int_handler_loop>:

adc_int_handler_loop:
	# Bitbang clock pulse.
	STWI	ADC_CTRL_BASE, 0x01
  153488:	deffff04 	addi	sp,sp,-4
  15348c:	da400015 	stw	r9,0(sp)
  153490:	deffff04 	addi	sp,sp,-4
  153494:	da800015 	stw	r10,0(sp)
  153498:	024005b4 	movhi	r9,22
  15349c:	4a485014 	ori	r9,r9,8512
  1534a0:	02800034 	movhi	r10,0
  1534a4:	52800054 	ori	r10,r10,1
  1534a8:	4a800035 	stwio	r10,0(r9)
  1534ac:	da800017 	ldw	r10,0(sp)
  1534b0:	dec00104 	addi	sp,sp,4
  1534b4:	da400017 	ldw	r9,0(sp)
  1534b8:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x00
  1534bc:	deffff04 	addi	sp,sp,-4
  1534c0:	da400015 	stw	r9,0(sp)
  1534c4:	deffff04 	addi	sp,sp,-4
  1534c8:	da800015 	stw	r10,0(sp)
  1534cc:	024005b4 	movhi	r9,22
  1534d0:	4a485014 	ori	r9,r9,8512
  1534d4:	02800034 	movhi	r10,0
  1534d8:	52800014 	ori	r10,r10,0
  1534dc:	4a800035 	stwio	r10,0(r9)
  1534e0:	da800017 	ldw	r10,0(sp)
  1534e4:	dec00104 	addi	sp,sp,4
  1534e8:	da400017 	ldw	r9,0(sp)
  1534ec:	dec00104 	addi	sp,sp,4

	# Get ch. A, ch. B, and logic data.
	MOVWI	r11, ADC_RAW_BASE
  1534f0:	02c005b4 	movhi	r11,22
  1534f4:	5ac87814 	ori	r11,r11,8672
	ldwio	r12, (r11)
  1534f8:	5b000037 	ldwio	r12,0(r11)

	# r12 for ch. A, r13 for ch. B, r14 for logic.
	srli	r13, r12, 8
  1534fc:	601ad23a 	srli	r13,r12,8
	srli	r14, r13, 8
  153500:	681cd23a 	srli	r14,r13,8
	movui	r15, 128
  153504:	03c02014 	movui	r15,128

	# Convert analog channels to non-signed values.
	add		r12, r12, r15
  153508:	63d9883a 	add	r12,r12,r15
	add		r13, r13, r15
  15350c:	6bdb883a 	add	r13,r13,r15

	# Keep only the bottom byte.
	andi	r12, r12, 0xFF
  153510:	63003fcc 	andi	r12,r12,255
	andi	r13, r13, 0xFF
  153514:	6b403fcc 	andi	r13,r13,255
	andi	r14, r14, 0xFF
  153518:	73803fcc 	andi	r14,r14,255
  15351c:	02000574 	movhi	r8,21

	# CH. A
	# Retrieve the current buffer contents.
	# Then update the current buffer with the new value.
	movia	r8, sample_buffer_A
  153520:	42197204 	addi	r8,r8,26056
	add		r8, r8, r10
  153524:	4291883a 	add	r8,r8,r10
	stb		r12, (r8)
  153528:	43000005 	stb	r12,0(r8)
  15352c:	02000574 	movhi	r8,21

	# CH. B
	# Retrieve the current buffer contents.
	# Then update the current buffer with the new value.
	movia	r8, sample_buffer_B
  153530:	4219ea04 	addi	r8,r8,26536
	add		r8, r8, r10
  153534:	4291883a 	add	r8,r8,r10
	stb		r13, (r8)
  153538:	43400005 	stb	r13,0(r8)
  15353c:	02000574 	movhi	r8,21

	# LOGIC ANALYZER
	# Retrieve the current buffer contents.
	# Then update the current buffer with the new value.
	movia	r8, sample_buffer_L
  153540:	421a6204 	addi	r8,r8,27016
	add		r8, r8, r10
  153544:	4291883a 	add	r8,r8,r10
	stb		r14, (r8)
  153548:	43800005 	stb	r14,0(r8)

	addi	r10, r10, 1
  15354c:	52800044 	addi	r10,r10,1
	movi	r15, 480
  153550:	03c07804 	movi	r15,480
	bltu	r10, r15, adc_int_handler_loop
  153554:	53ffcc36 	bltu	r10,r15,153488 <adc_int_handler_loop>
  153558:	02000574 	movhi	r8,21

	# Sample done.
	movia	r8, sample_complete
  15355c:	42197004 	addi	r8,r8,26048
	movi	r9, 1
  153560:	02400044 	movi	r9,1
	stb		r9, (r8)
  153564:	42400005 	stb	r9,0(r8)

00153568 <adc_int_handler_done>:

adc_int_handler_done:

	RESTORE
  153568:	e037883a 	mov	sp,fp
  15356c:	df000017 	ldw	fp,0(sp)
  153570:	dec00104 	addi	sp,sp,4
  153574:	dfc00017 	ldw	ra,0(sp)
  153578:	dec00104 	addi	sp,sp,4
	ret
  15357c:	f800283a 	ret

00153580 <draw_trace>:

.global draw_trace
.type draw_trace, @function

draw_trace:
	SAVE
  153580:	deffff04 	addi	sp,sp,-4
  153584:	dfc00015 	stw	ra,0(sp)
  153588:	deffff04 	addi	sp,sp,-4
  15358c:	df000015 	stw	fp,0(sp)
  153590:	d839883a 	mov	fp,sp
	push	r4
  153594:	deffff04 	addi	sp,sp,-4
  153598:	d9000015 	stw	r4,0(sp)
	push	r5
  15359c:	deffff04 	addi	sp,sp,-4
  1535a0:	d9400015 	stw	r5,0(sp)
	push	r6
  1535a4:	deffff04 	addi	sp,sp,-4
  1535a8:	d9800015 	stw	r6,0(sp)
  1535ac:	02000574 	movhi	r8,21

	movia	r8, sample_buffer_A
  1535b0:	42197204 	addi	r8,r8,26056
	mov		r10, r0
  1535b4:	0015883a 	mov	r10,zero

001535b8 <draw_trace_loop>:

draw_trace_loop:
	ldb		r12, (r8)
  1535b8:	43000007 	ldb	r12,0(r8)
	movui	r15, 255
  1535bc:	03c03fd4 	movui	r15,255
	sub		r12, r15, r12
  1535c0:	7b19c83a 	sub	r12,r15,r12
	andi	r12, r12, 0xFF
  1535c4:	63003fcc 	andi	r12,r12,255
	addi	r12, r12, 8
  1535c8:	63000204 	addi	r12,r12,8

	MOVWI	r9, VRAM_CTRL_BASE
  1535cc:	02400234 	movhi	r9,8
  1535d0:	4a400234 	orhi	r9,r9,8
	add		r9, r9, r10
  1535d4:	4a93883a 	add	r9,r9,r10
	add		r9, r9, r10
  1535d8:	4a93883a 	add	r9,r9,r10

	mov		r11, r0
  1535dc:	0017883a 	mov	r11,zero

001535e0 <draw_trace_col_loop>:
draw_trace_col_loop:
	MOVWI	r15, 0x001C
  1535e0:	03c00034 	movhi	r15,0
  1535e4:	7bc00714 	ori	r15,r15,28
	sthio	r15, (r9)
  1535e8:	4bc0002d 	sthio	r15,0(r9)

	movi	r15, 136
  1535ec:	03c02204 	movi	r15,136
	beq		r11, r15, draw_grid_pt
  1535f0:	5bc01726 	beq	r11,r15,153650 <draw_grid_pt>

	movi	r15, 240
  1535f4:	03c03c04 	movi	r15,240
	beq		r10, r15, draw_grid_pt
  1535f8:	53c01526 	beq	r10,r15,153650 <draw_grid_pt>

	beq		r11, r12, draw_trace_pt
  1535fc:	5b001826 	beq	r11,r12,153660 <draw_trace_pt>

00153600 <draw_trace_col_loop_continue>:

draw_trace_col_loop_continue:
	addi	r9, r9, 0x400
  153600:	4a410004 	addi	r9,r9,1024
	addi	r11, r11, 1
  153604:	5ac00044 	addi	r11,r11,1
	movi	r15, 272
  153608:	03c04404 	movi	r15,272
	bltu	r11, r15, draw_trace_col_loop
  15360c:	5bfff436 	bltu	r11,r15,1535e0 <draw_trace_col_loop>

	addi	r8, r8, 1
  153610:	42000044 	addi	r8,r8,1
	addi	r10, r10, 1
  153614:	52800044 	addi	r10,r10,1
	movi	r15, 480
  153618:	03c07804 	movi	r15,480
	bltu	r10, r15, draw_trace_loop
  15361c:	53ffe636 	bltu	r10,r15,1535b8 <draw_trace_loop>

00153620 <draw_trace_done>:

draw_trace_done:
	pop		r6
  153620:	d9800017 	ldw	r6,0(sp)
  153624:	dec00104 	addi	sp,sp,4
	pop		r5
  153628:	d9400017 	ldw	r5,0(sp)
  15362c:	dec00104 	addi	sp,sp,4
	pop		r4
  153630:	d9000017 	ldw	r4,0(sp)
  153634:	dec00104 	addi	sp,sp,4
	RESTORE
  153638:	e037883a 	mov	sp,fp
  15363c:	df000017 	ldw	fp,0(sp)
  153640:	dec00104 	addi	sp,sp,4
  153644:	dfc00017 	ldw	ra,0(sp)
  153648:	dec00104 	addi	sp,sp,4
	ret
  15364c:	f800283a 	ret

00153650 <draw_grid_pt>:

draw_grid_pt:
	MOVWI	r15, 0x1F00
  153650:	03c00034 	movhi	r15,0
  153654:	7bc7c014 	ori	r15,r15,7936
	sthio	r15, (r9)
  153658:	4bc0002d 	sthio	r15,0(r9)
	br		draw_trace_col_loop_continue
  15365c:	003fe806 	br	153600 <draw_trace_col_loop_continue>

00153660 <draw_trace_pt>:

draw_trace_pt:
	MOVWI	r15, 0xE07F
  153660:	03c00034 	movhi	r15,0
  153664:	7bf81fd4 	ori	r15,r15,57471
	sthio	r15, (r9)
  153668:	4bc0002d 	sthio	r15,0(r9)
	br		draw_trace_col_loop_continue
  15366c:	003fe406 	br	153600 <draw_trace_col_loop_continue>

00153670 <draw_grid>:

.global draw_grid
.type draw_grid, @function

draw_grid:
	SAVE
  153670:	deffff04 	addi	sp,sp,-4
  153674:	dfc00015 	stw	ra,0(sp)
  153678:	deffff04 	addi	sp,sp,-4
  15367c:	df000015 	stw	fp,0(sp)
  153680:	d839883a 	mov	fp,sp
	push	r4
  153684:	deffff04 	addi	sp,sp,-4
  153688:	d9000015 	stw	r4,0(sp)
	push	r5
  15368c:	deffff04 	addi	sp,sp,-4
  153690:	d9400015 	stw	r5,0(sp)
	push	r6
  153694:	deffff04 	addi	sp,sp,-4
  153698:	d9800015 	stw	r6,0(sp)

	movui	r6, 0x1F00
  15369c:	0187c014 	movui	r6,7936

	movui	r4, 136
  1536a0:	01002214 	movui	r4,136
	mov		r5, r0
  1536a4:	000b883a 	mov	r5,zero

001536a8 <draw_grid_horiz>:
draw_grid_horiz:
	call	draw_pixel
  1536a8:	01537240 	call	153724 <draw_pixel>
	movui	r6, 0x003C
  1536ac:	01800f14 	movui	r6,60
	addi	r4, r4, 1
  1536b0:	21000044 	addi	r4,r4,1
	call	draw_pixel
  1536b4:	01537240 	call	153724 <draw_pixel>
	addi	r4, r4, 1
  1536b8:	21000044 	addi	r4,r4,1
	call	draw_pixel
  1536bc:	01537240 	call	153724 <draw_pixel>
	addi	r4, r4, 1
  1536c0:	21000044 	addi	r4,r4,1
	call	draw_pixel
  1536c4:	01537240 	call	153724 <draw_pixel>
	movui	r6, 0x1F00
  1536c8:	0187c014 	movui	r6,7936
	subi	r4, r4, 3
  1536cc:	213fff44 	addi	r4,r4,-3

	addi	r5, r5, 1
  1536d0:	29400044 	addi	r5,r5,1
	movi	r8, 480
  1536d4:	02007804 	movi	r8,480
	bltu	r5, r8, draw_grid_horiz
  1536d8:	2a3ff336 	bltu	r5,r8,1536a8 <draw_grid_horiz>

	mov		r4, r0
  1536dc:	0009883a 	mov	r4,zero
	movui	r5, 240
  1536e0:	01403c14 	movui	r5,240

001536e4 <draw_grid_vert>:
draw_grid_vert:
	call	draw_pixel
  1536e4:	01537240 	call	153724 <draw_pixel>

	addi	r4, r4, 1
  1536e8:	21000044 	addi	r4,r4,1
	movi	r8, 272
  1536ec:	02004404 	movi	r8,272
	bltu	r4, r8, draw_grid_vert
  1536f0:	223ffc36 	bltu	r4,r8,1536e4 <draw_grid_vert>

001536f4 <draw_grid_done>:

draw_grid_done:
	pop		r6
  1536f4:	d9800017 	ldw	r6,0(sp)
  1536f8:	dec00104 	addi	sp,sp,4
	pop		r5
  1536fc:	d9400017 	ldw	r5,0(sp)
  153700:	dec00104 	addi	sp,sp,4
	pop		r4
  153704:	d9000017 	ldw	r4,0(sp)
  153708:	dec00104 	addi	sp,sp,4
	RESTORE
  15370c:	e037883a 	mov	sp,fp
  153710:	df000017 	ldw	fp,0(sp)
  153714:	dec00104 	addi	sp,sp,4
  153718:	dfc00017 	ldw	ra,0(sp)
  15371c:	dec00104 	addi	sp,sp,4
	ret
  153720:	f800283a 	ret

00153724 <draw_pixel>:


draw_pixel:
	SAVE
  153724:	deffff04 	addi	sp,sp,-4
  153728:	dfc00015 	stw	ra,0(sp)
  15372c:	deffff04 	addi	sp,sp,-4
  153730:	df000015 	stw	fp,0(sp)
  153734:	d839883a 	mov	fp,sp

	push	r4
  153738:	deffff04 	addi	sp,sp,-4
  15373c:	d9000015 	stw	r4,0(sp)
	push	r5
  153740:	deffff04 	addi	sp,sp,-4
  153744:	d9400015 	stw	r5,0(sp)

	slli	r4, r4, 10
  153748:	200892ba 	slli	r4,r4,10
	add		r4, r4, r5
  15374c:	2149883a 	add	r4,r4,r5
	add		r4, r4, r5
  153750:	2149883a 	add	r4,r4,r5
	MOVWI	r5, VRAM_CTRL_BASE
  153754:	01400234 	movhi	r5,8
  153758:	29400234 	orhi	r5,r5,8
	add		r4, r4, r5
  15375c:	2149883a 	add	r4,r4,r5
	sth		r6, (r4)
  153760:	2180000d 	sth	r6,0(r4)

	pop		r5
  153764:	d9400017 	ldw	r5,0(sp)
  153768:	dec00104 	addi	sp,sp,4
	pop		r4
  15376c:	d9000017 	ldw	r4,0(sp)
  153770:	dec00104 	addi	sp,sp,4

00153774 <draw_pixel_done>:

draw_pixel_done:
	RESTORE
  153774:	e037883a 	mov	sp,fp
  153778:	df000017 	ldw	fp,0(sp)
  15377c:	dec00104 	addi	sp,sp,4
  153780:	dfc00017 	ldw	ra,0(sp)
  153784:	dec00104 	addi	sp,sp,4
	ret
  153788:	f800283a 	ret

0015378c <clear_display>:

.global clear_display
.type clear_display, @function

clear_display:
	SAVE
  15378c:	deffff04 	addi	sp,sp,-4
  153790:	dfc00015 	stw	ra,0(sp)
  153794:	deffff04 	addi	sp,sp,-4
  153798:	df000015 	stw	fp,0(sp)
  15379c:	d839883a 	mov	fp,sp

	# Get display address and background color.
	MOVWI	r8, VRAM_CTRL_BASE
  1537a0:	02000234 	movhi	r8,8
  1537a4:	42000234 	orhi	r8,r8,8
	movui	r9, 272
  1537a8:	02404414 	movui	r9,272
	slli	r9, r9, 10
  1537ac:	481292ba 	slli	r9,r9,10
	add		r9, r8, r9
  1537b0:	4253883a 	add	r9,r8,r9
	movui	r15, 0x001C
  1537b4:	03c00714 	movui	r15,28

001537b8 <clear_display_loop>:

	# Loop over all screen pixels, clearing them.
clear_display_loop:
	sthio 	r15, (r8)
  1537b8:	43c0002d 	sthio	r15,0(r8)
	addi	r8, r8, 2
  1537bc:	42000084 	addi	r8,r8,2
	bltu	r8, r9, clear_display_loop
  1537c0:	427ffd36 	bltu	r8,r9,1537b8 <clear_display_loop>

001537c4 <clear_display_done>:

clear_display_done:
	RESTORE
  1537c4:	e037883a 	mov	sp,fp
  1537c8:	df000017 	ldw	fp,0(sp)
  1537cc:	dec00104 	addi	sp,sp,4
  1537d0:	dfc00017 	ldw	ra,0(sp)
  1537d4:	dec00104 	addi	sp,sp,4
	ret
  1537d8:	f800283a 	ret

001537dc <plot_pixel>:

.global plot_pixel
.type plot_pixel, @function

plot_pixel:
	SAVE
  1537dc:	deffff04 	addi	sp,sp,-4
  1537e0:	dfc00015 	stw	ra,0(sp)
  1537e4:	deffff04 	addi	sp,sp,-4
  1537e8:	df000015 	stw	fp,0(sp)
  1537ec:	d839883a 	mov	fp,sp

	push	r4
  1537f0:	deffff04 	addi	sp,sp,-4
  1537f4:	d9000015 	stw	r4,0(sp)
	push	r5
  1537f8:	deffff04 	addi	sp,sp,-4
  1537fc:	d9400015 	stw	r5,0(sp)

	# Each row takes 1024 bytes, so shift row var by 10 bits.
	slli	r5, r5, 10
  153800:	280a92ba 	slli	r5,r5,10
	# Add twice to account for 16-bit VRAM storage.
	add		r5, r5, r4
  153804:	290b883a 	add	r5,r5,r4
	add		r5, r5, r4
  153808:	290b883a 	add	r5,r5,r4
	# Now get the absolute address.
	MOVWI	r4, VRAM_CTRL_BASE
  15380c:	01000234 	movhi	r4,8
  153810:	21000234 	orhi	r4,r4,8
	add		r5, r5, r4
  153814:	290b883a 	add	r5,r5,r4
	# Store the color.
	sth		r6, (r5)
  153818:	2980000d 	sth	r6,0(r5)

	pop		r5
  15381c:	d9400017 	ldw	r5,0(sp)
  153820:	dec00104 	addi	sp,sp,4
	pop		r4
  153824:	d9000017 	ldw	r4,0(sp)
  153828:	dec00104 	addi	sp,sp,4

0015382c <plot_pixel_done>:

plot_pixel_done:
	RESTORE
  15382c:	e037883a 	mov	sp,fp
  153830:	df000017 	ldw	fp,0(sp)
  153834:	dec00104 	addi	sp,sp,4
  153838:	dfc00017 	ldw	ra,0(sp)
  15383c:	dec00104 	addi	sp,sp,4
	ret
  153840:	f800283a 	ret

00153844 <set_sample_rate>:

.global set_sample_rate
.type set_sample_rate, @function

set_sample_rate:
	SAVE
  153844:	deffff04 	addi	sp,sp,-4
  153848:	dfc00015 	stw	ra,0(sp)
  15384c:	deffff04 	addi	sp,sp,-4
  153850:	df000015 	stw	fp,0(sp)
  153854:	d839883a 	mov	fp,sp

	MOVWI	r9, 100000
  153858:	02400074 	movhi	r9,1
  15385c:	4a61a814 	ori	r9,r9,34464
	bleu	r4, r9, slow_sample_rate
  153860:	4900102e 	bgeu	r9,r4,1538a4 <slow_sample_rate>

00153864 <fast_sample_rate>:

fast_sample_rate:
	# Divide fastest sample rate by desired sample rate
	# to get number of ticks to pause (not collect samples)
	# between collecting samples.
	MOVWI	r8, ADC_RATE_BASE
  153864:	020005b4 	movhi	r8,22
  153868:	42087414 	ori	r8,r8,8656
	MOVWI	r9, 400000000
  15386c:	0245f5f4 	movhi	r9,6103
  153870:	4a610014 	ori	r9,r9,33792
	divu	r9, r9, r4
  153874:	4913203a 	divu	r9,r9,r4
	subi	r9, r9, 1
  153878:	4a7fffc4 	addi	r9,r9,-1
	stw		r9, (r8)
  15387c:	42400015 	stw	r9,0(r8)

	# Set fast clock for FIFO clock counter.
	MOVWI	r8, TRIG_CTRL_BASE
  153880:	020005b4 	movhi	r8,22
  153884:	42084814 	ori	r8,r8,8480
	MOVWI	r9, 0x00000080
  153888:	02400034 	movhi	r9,0
  15388c:	4a402014 	ori	r9,r9,128
	stw		r9, PIO_OUTCLR(r8)
  153890:	42400515 	stw	r9,20(r8)
  153894:	02000574 	movhi	r8,21

	# Update fifo source flag.
	movia	r8, fifo_clk_src
  153898:	42197104 	addi	r8,r8,26052
	stb		r0, (r8)
  15389c:	40000005 	stb	zero,0(r8)

	br		set_sample_rate_done
  1538a0:	00001006 	br	1538e4 <set_sample_rate_done>

001538a4 <slow_sample_rate>:

slow_sample_rate:
	# Divide fastest sample rate by desired sample rate
	# to get number of ticks to pause (not collect samples)
	# between collecting samples.
	MOVWI	r8, ADC_RATE_BASE
  1538a4:	020005b4 	movhi	r8,22
  1538a8:	42087414 	ori	r8,r8,8656
	MOVWI	r9, 1000000
  1538ac:	024003f4 	movhi	r9,15
  1538b0:	4a509014 	ori	r9,r9,16960
	divu	r9, r9, r4
  1538b4:	4913203a 	divu	r9,r9,r4
	subi	r9, r9, 1
  1538b8:	4a7fffc4 	addi	r9,r9,-1
	stw		r9, (r8)
  1538bc:	42400015 	stw	r9,0(r8)

	# Set 1MHz clock for FIFO clock counter.
	MOVWI	r8, TRIG_CTRL_BASE
  1538c0:	020005b4 	movhi	r8,22
  1538c4:	42084814 	ori	r8,r8,8480
	MOVWI	r9, 0x00000080
  1538c8:	02400034 	movhi	r9,0
  1538cc:	4a402014 	ori	r9,r9,128
	stw		r9, PIO_OUTSET(r8)
  1538d0:	42400415 	stw	r9,16(r8)
  1538d4:	02000574 	movhi	r8,21

	# Update fifo source flag.
	movia	r8, fifo_clk_src
  1538d8:	42197104 	addi	r8,r8,26052
	movi	r9, 1
  1538dc:	02400044 	movi	r9,1
	stb		r9, (r8)
  1538e0:	42400005 	stb	r9,0(r8)

001538e4 <set_sample_rate_done>:

set_sample_rate_done:
	# Always return 480 samples.
	movui	r2, 480
  1538e4:	00807814 	movui	r2,480

	RESTORE
  1538e8:	e037883a 	mov	sp,fp
  1538ec:	df000017 	ldw	fp,0(sp)
  1538f0:	dec00104 	addi	sp,sp,4
  1538f4:	dfc00017 	ldw	ra,0(sp)
  1538f8:	dec00104 	addi	sp,sp,4
	ret
  1538fc:	f800283a 	ret

00153900 <set_trigger>:

.global set_trigger
.type set_trigger, @function

set_trigger:
	SAVE
  153900:	deffff04 	addi	sp,sp,-4
  153904:	dfc00015 	stw	ra,0(sp)
  153908:	deffff04 	addi	sp,sp,-4
  15390c:	df000015 	stw	fp,0(sp)
  153910:	d839883a 	mov	fp,sp

	# Convert [0 to 127] to signed 8-bit [-127 to 127].
	# Then update trigger level.
	MOVWI	r8, TRIG_LEVEL_BASE
  153914:	020005b4 	movhi	r8,22
  153918:	42084014 	ori	r8,r8,8448
	slli	r9, r4, 1
  15391c:	2012907a 	slli	r9,r4,1
	subi	r9, r9, 127
  153920:	4a7fe044 	addi	r9,r9,-127
	andi	r9, r9, 0xFF
  153924:	4a403fcc 	andi	r9,r9,255
	stw		r9, (r8)
  153928:	42400015 	stw	r9,0(r8)

	# Slope is second bit of TRIG_CTRL. Modify the given
	# argument, then update slope.
	beq		r5, r0, set_trigger_slope_pos
  15392c:	28000526 	beq	r5,zero,153944 <set_trigger_slope_pos>
	movi	r8, 0x02
  153930:	02000084 	movi	r8,2
	MOVWI	r9, TRIG_CTRL_BASE
  153934:	024005b4 	movhi	r9,22
  153938:	4a484814 	ori	r9,r9,8480
	stw		r8, PIO_OUTSET(r9)
  15393c:	4a000415 	stw	r8,16(r9)
	br		set_trigger_done
  153940:	00000406 	br	153954 <set_trigger_done>

00153944 <set_trigger_slope_pos>:

set_trigger_slope_pos:
	movi	r8, 0x02
  153944:	02000084 	movi	r8,2
	MOVWI	r9, TRIG_CTRL_BASE
  153948:	024005b4 	movhi	r9,22
  15394c:	4a484814 	ori	r9,r9,8480
	stw		r8, PIO_OUTCLR(r9)
  153950:	4a000515 	stw	r8,20(r9)

00153954 <set_trigger_done>:

set_trigger_done:
	RESTORE
  153954:	e037883a 	mov	sp,fp
  153958:	df000017 	ldw	fp,0(sp)
  15395c:	dec00104 	addi	sp,sp,4
  153960:	dfc00017 	ldw	ra,0(sp)
  153964:	dec00104 	addi	sp,sp,4
	ret
  153968:	f800283a 	ret

0015396c <set_delay>:

.global set_delay
.type set_delay, @function

set_delay:
	SAVE
  15396c:	deffff04 	addi	sp,sp,-4
  153970:	dfc00015 	stw	ra,0(sp)
  153974:	deffff04 	addi	sp,sp,-4
  153978:	df000015 	stw	fp,0(sp)
  15397c:	d839883a 	mov	fp,sp

	# Simply set the delay (240 offset means delay 0 is in the middle).
	addi	r9, r4, 240
  153980:	22403c04 	addi	r9,r4,240
	MOVWI	r8, TRIG_DELAY_BASE
  153984:	020005b4 	movhi	r8,22
  153988:	42083814 	ori	r8,r8,8416
	stw		r9, (r8)
  15398c:	42400015 	stw	r9,0(r8)

00153990 <set_delay_done>:

set_delay_done:
	RESTORE
  153990:	e037883a 	mov	sp,fp
  153994:	df000017 	ldw	fp,0(sp)
  153998:	dec00104 	addi	sp,sp,4
  15399c:	dfc00017 	ldw	ra,0(sp)
  1539a0:	dec00104 	addi	sp,sp,4
	ret
  1539a4:	f800283a 	ret

001539a8 <start_sample>:

.global start_sample
.type start_sample, @function

start_sample:
	SAVE
  1539a8:	deffff04 	addi	sp,sp,-4
  1539ac:	dfc00015 	stw	ra,0(sp)
  1539b0:	deffff04 	addi	sp,sp,-4
  1539b4:	df000015 	stw	fp,0(sp)
  1539b8:	d839883a 	mov	fp,sp

	# Clear the edge capture register (write 1 to clear).
	MOVWI	r8, TRIG_INT_BASE
  1539bc:	020005b4 	movhi	r8,22
  1539c0:	42085814 	ori	r8,r8,8544
	MOVWI	r9, 0xFFFFFFFF
  1539c4:	027ffff4 	movhi	r9,65535
  1539c8:	4a7fffd4 	ori	r9,r9,65535
	stw		r9, PIO_EDGE_CAP(r8)
  1539cc:	42400315 	stw	r9,12(r8)

	# Enable trigger interrupts.
	MOVWI	r9, 0x00000002
  1539d0:	02400034 	movhi	r9,0
  1539d4:	4a400094 	ori	r9,r9,2
	# If auto-trigger, enable time-outs as well.
	slli	r8, r4, 2
  1539d8:	201090ba 	slli	r8,r4,2
	add		r9, r8, r9
  1539dc:	4253883a 	add	r9,r8,r9

	MOVWI	r8, TRIG_INT_BASE
  1539e0:	020005b4 	movhi	r8,22
  1539e4:	42085814 	ori	r8,r8,8544
	stw		r9, PIO_IRQ_MASK(r8)
  1539e8:	42400215 	stw	r9,8(r8)

	# Clear FIFO, turn on FIFO write.
	STWI	ADC_CTRL_BASE, 0x04
  1539ec:	deffff04 	addi	sp,sp,-4
  1539f0:	da400015 	stw	r9,0(sp)
  1539f4:	deffff04 	addi	sp,sp,-4
  1539f8:	da800015 	stw	r10,0(sp)
  1539fc:	024005b4 	movhi	r9,22
  153a00:	4a485014 	ori	r9,r9,8512
  153a04:	02800034 	movhi	r10,0
  153a08:	52800114 	ori	r10,r10,4
  153a0c:	4a800035 	stwio	r10,0(r9)
  153a10:	da800017 	ldw	r10,0(sp)
  153a14:	dec00104 	addi	sp,sp,4
  153a18:	da400017 	ldw	r9,0(sp)
  153a1c:	dec00104 	addi	sp,sp,4
	STWI	ADC_CTRL_BASE, 0x02
  153a20:	deffff04 	addi	sp,sp,-4
  153a24:	da400015 	stw	r9,0(sp)
  153a28:	deffff04 	addi	sp,sp,-4
  153a2c:	da800015 	stw	r10,0(sp)
  153a30:	024005b4 	movhi	r9,22
  153a34:	4a485014 	ori	r9,r9,8512
  153a38:	02800034 	movhi	r10,0
  153a3c:	52800094 	ori	r10,r10,2
  153a40:	4a800035 	stwio	r10,0(r9)
  153a44:	da800017 	ldw	r10,0(sp)
  153a48:	dec00104 	addi	sp,sp,4
  153a4c:	da400017 	ldw	r9,0(sp)
  153a50:	dec00104 	addi	sp,sp,4

	# Restart trigger counter [ch. A], [+ slope]
	MOVWI	r8, TRIG_CTRL_BASE
  153a54:	020005b4 	movhi	r8,22
  153a58:	42084814 	ori	r8,r8,8480
	movi	r9, 1
  153a5c:	02400044 	movi	r9,1
	stw		r9, PIO_OUTSET(r8)
  153a60:	42400415 	stw	r9,16(r8)
	stw		r9, PIO_OUTCLR(r8)
  153a64:	42400515 	stw	r9,20(r8)

00153a68 <start_sample_done>:

start_sample_done:
	RESTORE
  153a68:	e037883a 	mov	sp,fp
  153a6c:	df000017 	ldw	fp,0(sp)
  153a70:	dec00104 	addi	sp,sp,4
  153a74:	dfc00017 	ldw	ra,0(sp)
  153a78:	dec00104 	addi	sp,sp,4
	ret
  153a7c:	f800283a 	ret

00153a80 <sample_done>:

.global sample_done
.type sample_done, @function

sample_done:
	SAVE
  153a80:	deffff04 	addi	sp,sp,-4
  153a84:	dfc00015 	stw	ra,0(sp)
  153a88:	deffff04 	addi	sp,sp,-4
  153a8c:	df000015 	stw	fp,0(sp)
  153a90:	d839883a 	mov	fp,sp
  153a94:	02000574 	movhi	r8,21

	# Test if sample occurred.
	movia	r8, sample_complete
  153a98:	42197004 	addi	r8,r8,26048
	ldb		r9, (r8)
  153a9c:	42400007 	ldb	r9,0(r8)
	beq		r9, r0, sample_null
  153aa0:	48000426 	beq	r9,zero,153ab4 <sample_null>

	# If so, reset sample complete variable and return map to buffers.
	stb		r0, (r8)
  153aa4:	40000005 	stb	zero,0(r8)
  153aa8:	00800574 	movhi	r2,21
	movia	r2, sample_map
  153aac:	108eb404 	addi	r2,r2,15056
	br		sample_done_done
  153ab0:	00000106 	br	153ab8 <sample_done_done>

00153ab4 <sample_null>:

sample_null:
	# Otherwise, return null.
	mov		r2, r0
  153ab4:	0005883a 	mov	r2,zero

00153ab8 <sample_done_done>:

sample_done_done:
	RESTORE
  153ab8:	e037883a 	mov	sp,fp
  153abc:	df000017 	ldw	fp,0(sp)
  153ac0:	dec00104 	addi	sp,sp,4
  153ac4:	dfc00017 	ldw	ra,0(sp)
  153ac8:	dec00104 	addi	sp,sp,4
	ret
  153acc:	f800283a 	ret

00153ad0 <sample_map>:
  153ad0:	001565c8 	cmpgei	zero,zero,21911
  153ad4:	001567a8 	cmpgeui	zero,zero,21918
  153ad8:	00156988 	cmpgei	zero,zero,21926

00153adc <test_disp>:

.global test_disp
.type test_disp,@function

test_disp:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  153adc:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  153ae0:	42000234 	orhi	r8,r8,8
	mov		r11, r0
  153ae4:	0017883a 	mov	r11,zero
	mov		r12, r0
  153ae8:	0019883a 	mov	r12,zero

00153aec <disp>:

disp:
	movi	r13, 136
  153aec:	03402204 	movi	r13,136
	bltu	r12, r13, draw_top
  153af0:	63400836 	bltu	r12,r13,153b14 <draw_top>
	br 		draw_bot
  153af4:	00000a06 	br	153b20 <draw_bot>

00153af8 <disp_cont>:
disp_cont:
	addi	r8, r8, 2
  153af8:	42000084 	addi	r8,r8,2
	addi	r11, r11, 1
  153afc:	5ac00044 	addi	r11,r11,1
	movi	r13, 272
  153b00:	03404404 	movi	r13,272
	bgeu	r12, r13, draw_border
  153b04:	6340152e 	bgeu	r12,r13,153b5c <draw_border>
	movi	r13, 0x0200
  153b08:	03408004 	movi	r13,512
	bgeu	r11, r13, disp_reset
  153b0c:	5b403d2e 	bgeu	r11,r13,153c04 <disp_reset>
	br		disp
  153b10:	003ff606 	br	153aec <disp>

00153b14 <draw_top>:

draw_top:
	movi	r13, 240
  153b14:	03403c04 	movi	r13,240
	bltu	r11, r13, draw_red
  153b18:	5b400436 	bltu	r11,r13,153b2c <draw_red>
	br		draw_yellow
  153b1c:	00000606 	br	153b38 <draw_yellow>

00153b20 <draw_bot>:

draw_bot:
	movi	r13, 240
  153b20:	03403c04 	movi	r13,240
	bltu	r11, r13, draw_green
  153b24:	5b400736 	bltu	r11,r13,153b44 <draw_green>
	br		draw_blue
  153b28:	00000906 	br	153b50 <draw_blue>

00153b2c <draw_red>:

draw_red:
	movi	r9, 0x1F00
  153b2c:	0247c004 	movi	r9,7936
	sthio	r9, (r8)
  153b30:	4240002d 	sthio	r9,0(r8)
	br 		disp_cont
  153b34:	003ff006 	br	153af8 <disp_cont>

00153b38 <draw_yellow>:

draw_yellow:
	movui	r9, 0xFF03
  153b38:	027fc0d4 	movui	r9,65283
	sthio 	r9, (r8)
  153b3c:	4240002d 	sthio	r9,0(r8)
	br		disp_cont
  153b40:	003fed06 	br	153af8 <disp_cont>

00153b44 <draw_green>:

draw_green:
	movui	r9, 0xE003
  153b44:	027800d4 	movui	r9,57347
	sthio 	r9, (r8)
  153b48:	4240002d 	sthio	r9,0(r8)
	br		disp_cont
  153b4c:	003fea06 	br	153af8 <disp_cont>

00153b50 <draw_blue>:

draw_blue:
	movi	r9, 0x007C
  153b50:	02401f04 	movi	r9,124
	sthio 	r9, (r8)
  153b54:	4240002d 	sthio	r9,0(r8)
	br		disp_cont
  153b58:	003fe706 	br	153af8 <disp_cont>

00153b5c <draw_border>:

draw_border:
	movi	r9, 0x1F7C
  153b5c:	0247df04 	movi	r9,8060
	movi	r12, 272
  153b60:	03004404 	movi	r12,272
	movi	r13, 480
  153b64:	03407804 	movi	r13,480

00153b68 <draw_border_top>:

draw_border_top:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  153b68:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  153b6c:	42000234 	orhi	r8,r8,8
	addi	r8, r8, 0x0400
  153b70:	42010004 	addi	r8,r8,1024
	mov		r11, r0
  153b74:	0017883a 	mov	r11,zero

00153b78 <dbt_loop>:
dbt_loop:
	sthio	r9, (r8)
  153b78:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 2
  153b7c:	42000084 	addi	r8,r8,2
	addi	r11, r11, 1
  153b80:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r13, draw_border_bot
  153b84:	5b40012e 	bgeu	r11,r13,153b8c <draw_border_bot>
	br		dbt_loop
  153b88:	003ffb06 	br	153b78 <dbt_loop>

00153b8c <draw_border_bot>:

draw_border_bot:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  153b8c:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  153b90:	42000234 	orhi	r8,r8,8
	movhi	r14, %hi(277504)
  153b94:	03800134 	movhi	r14,4
	ori		r14, r14, %lo(277504)
  153b98:	738f0014 	ori	r14,r14,15360
	add		r8, r8, r14
  153b9c:	4391883a 	add	r8,r8,r14
	mov		r11, r0
  153ba0:	0017883a 	mov	r11,zero

00153ba4 <dbb_loop>:
dbb_loop:
	sthio	r9, (r8)
  153ba4:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 2
  153ba8:	42000084 	addi	r8,r8,2
	addi	r11, r11, 1
  153bac:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r13, draw_border_left
  153bb0:	5b40012e 	bgeu	r11,r13,153bb8 <draw_border_left>
	br		dbb_loop
  153bb4:	003ffb06 	br	153ba4 <dbb_loop>

00153bb8 <draw_border_left>:

draw_border_left:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  153bb8:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  153bbc:	42000234 	orhi	r8,r8,8
	mov		r11, r0
  153bc0:	0017883a 	mov	r11,zero

00153bc4 <dbl_loop>:
dbl_loop:
	sthio	r9, (r8)
  153bc4:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 0x0400
  153bc8:	42010004 	addi	r8,r8,1024
	addi	r11, r11, 1
  153bcc:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r12, draw_border_right
  153bd0:	5b00012e 	bgeu	r11,r12,153bd8 <draw_border_right>
	br		dbl_loop
  153bd4:	003ffb06 	br	153bc4 <dbl_loop>

00153bd8 <draw_border_right>:

draw_border_right:
	movhi	r8, %hi(VRAM_CTRL_BASE)
  153bd8:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  153bdc:	42000234 	orhi	r8,r8,8
	add		r8, r8, r13
  153be0:	4351883a 	add	r8,r8,r13
	add		r8, r8, r13
  153be4:	4351883a 	add	r8,r8,r13
	subi	r8, r8, 1
  153be8:	423fffc4 	addi	r8,r8,-1
	mov		r11, r0
  153bec:	0017883a 	mov	r11,zero

00153bf0 <dbr_loop>:
dbr_loop:
	sthio	r9, (r8)
  153bf0:	4240002d 	sthio	r9,0(r8)
	addi	r8, r8, 0x0400
  153bf4:	42010004 	addi	r8,r8,1024
	addi	r11, r11, 1
  153bf8:	5ac00044 	addi	r11,r11,1
	bgeu	r11, r12, test_disp_done
  153bfc:	5b00042e 	bgeu	r11,r12,153c10 <test_disp_done>
	br		dbr_loop
  153c00:	003ffb06 	br	153bf0 <dbr_loop>

00153c04 <disp_reset>:

disp_reset:
	mov		r11, r0
  153c04:	0017883a 	mov	r11,zero
	addi	r12, r12, 1
  153c08:	63000044 	addi	r12,r12,1
	br		disp
  153c0c:	003fb706 	br	153aec <disp>

00153c10 <test_disp_done>:

test_disp_done:
	ret
  153c10:	f800283a 	ret

00153c14 <test_vram>:

.global test_vram
.type test_vram,@function

test_vram:
	SAVE
  153c14:	deffff04 	addi	sp,sp,-4
  153c18:	dfc00015 	stw	ra,0(sp)
  153c1c:	deffff04 	addi	sp,sp,-4
  153c20:	df000015 	stw	fp,0(sp)
  153c24:	d839883a 	mov	fp,sp

	movhi	r8, %hi(VRAM_CTRL_BASE)
  153c28:	02000234 	movhi	r8,8
	ori		r8, r8, %lo(VRAM_CTRL_BASE)
  153c2c:	42000234 	orhi	r8,r8,8
	movhi	r9, %hi(VRAM_CTRL_SPAN)
  153c30:	02400234 	movhi	r9,8
	ori		r9, r9, %lo(VRAM_CTRL_SPAN)
  153c34:	4a400234 	orhi	r9,r9,8
	add		r9, r8, r9
  153c38:	4253883a 	add	r9,r8,r9
	movui	r12, 0x7000
  153c3c:	031c0014 	movui	r12,28672

	#call	write_read_all

	call	write_all
  153c40:	0153c700 	call	153c70 <write_all>
	call	read_all
  153c44:	0153c9c0 	call	153c9c <read_all>

	nop
  153c48:	0001883a 	nop
	call	read_all
  153c4c:	0153c9c0 	call	153c9c <read_all>

00153c50 <test_vram_fail>:

test_vram_fail:
	nop
  153c50:	0001883a 	nop
	br 		test_vram_fail
  153c54:	003ffe06 	br	153c50 <test_vram_fail>

00153c58 <test_vram_done>:

test_vram_done:
	RESTORE
  153c58:	e037883a 	mov	sp,fp
  153c5c:	df000017 	ldw	fp,0(sp)
  153c60:	dec00104 	addi	sp,sp,4
  153c64:	dfc00017 	ldw	ra,0(sp)
  153c68:	dec00104 	addi	sp,sp,4
	ret
  153c6c:	f800283a 	ret

00153c70 <write_all>:


.type write_all, @function

write_all:
	mov		r10, r8
  153c70:	4015883a 	mov	r10,r8
	mov		r11, r0
  153c74:	0017883a 	mov	r11,zero

00153c78 <write_all_loop>:

write_all_loop:
	sthio	r11, (r10)
  153c78:	52c0002d 	sthio	r11,0(r10)
	addi	r10, r10, 2
  153c7c:	52800084 	addi	r10,r10,2
	addi	r11, r11, 1
  153c80:	5ac00044 	addi	r11,r11,1
	bgeu	r10, r9, write_all_done
  153c84:	5240042e 	bgeu	r10,r9,153c98 <write_all_done>
	bgeu	r11, r12, write_all_reset_cnt
  153c88:	5b00012e 	bgeu	r11,r12,153c90 <write_all_reset_cnt>
	br		write_all_loop
  153c8c:	003ffa06 	br	153c78 <write_all_loop>

00153c90 <write_all_reset_cnt>:

write_all_reset_cnt:
	mov		r11, r0
  153c90:	0017883a 	mov	r11,zero
	br		write_all_loop
  153c94:	003ff806 	br	153c78 <write_all_loop>

00153c98 <write_all_done>:

write_all_done:
	ret
  153c98:	f800283a 	ret

00153c9c <read_all>:


.type read_all, @function

read_all:
	mov		r10, r8
  153c9c:	4015883a 	mov	r10,r8
	mov		r11, r0
  153ca0:	0017883a 	mov	r11,zero

00153ca4 <read_all_loop>:

read_all_loop:
	ldhio	r13, (r10)
  153ca4:	5340002f 	ldhio	r13,0(r10)
	bne		r13, r11, test_vram_fail
  153ca8:	6affe91e 	bne	r13,r11,153c50 <test_vram_fail>
	addi	r10, r10, 2
  153cac:	52800084 	addi	r10,r10,2
	addi	r11, r11, 1
  153cb0:	5ac00044 	addi	r11,r11,1
	bgeu	r10, r9, read_all_done
  153cb4:	5240042e 	bgeu	r10,r9,153cc8 <read_all_done>
	bgeu	r11, r12, read_all_reset_cnt
  153cb8:	5b00012e 	bgeu	r11,r12,153cc0 <read_all_reset_cnt>
	br		read_all_loop
  153cbc:	003ff906 	br	153ca4 <read_all_loop>

00153cc0 <read_all_reset_cnt>:

read_all_reset_cnt:
	mov		r11, r0
  153cc0:	0017883a 	mov	r11,zero
	br		write_all_loop
  153cc4:	003fec06 	br	153c78 <write_all_loop>

00153cc8 <read_all_done>:

read_all_done:
	ret
  153cc8:	f800283a 	ret

00153ccc <memcpy>:
  153ccc:	00c003c4 	movi	r3,15
  153cd0:	2005883a 	mov	r2,r4
  153cd4:	3009883a 	mov	r4,r6
  153cd8:	1980032e 	bgeu	r3,r6,153ce8 <memcpy+0x1c>
  153cdc:	2886b03a 	or	r3,r5,r2
  153ce0:	18c000cc 	andi	r3,r3,3
  153ce4:	18000926 	beq	r3,zero,153d0c <memcpy+0x40>
  153ce8:	1007883a 	mov	r3,r2
  153cec:	290f883a 	add	r7,r5,r4
  153cf0:	20000526 	beq	r4,zero,153d08 <memcpy+0x3c>
  153cf4:	29800003 	ldbu	r6,0(r5)
  153cf8:	18c00044 	addi	r3,r3,1
  153cfc:	29400044 	addi	r5,r5,1
  153d00:	19bfffc5 	stb	r6,-1(r3)
  153d04:	29fffb1e 	bne	r5,r7,153cf4 <memcpy+0x28>
  153d08:	f800283a 	ret
  153d0c:	327ffc04 	addi	r9,r6,-16
  153d10:	4812d13a 	srli	r9,r9,4
  153d14:	11000404 	addi	r4,r2,16
  153d18:	1007883a 	mov	r3,r2
  153d1c:	4810913a 	slli	r8,r9,4
  153d20:	280f883a 	mov	r7,r5
  153d24:	2209883a 	add	r4,r4,r8
  153d28:	3a000017 	ldw	r8,0(r7)
  153d2c:	18c00404 	addi	r3,r3,16
  153d30:	39c00404 	addi	r7,r7,16
  153d34:	1a3ffc15 	stw	r8,-16(r3)
  153d38:	3a3ffd17 	ldw	r8,-12(r7)
  153d3c:	1a3ffd15 	stw	r8,-12(r3)
  153d40:	3a3ffe17 	ldw	r8,-8(r7)
  153d44:	1a3ffe15 	stw	r8,-8(r3)
  153d48:	3a3fff17 	ldw	r8,-4(r7)
  153d4c:	1a3fff15 	stw	r8,-4(r3)
  153d50:	193ff51e 	bne	r3,r4,153d28 <memcpy+0x5c>
  153d54:	49c00044 	addi	r7,r9,1
  153d58:	380e913a 	slli	r7,r7,4
  153d5c:	310003cc 	andi	r4,r6,15
  153d60:	018000c4 	movi	r6,3
  153d64:	11c7883a 	add	r3,r2,r7
  153d68:	29cb883a 	add	r5,r5,r7
  153d6c:	313fdf2e 	bgeu	r6,r4,153cec <memcpy+0x20>
  153d70:	213fff04 	addi	r4,r4,-4
  153d74:	2014d0ba 	srli	r10,r4,2
  153d78:	1a400104 	addi	r9,r3,4
  153d7c:	180d883a 	mov	r6,r3
  153d80:	528f883a 	add	r7,r10,r10
  153d84:	39cf883a 	add	r7,r7,r7
  153d88:	49d3883a 	add	r9,r9,r7
  153d8c:	280f883a 	mov	r7,r5
  153d90:	3a000017 	ldw	r8,0(r7)
  153d94:	31800104 	addi	r6,r6,4
  153d98:	39c00104 	addi	r7,r7,4
  153d9c:	323fff15 	stw	r8,-4(r6)
  153da0:	327ffb1e 	bne	r6,r9,153d90 <memcpy+0xc4>
  153da4:	51800044 	addi	r6,r10,1
  153da8:	52bfff24 	muli	r10,r10,-4
  153dac:	318d883a 	add	r6,r6,r6
  153db0:	318d883a 	add	r6,r6,r6
  153db4:	5109883a 	add	r4,r10,r4
  153db8:	298b883a 	add	r5,r5,r6
  153dbc:	1987883a 	add	r3,r3,r6
  153dc0:	003fca06 	br	153cec <memcpy+0x20>

00153dc4 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  153dc4:	defff904 	addi	sp,sp,-28
  153dc8:	dfc00615 	stw	ra,24(sp)
  153dcc:	df000515 	stw	fp,20(sp)
  153dd0:	df000504 	addi	fp,sp,20
  153dd4:	e13ffc15 	stw	r4,-16(fp)
  153dd8:	e17ffd15 	stw	r5,-12(fp)
  153ddc:	e1bffe15 	stw	r6,-8(fp)
  153de0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  153de4:	e0800217 	ldw	r2,8(fp)
  153de8:	d8800015 	stw	r2,0(sp)
  153dec:	e13ffc17 	ldw	r4,-16(fp)
  153df0:	e17ffd17 	ldw	r5,-12(fp)
  153df4:	e1bffe17 	ldw	r6,-8(fp)
  153df8:	e1ffff17 	ldw	r7,-4(fp)
  153dfc:	0153f9c0 	call	153f9c <alt_iic_isr_register>
}  
  153e00:	e037883a 	mov	sp,fp
  153e04:	dfc00117 	ldw	ra,4(sp)
  153e08:	df000017 	ldw	fp,0(sp)
  153e0c:	dec00204 	addi	sp,sp,8
  153e10:	f800283a 	ret

00153e14 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  153e14:	defff904 	addi	sp,sp,-28
  153e18:	df000615 	stw	fp,24(sp)
  153e1c:	df000604 	addi	fp,sp,24
  153e20:	e13ffe15 	stw	r4,-8(fp)
  153e24:	e17fff15 	stw	r5,-4(fp)
  153e28:	e0bfff17 	ldw	r2,-4(fp)
  153e2c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  153e30:	0005303a 	rdctl	r2,status
  153e34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  153e38:	e0fffb17 	ldw	r3,-20(fp)
  153e3c:	00bfff84 	movi	r2,-2
  153e40:	1884703a 	and	r2,r3,r2
  153e44:	1001703a 	wrctl	status,r2
  
  return context;
  153e48:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  153e4c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  153e50:	e0bffa17 	ldw	r2,-24(fp)
  153e54:	00c00044 	movi	r3,1
  153e58:	1884983a 	sll	r2,r3,r2
  153e5c:	1007883a 	mov	r3,r2
  153e60:	00800574 	movhi	r2,21
  153e64:	109faa04 	addi	r2,r2,32424
  153e68:	10800017 	ldw	r2,0(r2)
  153e6c:	1886b03a 	or	r3,r3,r2
  153e70:	00800574 	movhi	r2,21
  153e74:	109faa04 	addi	r2,r2,32424
  153e78:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  153e7c:	00800574 	movhi	r2,21
  153e80:	109faa04 	addi	r2,r2,32424
  153e84:	10800017 	ldw	r2,0(r2)
  153e88:	100170fa 	wrctl	ienable,r2
  153e8c:	e0bffc17 	ldw	r2,-16(fp)
  153e90:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  153e94:	e0bffd17 	ldw	r2,-12(fp)
  153e98:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  153e9c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  153ea0:	e037883a 	mov	sp,fp
  153ea4:	df000017 	ldw	fp,0(sp)
  153ea8:	dec00104 	addi	sp,sp,4
  153eac:	f800283a 	ret

00153eb0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  153eb0:	defff904 	addi	sp,sp,-28
  153eb4:	df000615 	stw	fp,24(sp)
  153eb8:	df000604 	addi	fp,sp,24
  153ebc:	e13ffe15 	stw	r4,-8(fp)
  153ec0:	e17fff15 	stw	r5,-4(fp)
  153ec4:	e0bfff17 	ldw	r2,-4(fp)
  153ec8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  153ecc:	0005303a 	rdctl	r2,status
  153ed0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  153ed4:	e0fffb17 	ldw	r3,-20(fp)
  153ed8:	00bfff84 	movi	r2,-2
  153edc:	1884703a 	and	r2,r3,r2
  153ee0:	1001703a 	wrctl	status,r2
  
  return context;
  153ee4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  153ee8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  153eec:	e0bffa17 	ldw	r2,-24(fp)
  153ef0:	00c00044 	movi	r3,1
  153ef4:	1884983a 	sll	r2,r3,r2
  153ef8:	0084303a 	nor	r2,zero,r2
  153efc:	1007883a 	mov	r3,r2
  153f00:	00800574 	movhi	r2,21
  153f04:	109faa04 	addi	r2,r2,32424
  153f08:	10800017 	ldw	r2,0(r2)
  153f0c:	1886703a 	and	r3,r3,r2
  153f10:	00800574 	movhi	r2,21
  153f14:	109faa04 	addi	r2,r2,32424
  153f18:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  153f1c:	00800574 	movhi	r2,21
  153f20:	109faa04 	addi	r2,r2,32424
  153f24:	10800017 	ldw	r2,0(r2)
  153f28:	100170fa 	wrctl	ienable,r2
  153f2c:	e0bffc17 	ldw	r2,-16(fp)
  153f30:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  153f34:	e0bffd17 	ldw	r2,-12(fp)
  153f38:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  153f3c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  153f40:	e037883a 	mov	sp,fp
  153f44:	df000017 	ldw	fp,0(sp)
  153f48:	dec00104 	addi	sp,sp,4
  153f4c:	f800283a 	ret

00153f50 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  153f50:	defffc04 	addi	sp,sp,-16
  153f54:	df000315 	stw	fp,12(sp)
  153f58:	df000304 	addi	fp,sp,12
  153f5c:	e13ffe15 	stw	r4,-8(fp)
  153f60:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  153f64:	000530fa 	rdctl	r2,ienable
  153f68:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  153f6c:	e0bfff17 	ldw	r2,-4(fp)
  153f70:	00c00044 	movi	r3,1
  153f74:	1884983a 	sll	r2,r3,r2
  153f78:	1007883a 	mov	r3,r2
  153f7c:	e0bffd17 	ldw	r2,-12(fp)
  153f80:	1884703a 	and	r2,r3,r2
  153f84:	1004c03a 	cmpne	r2,r2,zero
  153f88:	10803fcc 	andi	r2,r2,255
}
  153f8c:	e037883a 	mov	sp,fp
  153f90:	df000017 	ldw	fp,0(sp)
  153f94:	dec00104 	addi	sp,sp,4
  153f98:	f800283a 	ret

00153f9c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  153f9c:	defff504 	addi	sp,sp,-44
  153fa0:	dfc00a15 	stw	ra,40(sp)
  153fa4:	df000915 	stw	fp,36(sp)
  153fa8:	df000904 	addi	fp,sp,36
  153fac:	e13ffc15 	stw	r4,-16(fp)
  153fb0:	e17ffd15 	stw	r5,-12(fp)
  153fb4:	e1bffe15 	stw	r6,-8(fp)
  153fb8:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  153fbc:	00bffa84 	movi	r2,-22
  153fc0:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  153fc4:	e0bffd17 	ldw	r2,-12(fp)
  153fc8:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  153fcc:	e0bff817 	ldw	r2,-32(fp)
  153fd0:	10800808 	cmpgei	r2,r2,32
  153fd4:	1000271e 	bne	r2,zero,154074 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  153fd8:	0005303a 	rdctl	r2,status
  153fdc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  153fe0:	e0fffa17 	ldw	r3,-24(fp)
  153fe4:	00bfff84 	movi	r2,-2
  153fe8:	1884703a 	and	r2,r3,r2
  153fec:	1001703a 	wrctl	status,r2
  
  return context;
  153ff0:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  153ff4:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  153ff8:	00c005b4 	movhi	r3,22
  153ffc:	18ec7c04 	addi	r3,r3,-19984
  154000:	e0bff817 	ldw	r2,-32(fp)
  154004:	100490fa 	slli	r2,r2,3
  154008:	1885883a 	add	r2,r3,r2
  15400c:	e0fffe17 	ldw	r3,-8(fp)
  154010:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  154014:	00c005b4 	movhi	r3,22
  154018:	18ec7c04 	addi	r3,r3,-19984
  15401c:	e0bff817 	ldw	r2,-32(fp)
  154020:	100490fa 	slli	r2,r2,3
  154024:	1885883a 	add	r2,r3,r2
  154028:	10800104 	addi	r2,r2,4
  15402c:	e0ffff17 	ldw	r3,-4(fp)
  154030:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  154034:	e0bffe17 	ldw	r2,-8(fp)
  154038:	10000526 	beq	r2,zero,154050 <alt_iic_isr_register+0xb4>
  15403c:	e0bff817 	ldw	r2,-32(fp)
  154040:	e13ffc17 	ldw	r4,-16(fp)
  154044:	100b883a 	mov	r5,r2
  154048:	0153e140 	call	153e14 <alt_ic_irq_enable>
  15404c:	00000406 	br	154060 <alt_iic_isr_register+0xc4>
  154050:	e0bff817 	ldw	r2,-32(fp)
  154054:	e13ffc17 	ldw	r4,-16(fp)
  154058:	100b883a 	mov	r5,r2
  15405c:	0153eb00 	call	153eb0 <alt_ic_irq_disable>
  154060:	e0bff715 	stw	r2,-36(fp)
  154064:	e0bff917 	ldw	r2,-28(fp)
  154068:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  15406c:	e0bffb17 	ldw	r2,-20(fp)
  154070:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  154074:	e0bff717 	ldw	r2,-36(fp)
}
  154078:	e037883a 	mov	sp,fp
  15407c:	dfc00117 	ldw	ra,4(sp)
  154080:	df000017 	ldw	fp,0(sp)
  154084:	dec00204 	addi	sp,sp,8
  154088:	f800283a 	ret

0015408c <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  15408c:	defffc04 	addi	sp,sp,-16
  154090:	df000315 	stw	fp,12(sp)
  154094:	df000304 	addi	fp,sp,12
  154098:	e13ffd15 	stw	r4,-12(fp)
  15409c:	e17ffe15 	stw	r5,-8(fp)
  1540a0:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  1540a4:	e0fffe17 	ldw	r3,-8(fp)
  1540a8:	e0bffd17 	ldw	r2,-12(fp)
  1540ac:	18800e26 	beq	r3,r2,1540e8 <alt_load_section+0x5c>
  {
    while( to != end )
  1540b0:	00000a06 	br	1540dc <alt_load_section+0x50>
    {
      *to++ = *from++;
  1540b4:	e0bffd17 	ldw	r2,-12(fp)
  1540b8:	10c00017 	ldw	r3,0(r2)
  1540bc:	e0bffe17 	ldw	r2,-8(fp)
  1540c0:	10c00015 	stw	r3,0(r2)
  1540c4:	e0bffe17 	ldw	r2,-8(fp)
  1540c8:	10800104 	addi	r2,r2,4
  1540cc:	e0bffe15 	stw	r2,-8(fp)
  1540d0:	e0bffd17 	ldw	r2,-12(fp)
  1540d4:	10800104 	addi	r2,r2,4
  1540d8:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  1540dc:	e0fffe17 	ldw	r3,-8(fp)
  1540e0:	e0bfff17 	ldw	r2,-4(fp)
  1540e4:	18bff31e 	bne	r3,r2,1540b4 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  1540e8:	e037883a 	mov	sp,fp
  1540ec:	df000017 	ldw	fp,0(sp)
  1540f0:	dec00104 	addi	sp,sp,4
  1540f4:	f800283a 	ret

001540f8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  1540f8:	defffe04 	addi	sp,sp,-8
  1540fc:	dfc00115 	stw	ra,4(sp)
  154100:	df000015 	stw	fp,0(sp)
  154104:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  154108:	01000574 	movhi	r4,21
  15410c:	211c8104 	addi	r4,r4,29188
  154110:	01400574 	movhi	r5,21
  154114:	29596804 	addi	r5,r5,26016
  154118:	01800574 	movhi	r6,21
  15411c:	319c8104 	addi	r6,r6,29188
  154120:	015408c0 	call	15408c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  154124:	01000574 	movhi	r4,21
  154128:	21000804 	addi	r4,r4,32
  15412c:	01400574 	movhi	r5,21
  154130:	29400804 	addi	r5,r5,32
  154134:	01800574 	movhi	r6,21
  154138:	31806e04 	addi	r6,r6,440
  15413c:	015408c0 	call	15408c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  154140:	01000574 	movhi	r4,21
  154144:	21177904 	addi	r4,r4,24036
  154148:	01400574 	movhi	r5,21
  15414c:	29577904 	addi	r5,r5,24036
  154150:	01800574 	movhi	r6,21
  154154:	31996804 	addi	r6,r6,26016
  154158:	015408c0 	call	15408c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  15415c:	01553080 	call	155308 <alt_dcache_flush_all>
  alt_icache_flush_all();
  154160:	01555b00 	call	1555b0 <alt_icache_flush_all>
}
  154164:	e037883a 	mov	sp,fp
  154168:	dfc00117 	ldw	ra,4(sp)
  15416c:	df000017 	ldw	fp,0(sp)
  154170:	dec00204 	addi	sp,sp,8
  154174:	f800283a 	ret

00154178 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  154178:	defffd04 	addi	sp,sp,-12
  15417c:	dfc00215 	stw	ra,8(sp)
  154180:	df000115 	stw	fp,4(sp)
  154184:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  154188:	0009883a 	mov	r4,zero
  15418c:	01541d40 	call	1541d4 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  154190:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  154194:	01542080 	call	154208 <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  154198:	01554400 	call	155440 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  15419c:	01000574 	movhi	r4,21
  1541a0:	21152704 	addi	r4,r4,21660
  1541a4:	01559840 	call	155984 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  1541a8:	d1233517 	ldw	r4,-29484(gp)
  1541ac:	d0e33617 	ldw	r3,-29480(gp)
  1541b0:	d0a33717 	ldw	r2,-29476(gp)
  1541b4:	180b883a 	mov	r5,r3
  1541b8:	100d883a 	mov	r6,r2
  1541bc:	01507280 	call	150728 <main>
  1541c0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  1541c4:	01000044 	movi	r4,1
  1541c8:	01552400 	call	155240 <close>
  exit (result);
  1541cc:	e13fff17 	ldw	r4,-4(fp)
  1541d0:	01559980 	call	155998 <exit>

001541d4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  1541d4:	defffd04 	addi	sp,sp,-12
  1541d8:	dfc00215 	stw	ra,8(sp)
  1541dc:	df000115 	stw	fp,4(sp)
  1541e0:	df000104 	addi	fp,sp,4
  1541e4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( PROC, PROC);
  1541e8:	01556400 	call	155640 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  1541ec:	00800044 	movi	r2,1
  1541f0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  1541f4:	e037883a 	mov	sp,fp
  1541f8:	dfc00117 	ldw	ra,4(sp)
  1541fc:	df000017 	ldw	fp,0(sp)
  154200:	dec00204 	addi	sp,sp,8
  154204:	f800283a 	ret

00154208 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  154208:	defffe04 	addi	sp,sp,-8
  15420c:	dfc00115 	stw	ra,4(sp)
  154210:	df000015 	stw	fp,0(sp)
  154214:	d839883a 	mov	fp,sp
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_CTRL, EPCS_ctrl);
  154218:	01000574 	movhi	r4,21
  15421c:	211ada04 	addi	r4,r4,27496
  154220:	01542740 	call	154274 <alt_epcs_flash_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
  154224:	0001883a 	nop
}
  154228:	e037883a 	mov	sp,fp
  15422c:	dfc00117 	ldw	ra,4(sp)
  154230:	df000017 	ldw	fp,0(sp)
  154234:	dec00204 	addi	sp,sp,8
  154238:	f800283a 	ret

0015423c <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  15423c:	defffd04 	addi	sp,sp,-12
  154240:	dfc00215 	stw	ra,8(sp)
  154244:	df000115 	stw	fp,4(sp)
  154248:	df000104 	addi	fp,sp,4
  15424c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
  154250:	e13fff17 	ldw	r4,-4(fp)
  154254:	01400574 	movhi	r5,21
  154258:	295c7d04 	addi	r5,r5,29172
  15425c:	01553a00 	call	1553a0 <alt_dev_llist_insert>
}
  154260:	e037883a 	mov	sp,fp
  154264:	dfc00117 	ldw	ra,4(sp)
  154268:	df000017 	ldw	fp,0(sp)
  15426c:	dec00204 	addi	sp,sp,8
  154270:	f800283a 	ret

00154274 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
  154274:	defffc04 	addi	sp,sp,-16
  154278:	dfc00315 	stw	ra,12(sp)
  15427c:	df000215 	stw	fp,8(sp)
  154280:	df000204 	addi	fp,sp,8
  154284:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
  154288:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
  15428c:	e13fff17 	ldw	r4,-4(fp)
  154290:	01542c80 	call	1542c8 <alt_epcs_flash_query>
  154294:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
  154298:	e0bffe17 	ldw	r2,-8(fp)
  15429c:	1000041e 	bne	r2,zero,1542b0 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
  1542a0:	e0bfff17 	ldw	r2,-4(fp)
  1542a4:	1009883a 	mov	r4,r2
  1542a8:	015423c0 	call	15423c <alt_flash_device_register>
  1542ac:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
  1542b0:	e0bffe17 	ldw	r2,-8(fp)
}
  1542b4:	e037883a 	mov	sp,fp
  1542b8:	dfc00117 	ldw	ra,4(sp)
  1542bc:	df000017 	ldw	fp,0(sp)
  1542c0:	dec00204 	addi	sp,sp,8
  1542c4:	f800283a 	ret

001542c8 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
  1542c8:	defffc04 	addi	sp,sp,-16
  1542cc:	dfc00315 	stw	ra,12(sp)
  1542d0:	df000215 	stw	fp,8(sp)
  1542d4:	df000204 	addi	fp,sp,8
  1542d8:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
  1542dc:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  1542e0:	e0bfff17 	ldw	r2,-4(fp)
  1542e4:	10003115 	stw	zero,196(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
  1542e8:	e0bfff17 	ldw	r2,-4(fp)
  1542ec:	10802d17 	ldw	r2,180(r2)
  1542f0:	1009883a 	mov	r4,r2
  1542f4:	01550580 	call	155058 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
  1542f8:	10c03fcc 	andi	r3,r2,255
  1542fc:	e0bfff17 	ldw	r2,-4(fp)
  154300:	10c02f15 	stw	r3,188(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
  154304:	e0bfff17 	ldw	r2,-4(fp)
  154308:	10802f17 	ldw	r2,188(r2)
  15430c:	10800598 	cmpnei	r2,r2,22
  154310:	10000a1e 	bne	r2,zero,15433c <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
  154314:	e0bfff17 	ldw	r2,-4(fp)
  154318:	00c02034 	movhi	r3,128
  15431c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
  154320:	e0bfff17 	ldw	r2,-4(fp)
  154324:	00c02004 	movi	r3,128
  154328:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  15432c:	e0bfff17 	ldw	r2,-4(fp)
  154330:	00c00074 	movhi	r3,1
  154334:	10c01015 	stw	r3,64(r2)
  154338:	00007306 	br	154508 <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
  15433c:	e0bfff17 	ldw	r2,-4(fp)
  154340:	10802f17 	ldw	r2,188(r2)
  154344:	10800518 	cmpnei	r2,r2,20
  154348:	10000a1e 	bne	r2,zero,154374 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
  15434c:	e0bfff17 	ldw	r2,-4(fp)
  154350:	00c00834 	movhi	r3,32
  154354:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
  154358:	e0bfff17 	ldw	r2,-4(fp)
  15435c:	00c00804 	movi	r3,32
  154360:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  154364:	e0bfff17 	ldw	r2,-4(fp)
  154368:	00c00074 	movhi	r3,1
  15436c:	10c01015 	stw	r3,64(r2)
  154370:	00006506 	br	154508 <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
  154374:	e0bfff17 	ldw	r2,-4(fp)
  154378:	10802f17 	ldw	r2,188(r2)
  15437c:	108004d8 	cmpnei	r2,r2,19
  154380:	10000a1e 	bne	r2,zero,1543ac <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
  154384:	e0bfff17 	ldw	r2,-4(fp)
  154388:	00c00434 	movhi	r3,16
  15438c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
  154390:	e0bfff17 	ldw	r2,-4(fp)
  154394:	00c00404 	movi	r3,16
  154398:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  15439c:	e0bfff17 	ldw	r2,-4(fp)
  1543a0:	00c00074 	movhi	r3,1
  1543a4:	10c01015 	stw	r3,64(r2)
  1543a8:	00005706 	br	154508 <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
  1543ac:	e0bfff17 	ldw	r2,-4(fp)
  1543b0:	10802f17 	ldw	r2,188(r2)
  1543b4:	10800498 	cmpnei	r2,r2,18
  1543b8:	10000a1e 	bne	r2,zero,1543e4 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
  1543bc:	e0bfff17 	ldw	r2,-4(fp)
  1543c0:	00c00234 	movhi	r3,8
  1543c4:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
  1543c8:	e0bfff17 	ldw	r2,-4(fp)
  1543cc:	00c00204 	movi	r3,8
  1543d0:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  1543d4:	e0bfff17 	ldw	r2,-4(fp)
  1543d8:	00c00074 	movhi	r3,1
  1543dc:	10c01015 	stw	r3,64(r2)
  1543e0:	00004906 	br	154508 <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
  1543e4:	e0bfff17 	ldw	r2,-4(fp)
  1543e8:	10802f17 	ldw	r2,188(r2)
  1543ec:	10800418 	cmpnei	r2,r2,16
  1543f0:	10000a1e 	bne	r2,zero,15441c <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
  1543f4:	e0bfff17 	ldw	r2,-4(fp)
  1543f8:	00c000b4 	movhi	r3,2
  1543fc:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
  154400:	e0bfff17 	ldw	r2,-4(fp)
  154404:	00c00104 	movi	r3,4
  154408:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
  15440c:	e0bfff17 	ldw	r2,-4(fp)
  154410:	00e00014 	movui	r3,32768
  154414:	10c01015 	stw	r3,64(r2)
  154418:	00003b06 	br	154508 <alt_epcs_flash_query+0x240>
  {
    /* 
     * Read electronic signature doesn't work for the EPCS128; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
  15441c:	e0bfff17 	ldw	r2,-4(fp)
  154420:	10802d17 	ldw	r2,180(r2)
  154424:	1009883a 	mov	r4,r2
  154428:	01550c00 	call	1550c0 <epcs_read_device_id>
  15442c:	e0ffff17 	ldw	r3,-4(fp)
  154430:	18802f15 	stw	r2,188(r3)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
  154434:	e0bfff17 	ldw	r2,-4(fp)
  154438:	10c02f17 	ldw	r3,188(r2)
  15443c:	00804034 	movhi	r2,256
  154440:	10bfffc4 	addi	r2,r2,-1
  154444:	1886703a 	and	r3,r3,r2
  154448:	00800874 	movhi	r2,33
  15444c:	10ae8604 	addi	r2,r2,-17896
  154450:	18800a1e 	bne	r3,r2,15447c <alt_epcs_flash_query+0x1b4>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
  154454:	e0bfff17 	ldw	r2,-4(fp)
  154458:	00c04034 	movhi	r3,256
  15445c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
  154460:	e0bfff17 	ldw	r2,-4(fp)
  154464:	00c04004 	movi	r3,256
  154468:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  15446c:	e0bfff17 	ldw	r2,-4(fp)
  154470:	00c00074 	movhi	r3,1
  154474:	10c01015 	stw	r3,64(r2)
  154478:	00002306 	br	154508 <alt_epcs_flash_query+0x240>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
  15447c:	e0bfff17 	ldw	r2,-4(fp)
  154480:	10802f17 	ldw	r2,188(r2)
  154484:	10803fcc 	andi	r2,r2,255
  154488:	10800618 	cmpnei	r2,r2,24
  15448c:	10000a1e 	bne	r2,zero,1544b8 <alt_epcs_flash_query+0x1f0>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
  154490:	e0bfff17 	ldw	r2,-4(fp)
  154494:	00c04034 	movhi	r3,256
  154498:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
  15449c:	e0bfff17 	ldw	r2,-4(fp)
  1544a0:	00c01004 	movi	r3,64
  1544a4:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
  1544a8:	e0bfff17 	ldw	r2,-4(fp)
  1544ac:	00c00134 	movhi	r3,4
  1544b0:	10c01015 	stw	r3,64(r2)
  1544b4:	00001406 	br	154508 <alt_epcs_flash_query+0x240>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
  1544b8:	e0bfff17 	ldw	r2,-4(fp)
  1544bc:	10802f17 	ldw	r2,188(r2)
  1544c0:	10803fcc 	andi	r2,r2,255
  1544c4:	10800658 	cmpnei	r2,r2,25
  1544c8:	10000d1e 	bne	r2,zero,154500 <alt_epcs_flash_query+0x238>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
  1544cc:	e0bfff17 	ldw	r2,-4(fp)
  1544d0:	00c08034 	movhi	r3,512
  1544d4:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
  1544d8:	e0bfff17 	ldw	r2,-4(fp)
  1544dc:	00c08004 	movi	r3,512
  1544e0:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  1544e4:	e0bfff17 	ldw	r2,-4(fp)
  1544e8:	00c00074 	movhi	r3,1
  1544ec:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
  1544f0:	e0bfff17 	ldw	r2,-4(fp)
  1544f4:	00c00044 	movi	r3,1
  1544f8:	10c03115 	stw	r3,196(r2)
  1544fc:	00000206 	br	154508 <alt_epcs_flash_query+0x240>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
  154500:	00bffb44 	movi	r2,-19
  154504:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
  154508:	e0bfff17 	ldw	r2,-4(fp)
  15450c:	10800e17 	ldw	r2,56(r2)
  154510:	1007883a 	mov	r3,r2
  154514:	e0bfff17 	ldw	r2,-4(fp)
  154518:	10c02e15 	stw	r3,184(r2)
  flash->dev.number_of_regions = 1;
  15451c:	e0bfff17 	ldw	r2,-4(fp)
  154520:	00c00044 	movi	r3,1
  154524:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
  154528:	e0bfff17 	ldw	r2,-4(fp)
  15452c:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
  154530:	e0bfff17 	ldw	r2,-4(fp)
  154534:	00c04004 	movi	r3,256
  154538:	10c03015 	stw	r3,192(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
  15453c:	e0bffe17 	ldw	r2,-8(fp)
}
  154540:	e037883a 	mov	sp,fp
  154544:	dfc00117 	ldw	ra,4(sp)
  154548:	df000017 	ldw	fp,0(sp)
  15454c:	dec00204 	addi	sp,sp,8
  154550:	f800283a 	ret

00154554 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
  154554:	deffee04 	addi	sp,sp,-72
  154558:	dfc01115 	stw	ra,68(sp)
  15455c:	df001015 	stw	fp,64(sp)
  154560:	df001004 	addi	fp,sp,64
  154564:	e13ffc15 	stw	r4,-16(fp)
  154568:	e17ffd15 	stw	r5,-12(fp)
  15456c:	e1bffe15 	stw	r6,-8(fp)
  154570:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  154574:	00800804 	movi	r2,32
  154578:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
  15457c:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
  154580:	00002606 	br	15461c <alt_epcs_flash_memcmp+0xc8>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
  154584:	e0bff117 	ldw	r2,-60(fp)
  154588:	e0ffff17 	ldw	r3,-4(fp)
  15458c:	1880012e 	bgeu	r3,r2,154594 <alt_epcs_flash_memcmp+0x40>
  154590:	1805883a 	mov	r2,r3
  154594:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
  154598:	e0fffe17 	ldw	r3,-8(fp)
  15459c:	e0bff017 	ldw	r2,-64(fp)
  1545a0:	1887883a 	add	r3,r3,r2
  1545a4:	e0bff404 	addi	r2,fp,-48
  1545a8:	e13ffc17 	ldw	r4,-16(fp)
  1545ac:	180b883a 	mov	r5,r3
  1545b0:	100d883a 	mov	r6,r2
  1545b4:	e1fff217 	ldw	r7,-56(fp)
  1545b8:	0154b340 	call	154b34 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
  1545bc:	1000020e 	bge	r2,zero,1545c8 <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
  1545c0:	00bfffc4 	movi	r2,-1
  1545c4:	00001806 	br	154628 <alt_epcs_flash_memcmp+0xd4>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
  1545c8:	e0bff017 	ldw	r2,-64(fp)
  1545cc:	e0fffd17 	ldw	r3,-12(fp)
  1545d0:	1889883a 	add	r4,r3,r2
  1545d4:	e0bff217 	ldw	r2,-56(fp)
  1545d8:	e0fff404 	addi	r3,fp,-48
  1545dc:	180b883a 	mov	r5,r3
  1545e0:	100d883a 	mov	r6,r2
  1545e4:	01559d00 	call	1559d0 <memcmp>
  1545e8:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
  1545ec:	e0bff317 	ldw	r2,-52(fp)
  1545f0:	10000226 	beq	r2,zero,1545fc <alt_epcs_flash_memcmp+0xa8>
    {
      return this_chunk_cmp;
  1545f4:	e0bff317 	ldw	r2,-52(fp)
  1545f8:	00000b06 	br	154628 <alt_epcs_flash_memcmp+0xd4>
    }

    n -= this_chunk_size;
  1545fc:	e0bff217 	ldw	r2,-56(fp)
  154600:	e0ffff17 	ldw	r3,-4(fp)
  154604:	1885c83a 	sub	r2,r3,r2
  154608:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
  15460c:	e0fff017 	ldw	r3,-64(fp)
  154610:	e0bff217 	ldw	r2,-56(fp)
  154614:	1885883a 	add	r2,r3,r2
  154618:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
  15461c:	e0bfff17 	ldw	r2,-4(fp)
  154620:	103fd81e 	bne	r2,zero,154584 <alt_epcs_flash_memcmp+0x30>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
  154624:	0005883a 	mov	r2,zero
}
  154628:	e037883a 	mov	sp,fp
  15462c:	dfc00117 	ldw	ra,4(sp)
  154630:	df000017 	ldw	fp,0(sp)
  154634:	dec00204 	addi	sp,sp,8
  154638:	f800283a 	ret

0015463c <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
  15463c:	defff404 	addi	sp,sp,-48
  154640:	dfc00b15 	stw	ra,44(sp)
  154644:	df000a15 	stw	fp,40(sp)
  154648:	df000a04 	addi	fp,sp,40
  15464c:	e13ffc15 	stw	r4,-16(fp)
  154650:	e17ffd15 	stw	r5,-12(fp)
  154654:	e1bffe15 	stw	r6,-8(fp)
  154658:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
  15465c:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  154660:	e03ff815 	stw	zero,-32(fp)
  154664:	00008306 	br	154874 <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
  154668:	e0fffc17 	ldw	r3,-16(fp)
  15466c:	e0bff817 	ldw	r2,-32(fp)
  154670:	1004913a 	slli	r2,r2,4
  154674:	1885883a 	add	r2,r3,r2
  154678:	10800d04 	addi	r2,r2,52
  15467c:	10800017 	ldw	r2,0(r2)
  154680:	e0fffd17 	ldw	r3,-12(fp)
  154684:	18807816 	blt	r3,r2,154868 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
  154688:	e0fffc17 	ldw	r3,-16(fp)
  15468c:	e0bff817 	ldw	r2,-32(fp)
  154690:	1004913a 	slli	r2,r2,4
  154694:	1885883a 	add	r2,r3,r2
  154698:	10800d04 	addi	r2,r2,52
  15469c:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
  1546a0:	e13ffc17 	ldw	r4,-16(fp)
  1546a4:	e0bff817 	ldw	r2,-32(fp)
  1546a8:	1004913a 	slli	r2,r2,4
  1546ac:	2085883a 	add	r2,r4,r2
  1546b0:	10800e04 	addi	r2,r2,56
  1546b4:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
  1546b8:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
  1546bc:	e0fffd17 	ldw	r3,-12(fp)
  1546c0:	1880690e 	bge	r3,r2,154868 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
  1546c4:	e0fffc17 	ldw	r3,-16(fp)
  1546c8:	e0bff817 	ldw	r2,-32(fp)
  1546cc:	1004913a 	slli	r2,r2,4
  1546d0:	1885883a 	add	r2,r3,r2
  1546d4:	10800d04 	addi	r2,r2,52
  1546d8:	10800017 	ldw	r2,0(r2)
  1546dc:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
  1546e0:	e03ff915 	stw	zero,-28(fp)
  1546e4:	00005806 	br	154848 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
  1546e8:	e0fffd17 	ldw	r3,-12(fp)
  1546ec:	e0bffa17 	ldw	r2,-24(fp)
  1546f0:	18804916 	blt	r3,r2,154818 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
  1546f4:	e0fffc17 	ldw	r3,-16(fp)
  1546f8:	e0bff817 	ldw	r2,-32(fp)
  1546fc:	10800104 	addi	r2,r2,4
  154700:	1004913a 	slli	r2,r2,4
  154704:	1885883a 	add	r2,r3,r2
  154708:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
  15470c:	e0bffa17 	ldw	r2,-24(fp)
  154710:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
  154714:	e0fffd17 	ldw	r3,-12(fp)
  154718:	18803f0e 	bge	r3,r2,154818 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
  15471c:	e0fffc17 	ldw	r3,-16(fp)
  154720:	e0bff817 	ldw	r2,-32(fp)
  154724:	10800104 	addi	r2,r2,4
  154728:	1004913a 	slli	r2,r2,4
  15472c:	1885883a 	add	r2,r3,r2
  154730:	10c00017 	ldw	r3,0(r2)
  154734:	e0bffa17 	ldw	r2,-24(fp)
  154738:	1887883a 	add	r3,r3,r2
  15473c:	e0bffd17 	ldw	r2,-12(fp)
  154740:	1885c83a 	sub	r2,r3,r2
  154744:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
  154748:	e0fffb17 	ldw	r3,-20(fp)
  15474c:	e0bfff17 	ldw	r2,-4(fp)
  154750:	1880010e 	bge	r3,r2,154758 <alt_epcs_flash_write+0x11c>
  154754:	1805883a 	mov	r2,r3
  154758:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
  15475c:	e0bffb17 	ldw	r2,-20(fp)
  154760:	e13ffc17 	ldw	r4,-16(fp)
  154764:	e17ffe17 	ldw	r5,-8(fp)
  154768:	e1bffd17 	ldw	r6,-12(fp)
  15476c:	100f883a 	mov	r7,r2
  154770:	01545540 	call	154554 <alt_epcs_flash_memcmp>
  154774:	10001226 	beq	r2,zero,1547c0 <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
  154778:	e0bffc17 	ldw	r2,-16(fp)
  15477c:	10800817 	ldw	r2,32(r2)
  154780:	e13ffc17 	ldw	r4,-16(fp)
  154784:	e17ffa17 	ldw	r5,-24(fp)
  154788:	103ee83a 	callr	r2
  15478c:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
  154790:	e0bff717 	ldw	r2,-36(fp)
  154794:	10000a1e 	bne	r2,zero,1547c0 <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
  154798:	e0bffc17 	ldw	r2,-16(fp)
  15479c:	10800917 	ldw	r2,36(r2)
  1547a0:	e0fffb17 	ldw	r3,-20(fp)
  1547a4:	d8c00015 	stw	r3,0(sp)
  1547a8:	e13ffc17 	ldw	r4,-16(fp)
  1547ac:	e17ffa17 	ldw	r5,-24(fp)
  1547b0:	e1bffd17 	ldw	r6,-12(fp)
  1547b4:	e1fffe17 	ldw	r7,-8(fp)
  1547b8:	103ee83a 	callr	r2
  1547bc:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
  1547c0:	e0ffff17 	ldw	r3,-4(fp)
  1547c4:	e0bffb17 	ldw	r2,-20(fp)
  1547c8:	18802e26 	beq	r3,r2,154884 <alt_epcs_flash_write+0x248>
  1547cc:	e0bff717 	ldw	r2,-36(fp)
  1547d0:	10002c1e 	bne	r2,zero,154884 <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
  1547d4:	e0ffff17 	ldw	r3,-4(fp)
  1547d8:	e0bffb17 	ldw	r2,-20(fp)
  1547dc:	1885c83a 	sub	r2,r3,r2
  1547e0:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
  1547e4:	e0fffc17 	ldw	r3,-16(fp)
  1547e8:	e0bff817 	ldw	r2,-32(fp)
  1547ec:	10800104 	addi	r2,r2,4
  1547f0:	1004913a 	slli	r2,r2,4
  1547f4:	1885883a 	add	r2,r3,r2
  1547f8:	10c00017 	ldw	r3,0(r2)
  1547fc:	e0bffa17 	ldw	r2,-24(fp)
  154800:	1885883a 	add	r2,r3,r2
  154804:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
  154808:	e0bffb17 	ldw	r2,-20(fp)
  15480c:	e0fffe17 	ldw	r3,-8(fp)
  154810:	1885883a 	add	r2,r3,r2
  154814:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
  154818:	e0fffc17 	ldw	r3,-16(fp)
  15481c:	e0bff817 	ldw	r2,-32(fp)
  154820:	10800104 	addi	r2,r2,4
  154824:	1004913a 	slli	r2,r2,4
  154828:	1885883a 	add	r2,r3,r2
  15482c:	10800017 	ldw	r2,0(r2)
  154830:	e0fffa17 	ldw	r3,-24(fp)
  154834:	1885883a 	add	r2,r3,r2
  154838:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
  15483c:	e0bff917 	ldw	r2,-28(fp)
  154840:	10800044 	addi	r2,r2,1
  154844:	e0bff915 	stw	r2,-28(fp)
  154848:	e0fffc17 	ldw	r3,-16(fp)
  15484c:	e0bff817 	ldw	r2,-32(fp)
  154850:	1004913a 	slli	r2,r2,4
  154854:	1885883a 	add	r2,r3,r2
  154858:	10800f04 	addi	r2,r2,60
  15485c:	10800017 	ldw	r2,0(r2)
  154860:	e0fff917 	ldw	r3,-28(fp)
  154864:	18bfa016 	blt	r3,r2,1546e8 <alt_epcs_flash_write+0xac>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  154868:	e0bff817 	ldw	r2,-32(fp)
  15486c:	10800044 	addi	r2,r2,1
  154870:	e0bff815 	stw	r2,-32(fp)
  154874:	e0bffc17 	ldw	r2,-16(fp)
  154878:	10800c17 	ldw	r2,48(r2)
  15487c:	e0fff817 	ldw	r3,-32(fp)
  154880:	18bf7916 	blt	r3,r2,154668 <alt_epcs_flash_write+0x2c>
      }
    }
  }

finished:
  return ret_code;
  154884:	e0bff717 	ldw	r2,-36(fp)
}
  154888:	e037883a 	mov	sp,fp
  15488c:	dfc00117 	ldw	ra,4(sp)
  154890:	df000017 	ldw	fp,0(sp)
  154894:	dec00204 	addi	sp,sp,8
  154898:	f800283a 	ret

0015489c <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
  15489c:	defffa04 	addi	sp,sp,-24
  1548a0:	df000515 	stw	fp,20(sp)
  1548a4:	df000504 	addi	fp,sp,20
  1548a8:	e13ffd15 	stw	r4,-12(fp)
  1548ac:	e17ffe15 	stw	r5,-8(fp)
  1548b0:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
  1548b4:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
  1548b8:	e0bffd17 	ldw	r2,-12(fp)
  1548bc:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
  1548c0:	e0bffc17 	ldw	r2,-16(fp)
  1548c4:	10c00c17 	ldw	r3,48(r2)
  1548c8:	e0bfff17 	ldw	r2,-4(fp)
  1548cc:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
  1548d0:	e0bffc17 	ldw	r2,-16(fp)
  1548d4:	10800c17 	ldw	r2,48(r2)
  1548d8:	1000031e 	bne	r2,zero,1548e8 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
  1548dc:	00bffec4 	movi	r2,-5
  1548e0:	e0bffb15 	stw	r2,-20(fp)
  1548e4:	00000b06 	br	154914 <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
  1548e8:	e0bffc17 	ldw	r2,-16(fp)
  1548ec:	10800c17 	ldw	r2,48(r2)
  1548f0:	10800250 	cmplti	r2,r2,9
  1548f4:	1000031e 	bne	r2,zero,154904 <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
  1548f8:	00bffd04 	movi	r2,-12
  1548fc:	e0bffb15 	stw	r2,-20(fp)
  154900:	00000406 	br	154914 <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
  154904:	e0bffc17 	ldw	r2,-16(fp)
  154908:	10c00d04 	addi	r3,r2,52
  15490c:	e0bffe17 	ldw	r2,-8(fp)
  154910:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
  154914:	e0bffb17 	ldw	r2,-20(fp)
}
  154918:	e037883a 	mov	sp,fp
  15491c:	df000017 	ldw	fp,0(sp)
  154920:	dec00104 	addi	sp,sp,4
  154924:	f800283a 	ret

00154928 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
  154928:	defff904 	addi	sp,sp,-28
  15492c:	df000615 	stw	fp,24(sp)
  154930:	df000604 	addi	fp,sp,24
  154934:	e13ffe15 	stw	r4,-8(fp)
  154938:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
  15493c:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  154940:	e0bffe17 	ldw	r2,-8(fp)
  154944:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  154948:	e0bffb17 	ldw	r2,-20(fp)
  15494c:	10800c17 	ldw	r2,48(r2)
  154950:	10bfffc4 	addi	r2,r2,-1
  154954:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
  154958:	e0fffb17 	ldw	r3,-20(fp)
  15495c:	e0bffc17 	ldw	r2,-16(fp)
  154960:	1004913a 	slli	r2,r2,4
  154964:	1885883a 	add	r2,r3,r2
  154968:	10800d04 	addi	r2,r2,52
  15496c:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
  154970:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
  154974:	e13ffb17 	ldw	r4,-20(fp)
  154978:	e0bffc17 	ldw	r2,-16(fp)
  15497c:	1004913a 	slli	r2,r2,4
  154980:	2085883a 	add	r2,r4,r2
  154984:	10800e04 	addi	r2,r2,56
  154988:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
  15498c:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
  154990:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
  154994:	e0bfff17 	ldw	r2,-4(fp)
  154998:	e0fffd17 	ldw	r3,-12(fp)
  15499c:	1880022e 	bgeu	r3,r2,1549a8 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
  1549a0:	00bffec4 	movi	r2,-5
  1549a4:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
  1549a8:	e0bffa17 	ldw	r2,-24(fp)
}
  1549ac:	e037883a 	mov	sp,fp
  1549b0:	df000017 	ldw	fp,0(sp)
  1549b4:	dec00104 	addi	sp,sp,4
  1549b8:	f800283a 	ret

001549bc <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
  1549bc:	defffa04 	addi	sp,sp,-24
  1549c0:	dfc00515 	stw	ra,20(sp)
  1549c4:	df000415 	stw	fp,16(sp)
  1549c8:	df000404 	addi	fp,sp,16
  1549cc:	e13ffe15 	stw	r4,-8(fp)
  1549d0:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
  1549d4:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  1549d8:	e0bffe17 	ldw	r2,-8(fp)
  1549dc:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
  1549e0:	e13ffe17 	ldw	r4,-8(fp)
  1549e4:	e17fff17 	ldw	r5,-4(fp)
  1549e8:	01549280 	call	154928 <alt_epcs_test_address>
  1549ec:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
  1549f0:	e0bffc17 	ldw	r2,-16(fp)
  1549f4:	10000816 	blt	r2,zero,154a18 <alt_epcs_flash_erase_block+0x5c>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
  1549f8:	e0bffd17 	ldw	r2,-12(fp)
  1549fc:	11002d17 	ldw	r4,180(r2)
  154a00:	e0ffff17 	ldw	r3,-4(fp)
  154a04:	e0bffd17 	ldw	r2,-12(fp)
  154a08:	10803117 	ldw	r2,196(r2)
  154a0c:	180b883a 	mov	r5,r3
  154a10:	100d883a 	mov	r6,r2
  154a14:	0154c980 	call	154c98 <epcs_sector_erase>
  }
  return ret_code;
  154a18:	e0bffc17 	ldw	r2,-16(fp)
}
  154a1c:	e037883a 	mov	sp,fp
  154a20:	dfc00117 	ldw	ra,4(sp)
  154a24:	df000017 	ldw	fp,0(sp)
  154a28:	dec00204 	addi	sp,sp,8
  154a2c:	f800283a 	ret

00154a30 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
  154a30:	defff404 	addi	sp,sp,-48
  154a34:	dfc00b15 	stw	ra,44(sp)
  154a38:	df000a15 	stw	fp,40(sp)
  154a3c:	df000a04 	addi	fp,sp,40
  154a40:	e13ffc15 	stw	r4,-16(fp)
  154a44:	e17ffd15 	stw	r5,-12(fp)
  154a48:	e1bffe15 	stw	r6,-8(fp)
  154a4c:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  154a50:	e0bffc17 	ldw	r2,-16(fp)
  154a54:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
  154a58:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
  154a5c:	e13ffc17 	ldw	r4,-16(fp)
  154a60:	e17ffe17 	ldw	r5,-8(fp)
  154a64:	01549280 	call	154928 <alt_epcs_test_address>
  154a68:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
  154a6c:	e0bff917 	ldw	r2,-28(fp)
  154a70:	10002a16 	blt	r2,zero,154b1c <alt_epcs_flash_write_block+0xec>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
  154a74:	00002706 	br	154b14 <alt_epcs_flash_write_block+0xe4>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
  154a78:	e0bff817 	ldw	r2,-32(fp)
  154a7c:	10c03017 	ldw	r3,192(r2)
  154a80:	e0bffe17 	ldw	r2,-8(fp)
  154a84:	1887883a 	add	r3,r3,r2
  154a88:	e0bff817 	ldw	r2,-32(fp)
  154a8c:	10803017 	ldw	r2,192(r2)
  154a90:	0085c83a 	sub	r2,zero,r2
  154a94:	1884703a 	and	r2,r3,r2
  154a98:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
  154a9c:	e0fffa17 	ldw	r3,-24(fp)
  154aa0:	e0bffe17 	ldw	r2,-8(fp)
  154aa4:	1885c83a 	sub	r2,r3,r2
  154aa8:	e0c00217 	ldw	r3,8(fp)
  154aac:	1880010e 	bge	r3,r2,154ab4 <alt_epcs_flash_write_block+0x84>
  154ab0:	1805883a 	mov	r2,r3
  154ab4:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
  154ab8:	e0bff817 	ldw	r2,-32(fp)
  154abc:	10c02d17 	ldw	r3,180(r2)
  154ac0:	e0bff717 	ldw	r2,-36(fp)
  154ac4:	e13fff17 	ldw	r4,-4(fp)
  154ac8:	2085883a 	add	r2,r4,r2
          f->four_bytes_mode);
  154acc:	e13ff817 	ldw	r4,-32(fp)
    while (length)
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
      length_of_current_write = MIN(length, next_page_start - data_offset);

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
  154ad0:	21003117 	ldw	r4,196(r4)
  154ad4:	d9000015 	stw	r4,0(sp)
  154ad8:	1809883a 	mov	r4,r3
  154adc:	e17ffe17 	ldw	r5,-8(fp)
  154ae0:	100d883a 	mov	r6,r2
  154ae4:	e1fffb17 	ldw	r7,-20(fp)
  154ae8:	0154f3c0 	call	154f3c <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
  154aec:	e0c00217 	ldw	r3,8(fp)
  154af0:	e0bffb17 	ldw	r2,-20(fp)
  154af4:	1885c83a 	sub	r2,r3,r2
  154af8:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
  154afc:	e0fff717 	ldw	r3,-36(fp)
  154b00:	e0bffb17 	ldw	r2,-20(fp)
  154b04:	1885883a 	add	r2,r3,r2
  154b08:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
  154b0c:	e0bffa17 	ldw	r2,-24(fp)
  154b10:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
  154b14:	e0800217 	ldw	r2,8(fp)
  154b18:	103fd71e 	bne	r2,zero,154a78 <alt_epcs_flash_write_block+0x48>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
  154b1c:	e0bff917 	ldw	r2,-28(fp)
}
  154b20:	e037883a 	mov	sp,fp
  154b24:	dfc00117 	ldw	ra,4(sp)
  154b28:	df000017 	ldw	fp,0(sp)
  154b2c:	dec00204 	addi	sp,sp,8
  154b30:	f800283a 	ret

00154b34 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
  154b34:	defff704 	addi	sp,sp,-36
  154b38:	dfc00815 	stw	ra,32(sp)
  154b3c:	df000715 	stw	fp,28(sp)
  154b40:	df000704 	addi	fp,sp,28
  154b44:	e13ffc15 	stw	r4,-16(fp)
  154b48:	e17ffd15 	stw	r5,-12(fp)
  154b4c:	e1bffe15 	stw	r6,-8(fp)
  154b50:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
  154b54:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  154b58:	e0bffc17 	ldw	r2,-16(fp)
  154b5c:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
  154b60:	e13ffc17 	ldw	r4,-16(fp)
  154b64:	e17ffd17 	ldw	r5,-12(fp)
  154b68:	01549280 	call	154928 <alt_epcs_test_address>
  154b6c:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
  154b70:	e0bffa17 	ldw	r2,-24(fp)
  154b74:	10000f16 	blt	r2,zero,154bb4 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
  154b78:	e0bffb17 	ldw	r2,-20(fp)
  154b7c:	10802d17 	ldw	r2,180(r2)
                                f->four_bytes_mode);
  154b80:	e0fffb17 	ldw	r3,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);

  if (ret_code >= 0)
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
  154b84:	18c03117 	ldw	r3,196(r3)
  154b88:	d8c00015 	stw	r3,0(sp)
  154b8c:	1009883a 	mov	r4,r2
  154b90:	e17ffd17 	ldw	r5,-12(fp)
  154b94:	e1bffe17 	ldw	r6,-8(fp)
  154b98:	e1ffff17 	ldw	r7,-4(fp)
  154b9c:	0154d900 	call	154d90 <epcs_read_buffer>
  154ba0:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
  154ba4:	e0fffa17 	ldw	r3,-24(fp)
  154ba8:	e0bfff17 	ldw	r2,-4(fp)
  154bac:	1880011e 	bne	r3,r2,154bb4 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
  154bb0:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
  154bb4:	e0bffa17 	ldw	r2,-24(fp)
}
  154bb8:	e037883a 	mov	sp,fp
  154bbc:	dfc00117 	ldw	ra,4(sp)
  154bc0:	df000017 	ldw	fp,0(sp)
  154bc4:	dec00204 	addi	sp,sp,8
  154bc8:	f800283a 	ret

00154bcc <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
  154bcc:	defff904 	addi	sp,sp,-28
  154bd0:	dfc00615 	stw	ra,24(sp)
  154bd4:	df000515 	stw	fp,20(sp)
  154bd8:	df000504 	addi	fp,sp,20
  154bdc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
  154be0:	00800144 	movi	r2,5
  154be4:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
  154be8:	00800044 	movi	r2,1
  154bec:	d8800015 	stw	r2,0(sp)
  154bf0:	e0bffe44 	addi	r2,fp,-7
  154bf4:	d8800115 	stw	r2,4(sp)
  154bf8:	d8000215 	stw	zero,8(sp)
  154bfc:	e13fff17 	ldw	r4,-4(fp)
  154c00:	000b883a 	mov	r5,zero
  154c04:	01800044 	movi	r6,1
  154c08:	e1fffe04 	addi	r7,fp,-8
  154c0c:	01556600 	call	155660 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
  154c10:	e0bffe43 	ldbu	r2,-7(fp)
}
  154c14:	e037883a 	mov	sp,fp
  154c18:	dfc00117 	ldw	ra,4(sp)
  154c1c:	df000017 	ldw	fp,0(sp)
  154c20:	dec00204 	addi	sp,sp,8
  154c24:	f800283a 	ret

00154c28 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  154c28:	defffd04 	addi	sp,sp,-12
  154c2c:	dfc00215 	stw	ra,8(sp)
  154c30:	df000115 	stw	fp,4(sp)
  154c34:	df000104 	addi	fp,sp,4
  154c38:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
  154c3c:	e13fff17 	ldw	r4,-4(fp)
  154c40:	0154bcc0 	call	154bcc <epcs_read_status_register>
  154c44:	10803fcc 	andi	r2,r2,255
  154c48:	1080004c 	andi	r2,r2,1
}
  154c4c:	e037883a 	mov	sp,fp
  154c50:	dfc00117 	ldw	ra,4(sp)
  154c54:	df000017 	ldw	fp,0(sp)
  154c58:	dec00204 	addi	sp,sp,8
  154c5c:	f800283a 	ret

00154c60 <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  154c60:	defffd04 	addi	sp,sp,-12
  154c64:	dfc00215 	stw	ra,8(sp)
  154c68:	df000115 	stw	fp,4(sp)
  154c6c:	df000104 	addi	fp,sp,4
  154c70:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
  154c74:	0001883a 	nop
  154c78:	e13fff17 	ldw	r4,-4(fp)
  154c7c:	0154c280 	call	154c28 <epcs_test_wip>
  154c80:	103ffd1e 	bne	r2,zero,154c78 <epcs_await_wip_released+0x18>
  {
  }
}
  154c84:	e037883a 	mov	sp,fp
  154c88:	dfc00117 	ldw	ra,4(sp)
  154c8c:	df000017 	ldw	fp,0(sp)
  154c90:	dec00204 	addi	sp,sp,8
  154c94:	f800283a 	ret

00154c98 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
  154c98:	defff604 	addi	sp,sp,-40
  154c9c:	dfc00915 	stw	ra,36(sp)
  154ca0:	df000815 	stw	fp,32(sp)
  154ca4:	df000804 	addi	fp,sp,32
  154ca8:	e13ffd15 	stw	r4,-12(fp)
  154cac:	e17ffe15 	stw	r5,-8(fp)
  154cb0:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
  154cb4:	e0bfff17 	ldw	r2,-4(fp)
  154cb8:	10001226 	beq	r2,zero,154d04 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
  154cbc:	00bff604 	movi	r2,-40
  154cc0:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
  154cc4:	e0bffe17 	ldw	r2,-8(fp)
  154cc8:	1004d63a 	srli	r2,r2,24
  154ccc:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
  154cd0:	e0bffe17 	ldw	r2,-8(fp)
  154cd4:	1004d43a 	srli	r2,r2,16
  154cd8:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
  154cdc:	e0bffe17 	ldw	r2,-8(fp)
  154ce0:	1004d23a 	srli	r2,r2,8
  154ce4:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
  154ce8:	e0bffe17 	ldw	r2,-8(fp)
  154cec:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
  154cf0:	00800144 	movi	r2,5
  154cf4:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
  154cf8:	e13ffd17 	ldw	r4,-12(fp)
  154cfc:	01551400 	call	155140 <epcs_enter_4_bytes_mode>
  154d00:	00000c06 	br	154d34 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
  154d04:	00bff604 	movi	r2,-40
  154d08:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
  154d0c:	e0bffe17 	ldw	r2,-8(fp)
  154d10:	1004d43a 	srli	r2,r2,16
  154d14:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
  154d18:	e0bffe17 	ldw	r2,-8(fp)
  154d1c:	1004d23a 	srli	r2,r2,8
  154d20:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
  154d24:	e0bffe17 	ldw	r2,-8(fp)
  154d28:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
  154d2c:	00800104 	movi	r2,4
  154d30:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
  154d34:	e13ffd17 	ldw	r4,-12(fp)
  154d38:	0154e840 	call	154e84 <epcs_write_enable>

  alt_avalon_spi_command(
  154d3c:	e0fffb03 	ldbu	r3,-20(fp)
    base,
    0,
    len,
    se,
  154d40:	e0bffb44 	addi	r2,fp,-19
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);

  alt_avalon_spi_command(
  154d44:	d8000015 	stw	zero,0(sp)
  154d48:	d8000115 	stw	zero,4(sp)
  154d4c:	d8000215 	stw	zero,8(sp)
  154d50:	e13ffd17 	ldw	r4,-12(fp)
  154d54:	000b883a 	mov	r5,zero
  154d58:	180d883a 	mov	r6,r3
  154d5c:	100f883a 	mov	r7,r2
  154d60:	01556600 	call	155660 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
  154d64:	e13ffd17 	ldw	r4,-12(fp)
  154d68:	0154c600 	call	154c60 <epcs_await_wip_released>

  if(four_bytes_mode)
  154d6c:	e0bfff17 	ldw	r2,-4(fp)
  154d70:	10000226 	beq	r2,zero,154d7c <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
  154d74:	e13ffd17 	ldw	r4,-12(fp)
  154d78:	01551980 	call	155198 <epcs_exit_4_bytes_mode>
  }
}
  154d7c:	e037883a 	mov	sp,fp
  154d80:	dfc00117 	ldw	ra,4(sp)
  154d84:	df000017 	ldw	fp,0(sp)
  154d88:	dec00204 	addi	sp,sp,8
  154d8c:	f800283a 	ret

00154d90 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
  154d90:	defff404 	addi	sp,sp,-48
  154d94:	dfc00b15 	stw	ra,44(sp)
  154d98:	df000a15 	stw	fp,40(sp)
  154d9c:	df000a04 	addi	fp,sp,40
  154da0:	e13ffc15 	stw	r4,-16(fp)
  154da4:	e17ffd15 	stw	r5,-12(fp)
  154da8:	e1bffe15 	stw	r6,-8(fp)
  154dac:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
  154db0:	008000c4 	movi	r2,3
  154db4:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
  154db8:	e0800217 	ldw	r2,8(fp)
  154dbc:	10001026 	beq	r2,zero,154e00 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
  154dc0:	e0bffd17 	ldw	r2,-12(fp)
  154dc4:	1004d63a 	srli	r2,r2,24
  154dc8:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
  154dcc:	e0bffd17 	ldw	r2,-12(fp)
  154dd0:	1005d43a 	srai	r2,r2,16
  154dd4:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
  154dd8:	e0bffd17 	ldw	r2,-12(fp)
  154ddc:	1005d23a 	srai	r2,r2,8
  154de0:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
  154de4:	e0bffd17 	ldw	r2,-12(fp)
  154de8:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
  154dec:	00800144 	movi	r2,5
  154df0:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
  154df4:	e13ffc17 	ldw	r4,-16(fp)
  154df8:	01551400 	call	155140 <epcs_enter_4_bytes_mode>
  154dfc:	00000a06 	br	154e28 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
  154e00:	e0bffd17 	ldw	r2,-12(fp)
  154e04:	1005d43a 	srai	r2,r2,16
  154e08:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
  154e0c:	e0bffd17 	ldw	r2,-12(fp)
  154e10:	1005d23a 	srai	r2,r2,8
  154e14:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
  154e18:	e0bffd17 	ldw	r2,-12(fp)
  154e1c:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
  154e20:	00800104 	movi	r2,4
  154e24:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
  154e28:	e13ffc17 	ldw	r4,-16(fp)
  154e2c:	0154c600 	call	154c60 <epcs_await_wip_released>

  alt_avalon_spi_command(
  154e30:	e0ffff17 	ldw	r3,-4(fp)
    base,
    0,
    cmd_len,
    read_command,
  154e34:	e0bffa04 	addi	r2,fp,-24
        cmd_len = 4;
  }

  epcs_await_wip_released(base);

  alt_avalon_spi_command(
  154e38:	d8c00015 	stw	r3,0(sp)
  154e3c:	e0fffe17 	ldw	r3,-8(fp)
  154e40:	d8c00115 	stw	r3,4(sp)
  154e44:	d8000215 	stw	zero,8(sp)
  154e48:	e13ffc17 	ldw	r4,-16(fp)
  154e4c:	000b883a 	mov	r5,zero
  154e50:	e1bff917 	ldw	r6,-28(fp)
  154e54:	100f883a 	mov	r7,r2
  154e58:	01556600 	call	155660 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
  154e5c:	e0800217 	ldw	r2,8(fp)
  154e60:	10000226 	beq	r2,zero,154e6c <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
  154e64:	e13ffc17 	ldw	r4,-16(fp)
  154e68:	01551980 	call	155198 <epcs_exit_4_bytes_mode>
  }

  return length;
  154e6c:	e0bfff17 	ldw	r2,-4(fp)
}
  154e70:	e037883a 	mov	sp,fp
  154e74:	dfc00117 	ldw	ra,4(sp)
  154e78:	df000017 	ldw	fp,0(sp)
  154e7c:	dec00204 	addi	sp,sp,8
  154e80:	f800283a 	ret

00154e84 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
  154e84:	defff904 	addi	sp,sp,-28
  154e88:	dfc00615 	stw	ra,24(sp)
  154e8c:	df000515 	stw	fp,20(sp)
  154e90:	df000504 	addi	fp,sp,20
  154e94:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
  154e98:	00800184 	movi	r2,6
  154e9c:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
  154ea0:	d8000015 	stw	zero,0(sp)
  154ea4:	d8000115 	stw	zero,4(sp)
  154ea8:	d8000215 	stw	zero,8(sp)
  154eac:	e13fff17 	ldw	r4,-4(fp)
  154eb0:	000b883a 	mov	r5,zero
  154eb4:	01800044 	movi	r6,1
  154eb8:	e1fffe04 	addi	r7,fp,-8
  154ebc:	01556600 	call	155660 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
  154ec0:	e037883a 	mov	sp,fp
  154ec4:	dfc00117 	ldw	ra,4(sp)
  154ec8:	df000017 	ldw	fp,0(sp)
  154ecc:	dec00204 	addi	sp,sp,8
  154ed0:	f800283a 	ret

00154ed4 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
  154ed4:	defff804 	addi	sp,sp,-32
  154ed8:	dfc00715 	stw	ra,28(sp)
  154edc:	df000615 	stw	fp,24(sp)
  154ee0:	df000604 	addi	fp,sp,24
  154ee4:	e13ffe15 	stw	r4,-8(fp)
  154ee8:	2805883a 	mov	r2,r5
  154eec:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
  154ef0:	00800044 	movi	r2,1
  154ef4:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
  154ef8:	e0bfff03 	ldbu	r2,-4(fp)
  154efc:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
  154f00:	d8000015 	stw	zero,0(sp)
  154f04:	d8000115 	stw	zero,4(sp)
  154f08:	d8000215 	stw	zero,8(sp)
  154f0c:	e13ffe17 	ldw	r4,-8(fp)
  154f10:	000b883a 	mov	r5,zero
  154f14:	01800084 	movi	r6,2
  154f18:	e1fffd04 	addi	r7,fp,-12
  154f1c:	01556600 	call	155660 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
  154f20:	e13ffe17 	ldw	r4,-8(fp)
  154f24:	0154c600 	call	154c60 <epcs_await_wip_released>
}
  154f28:	e037883a 	mov	sp,fp
  154f2c:	dfc00117 	ldw	ra,4(sp)
  154f30:	df000017 	ldw	fp,0(sp)
  154f34:	dec00204 	addi	sp,sp,8
  154f38:	f800283a 	ret

00154f3c <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
  154f3c:	defff404 	addi	sp,sp,-48
  154f40:	dfc00b15 	stw	ra,44(sp)
  154f44:	df000a15 	stw	fp,40(sp)
  154f48:	df000a04 	addi	fp,sp,40
  154f4c:	e13ffc15 	stw	r4,-16(fp)
  154f50:	e17ffd15 	stw	r5,-12(fp)
  154f54:	e1bffe15 	stw	r6,-8(fp)
  154f58:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
  154f5c:	00800084 	movi	r2,2
  154f60:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
  154f64:	e0800217 	ldw	r2,8(fp)
  154f68:	10001026 	beq	r2,zero,154fac <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
  154f6c:	e0bffd17 	ldw	r2,-12(fp)
  154f70:	1004d63a 	srli	r2,r2,24
  154f74:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
  154f78:	e0bffd17 	ldw	r2,-12(fp)
  154f7c:	1005d43a 	srai	r2,r2,16
  154f80:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
  154f84:	e0bffd17 	ldw	r2,-12(fp)
  154f88:	1005d23a 	srai	r2,r2,8
  154f8c:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
  154f90:	e0bffd17 	ldw	r2,-12(fp)
  154f94:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
  154f98:	00800144 	movi	r2,5
  154f9c:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
  154fa0:	e13ffc17 	ldw	r4,-16(fp)
  154fa4:	01551400 	call	155140 <epcs_enter_4_bytes_mode>
  154fa8:	00000a06 	br	154fd4 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
  154fac:	e0bffd17 	ldw	r2,-12(fp)
  154fb0:	1005d43a 	srai	r2,r2,16
  154fb4:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
  154fb8:	e0bffd17 	ldw	r2,-12(fp)
  154fbc:	1005d23a 	srai	r2,r2,8
  154fc0:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
  154fc4:	e0bffd17 	ldw	r2,-12(fp)
  154fc8:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
  154fcc:	00800104 	movi	r2,4
  154fd0:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
  154fd4:	e13ffc17 	ldw	r4,-16(fp)
  154fd8:	0154e840 	call	154e84 <epcs_write_enable>
  /* Send the PP command */
  alt_avalon_spi_command(
    base,
    0,
    cmd_len,
    pp,
  154fdc:	e0bffa04 	addi	r2,fp,-24

  /* First, WREN */
  epcs_write_enable(base);

  /* Send the PP command */
  alt_avalon_spi_command(
  154fe0:	d8000015 	stw	zero,0(sp)
  154fe4:	d8000115 	stw	zero,4(sp)
  154fe8:	00c00044 	movi	r3,1
  154fec:	d8c00215 	stw	r3,8(sp)
  154ff0:	e13ffc17 	ldw	r4,-16(fp)
  154ff4:	000b883a 	mov	r5,zero
  154ff8:	e1bff917 	ldw	r6,-28(fp)
  154ffc:	100f883a 	mov	r7,r2
  155000:	01556600 	call	155660 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
  155004:	e0bfff17 	ldw	r2,-4(fp)
  155008:	d8000015 	stw	zero,0(sp)
  15500c:	d8000115 	stw	zero,4(sp)
  155010:	d8000215 	stw	zero,8(sp)
  155014:	e13ffc17 	ldw	r4,-16(fp)
  155018:	000b883a 	mov	r5,zero
  15501c:	100d883a 	mov	r6,r2
  155020:	e1fffe17 	ldw	r7,-8(fp)
  155024:	01556600 	call	155660 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
  155028:	e13ffc17 	ldw	r4,-16(fp)
  15502c:	0154c600 	call	154c60 <epcs_await_wip_released>

  if(four_bytes_mode)
  155030:	e0800217 	ldw	r2,8(fp)
  155034:	10000226 	beq	r2,zero,155040 <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
  155038:	e13ffc17 	ldw	r4,-16(fp)
  15503c:	01551980 	call	155198 <epcs_exit_4_bytes_mode>
  }

  return length;
  155040:	e0bfff17 	ldw	r2,-4(fp)
}
  155044:	e037883a 	mov	sp,fp
  155048:	dfc00117 	ldw	ra,4(sp)
  15504c:	df000017 	ldw	fp,0(sp)
  155050:	dec00204 	addi	sp,sp,8
  155054:	f800283a 	ret

00155058 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
  155058:	defff804 	addi	sp,sp,-32
  15505c:	dfc00715 	stw	ra,28(sp)
  155060:	df000615 	stw	fp,24(sp)
  155064:	df000604 	addi	fp,sp,24
  155068:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
  15506c:	00bfeac4 	movi	r2,-85
  155070:	e0bffd05 	stb	r2,-12(fp)
  155074:	e03ffd45 	stb	zero,-11(fp)
  155078:	e03ffd85 	stb	zero,-10(fp)
  15507c:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
  155080:	00800044 	movi	r2,1
  155084:	d8800015 	stw	r2,0(sp)
  155088:	e0bffe04 	addi	r2,fp,-8
  15508c:	d8800115 	stw	r2,4(sp)
  155090:	d8000215 	stw	zero,8(sp)
  155094:	e13fff17 	ldw	r4,-4(fp)
  155098:	000b883a 	mov	r5,zero
  15509c:	01800104 	movi	r6,4
  1550a0:	e1fffd04 	addi	r7,fp,-12
  1550a4:	01556600 	call	155660 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
  1550a8:	e0bffe03 	ldbu	r2,-8(fp)
}
  1550ac:	e037883a 	mov	sp,fp
  1550b0:	dfc00117 	ldw	ra,4(sp)
  1550b4:	df000017 	ldw	fp,0(sp)
  1550b8:	dec00204 	addi	sp,sp,8
  1550bc:	f800283a 	ret

001550c0 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
  1550c0:	defff904 	addi	sp,sp,-28
  1550c4:	dfc00615 	stw	ra,24(sp)
  1550c8:	df000515 	stw	fp,20(sp)
  1550cc:	df000504 	addi	fp,sp,20
  1550d0:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
  1550d4:	00bfe7c4 	movi	r2,-97
  1550d8:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
  1550dc:	008000c4 	movi	r2,3
  1550e0:	d8800015 	stw	r2,0(sp)
    base,
    0,
    sizeof(rd_id_cmd) / sizeof(*rd_id_cmd),
    rd_id_cmd,
    3,
    id,
  1550e4:	e0bffe44 	addi	r2,fp,-7
alt_u32 epcs_read_device_id(alt_u32 base)
{
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
  alt_u8 id[3];

  alt_avalon_spi_command(
  1550e8:	d8800115 	stw	r2,4(sp)
  1550ec:	d8000215 	stw	zero,8(sp)
  1550f0:	e13fff17 	ldw	r4,-4(fp)
  1550f4:	000b883a 	mov	r5,zero
  1550f8:	01800044 	movi	r6,1
  1550fc:	e1fffe04 	addi	r7,fp,-8
  155100:	01556600 	call	155660 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
  155104:	e0bffe43 	ldbu	r2,-7(fp)
  155108:	10803fcc 	andi	r2,r2,255
  15510c:	1006943a 	slli	r3,r2,16
  155110:	e0bffe83 	ldbu	r2,-6(fp)
  155114:	10803fcc 	andi	r2,r2,255
  155118:	1004923a 	slli	r2,r2,8
  15511c:	1886b03a 	or	r3,r3,r2
  155120:	e0bffec3 	ldbu	r2,-5(fp)
  155124:	10803fcc 	andi	r2,r2,255
  155128:	1884b03a 	or	r2,r3,r2
}
  15512c:	e037883a 	mov	sp,fp
  155130:	dfc00117 	ldw	ra,4(sp)
  155134:	df000017 	ldw	fp,0(sp)
  155138:	dec00204 	addi	sp,sp,8
  15513c:	f800283a 	ret

00155140 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
  155140:	defff904 	addi	sp,sp,-28
  155144:	dfc00615 	stw	ra,24(sp)
  155148:	df000515 	stw	fp,20(sp)
  15514c:	df000504 	addi	fp,sp,20
  155150:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
  155154:	00bfedc4 	movi	r2,-73
  155158:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
  15515c:	e13fff17 	ldw	r4,-4(fp)
  155160:	0154e840 	call	154e84 <epcs_write_enable>

  alt_avalon_spi_command(
  155164:	d8000015 	stw	zero,0(sp)
  155168:	d8000115 	stw	zero,4(sp)
  15516c:	d8000215 	stw	zero,8(sp)
  155170:	e13fff17 	ldw	r4,-4(fp)
  155174:	000b883a 	mov	r5,zero
  155178:	01800044 	movi	r6,1
  15517c:	e1fffe04 	addi	r7,fp,-8
  155180:	01556600 	call	155660 <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
  155184:	e037883a 	mov	sp,fp
  155188:	dfc00117 	ldw	ra,4(sp)
  15518c:	df000017 	ldw	fp,0(sp)
  155190:	dec00204 	addi	sp,sp,8
  155194:	f800283a 	ret

00155198 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
  155198:	defff904 	addi	sp,sp,-28
  15519c:	dfc00615 	stw	ra,24(sp)
  1551a0:	df000515 	stw	fp,20(sp)
  1551a4:	df000504 	addi	fp,sp,20
  1551a8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
  1551ac:	00bffa44 	movi	r2,-23
  1551b0:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
  1551b4:	e13fff17 	ldw	r4,-4(fp)
  1551b8:	0154e840 	call	154e84 <epcs_write_enable>

  alt_avalon_spi_command(
  1551bc:	d8000015 	stw	zero,0(sp)
  1551c0:	d8000115 	stw	zero,4(sp)
  1551c4:	d8000215 	stw	zero,8(sp)
  1551c8:	e13fff17 	ldw	r4,-4(fp)
  1551cc:	000b883a 	mov	r5,zero
  1551d0:	01800044 	movi	r6,1
  1551d4:	e1fffe04 	addi	r7,fp,-8
  1551d8:	01556600 	call	155660 <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
  1551dc:	e037883a 	mov	sp,fp
  1551e0:	dfc00117 	ldw	ra,4(sp)
  1551e4:	df000017 	ldw	fp,0(sp)
  1551e8:	dec00204 	addi	sp,sp,8
  1551ec:	f800283a 	ret

001551f0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1551f0:	defffe04 	addi	sp,sp,-8
  1551f4:	dfc00115 	stw	ra,4(sp)
  1551f8:	df000015 	stw	fp,0(sp)
  1551fc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  155200:	00800574 	movhi	r2,21
  155204:	109c7c04 	addi	r2,r2,29168
  155208:	10800017 	ldw	r2,0(r2)
  15520c:	10000526 	beq	r2,zero,155224 <alt_get_errno+0x34>
  155210:	00800574 	movhi	r2,21
  155214:	109c7c04 	addi	r2,r2,29168
  155218:	10800017 	ldw	r2,0(r2)
  15521c:	103ee83a 	callr	r2
  155220:	00000206 	br	15522c <alt_get_errno+0x3c>
  155224:	00800574 	movhi	r2,21
  155228:	109fae04 	addi	r2,r2,32440
}
  15522c:	e037883a 	mov	sp,fp
  155230:	dfc00117 	ldw	ra,4(sp)
  155234:	df000017 	ldw	fp,0(sp)
  155238:	dec00204 	addi	sp,sp,8
  15523c:	f800283a 	ret

00155240 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  155240:	defffb04 	addi	sp,sp,-20
  155244:	dfc00415 	stw	ra,16(sp)
  155248:	df000315 	stw	fp,12(sp)
  15524c:	df000304 	addi	fp,sp,12
  155250:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  155254:	e0bfff17 	ldw	r2,-4(fp)
  155258:	10000616 	blt	r2,zero,155274 <close+0x34>
  15525c:	e0bfff17 	ldw	r2,-4(fp)
  155260:	10c00324 	muli	r3,r2,12
  155264:	00800574 	movhi	r2,21
  155268:	109b1604 	addi	r2,r2,27736
  15526c:	1885883a 	add	r2,r3,r2
  155270:	00000106 	br	155278 <close+0x38>
  155274:	0005883a 	mov	r2,zero
  155278:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  15527c:	e0bffd17 	ldw	r2,-12(fp)
  155280:	10001826 	beq	r2,zero,1552e4 <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  155284:	e0bffd17 	ldw	r2,-12(fp)
  155288:	10800017 	ldw	r2,0(r2)
  15528c:	10800417 	ldw	r2,16(r2)
  155290:	10000626 	beq	r2,zero,1552ac <close+0x6c>
  155294:	e0bffd17 	ldw	r2,-12(fp)
  155298:	10800017 	ldw	r2,0(r2)
  15529c:	10800417 	ldw	r2,16(r2)
  1552a0:	e13ffd17 	ldw	r4,-12(fp)
  1552a4:	103ee83a 	callr	r2
  1552a8:	00000106 	br	1552b0 <close+0x70>
  1552ac:	0005883a 	mov	r2,zero
  1552b0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  1552b4:	e13fff17 	ldw	r4,-4(fp)
  1552b8:	01555e00 	call	1555e0 <alt_release_fd>
    if (rval < 0)
  1552bc:	e0bffe17 	ldw	r2,-8(fp)
  1552c0:	1000060e 	bge	r2,zero,1552dc <close+0x9c>
    {
      ALT_ERRNO = -rval;
  1552c4:	01551f00 	call	1551f0 <alt_get_errno>
  1552c8:	e0fffe17 	ldw	r3,-8(fp)
  1552cc:	00c7c83a 	sub	r3,zero,r3
  1552d0:	10c00015 	stw	r3,0(r2)
      return -1;
  1552d4:	00bfffc4 	movi	r2,-1
  1552d8:	00000606 	br	1552f4 <close+0xb4>
    }
    return 0;
  1552dc:	0005883a 	mov	r2,zero
  1552e0:	00000406 	br	1552f4 <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  1552e4:	01551f00 	call	1551f0 <alt_get_errno>
  1552e8:	00c01444 	movi	r3,81
  1552ec:	10c00015 	stw	r3,0(r2)
    return -1;
  1552f0:	00bfffc4 	movi	r2,-1
  }
}
  1552f4:	e037883a 	mov	sp,fp
  1552f8:	dfc00117 	ldw	ra,4(sp)
  1552fc:	df000017 	ldw	fp,0(sp)
  155300:	dec00204 	addi	sp,sp,8
  155304:	f800283a 	ret

00155308 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  155308:	deffff04 	addi	sp,sp,-4
  15530c:	df000015 	stw	fp,0(sp)
  155310:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  155314:	e037883a 	mov	sp,fp
  155318:	df000017 	ldw	fp,0(sp)
  15531c:	dec00104 	addi	sp,sp,4
  155320:	f800283a 	ret

00155324 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  155324:	defffc04 	addi	sp,sp,-16
  155328:	df000315 	stw	fp,12(sp)
  15532c:	df000304 	addi	fp,sp,12
  155330:	e13ffd15 	stw	r4,-12(fp)
  155334:	e17ffe15 	stw	r5,-8(fp)
  155338:	e1bfff15 	stw	r6,-4(fp)
  return len;
  15533c:	e0bfff17 	ldw	r2,-4(fp)
}
  155340:	e037883a 	mov	sp,fp
  155344:	df000017 	ldw	fp,0(sp)
  155348:	dec00104 	addi	sp,sp,4
  15534c:	f800283a 	ret

00155350 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  155350:	defffe04 	addi	sp,sp,-8
  155354:	dfc00115 	stw	ra,4(sp)
  155358:	df000015 	stw	fp,0(sp)
  15535c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  155360:	00800574 	movhi	r2,21
  155364:	109c7c04 	addi	r2,r2,29168
  155368:	10800017 	ldw	r2,0(r2)
  15536c:	10000526 	beq	r2,zero,155384 <alt_get_errno+0x34>
  155370:	00800574 	movhi	r2,21
  155374:	109c7c04 	addi	r2,r2,29168
  155378:	10800017 	ldw	r2,0(r2)
  15537c:	103ee83a 	callr	r2
  155380:	00000206 	br	15538c <alt_get_errno+0x3c>
  155384:	00800574 	movhi	r2,21
  155388:	109fae04 	addi	r2,r2,32440
}
  15538c:	e037883a 	mov	sp,fp
  155390:	dfc00117 	ldw	ra,4(sp)
  155394:	df000017 	ldw	fp,0(sp)
  155398:	dec00204 	addi	sp,sp,8
  15539c:	f800283a 	ret

001553a0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  1553a0:	defffa04 	addi	sp,sp,-24
  1553a4:	dfc00515 	stw	ra,20(sp)
  1553a8:	df000415 	stw	fp,16(sp)
  1553ac:	df000404 	addi	fp,sp,16
  1553b0:	e13ffe15 	stw	r4,-8(fp)
  1553b4:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  1553b8:	e0bffe17 	ldw	r2,-8(fp)
  1553bc:	10000326 	beq	r2,zero,1553cc <alt_dev_llist_insert+0x2c>
  1553c0:	e0bffe17 	ldw	r2,-8(fp)
  1553c4:	10800217 	ldw	r2,8(r2)
  1553c8:	1000051e 	bne	r2,zero,1553e0 <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
  1553cc:	01553500 	call	155350 <alt_get_errno>
  1553d0:	00c00584 	movi	r3,22
  1553d4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  1553d8:	00bffa84 	movi	r2,-22
  1553dc:	00001306 	br	15542c <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  1553e0:	e0bffe17 	ldw	r2,-8(fp)
  1553e4:	e0ffff17 	ldw	r3,-4(fp)
  1553e8:	e0fffc15 	stw	r3,-16(fp)
  1553ec:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  1553f0:	e0bffd17 	ldw	r2,-12(fp)
  1553f4:	e0fffc17 	ldw	r3,-16(fp)
  1553f8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  1553fc:	e0bffc17 	ldw	r2,-16(fp)
  155400:	10c00017 	ldw	r3,0(r2)
  155404:	e0bffd17 	ldw	r2,-12(fp)
  155408:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  15540c:	e0bffc17 	ldw	r2,-16(fp)
  155410:	10800017 	ldw	r2,0(r2)
  155414:	e0fffd17 	ldw	r3,-12(fp)
  155418:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  15541c:	e0bffc17 	ldw	r2,-16(fp)
  155420:	e0fffd17 	ldw	r3,-12(fp)
  155424:	10c00015 	stw	r3,0(r2)

  return 0;  
  155428:	0005883a 	mov	r2,zero
}
  15542c:	e037883a 	mov	sp,fp
  155430:	dfc00117 	ldw	ra,4(sp)
  155434:	df000017 	ldw	fp,0(sp)
  155438:	dec00204 	addi	sp,sp,8
  15543c:	f800283a 	ret

00155440 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  155440:	defffd04 	addi	sp,sp,-12
  155444:	dfc00215 	stw	ra,8(sp)
  155448:	df000115 	stw	fp,4(sp)
  15544c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  155450:	00800574 	movhi	r2,21
  155454:	10977804 	addi	r2,r2,24032
  155458:	e0bfff15 	stw	r2,-4(fp)
  15545c:	00000606 	br	155478 <_do_ctors+0x38>
        (*ctor) (); 
  155460:	e0bfff17 	ldw	r2,-4(fp)
  155464:	10800017 	ldw	r2,0(r2)
  155468:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  15546c:	e0bfff17 	ldw	r2,-4(fp)
  155470:	10bfff04 	addi	r2,r2,-4
  155474:	e0bfff15 	stw	r2,-4(fp)
  155478:	e0ffff17 	ldw	r3,-4(fp)
  15547c:	00800574 	movhi	r2,21
  155480:	10977904 	addi	r2,r2,24036
  155484:	18bff62e 	bgeu	r3,r2,155460 <_do_ctors+0x20>
        (*ctor) (); 
}
  155488:	e037883a 	mov	sp,fp
  15548c:	dfc00117 	ldw	ra,4(sp)
  155490:	df000017 	ldw	fp,0(sp)
  155494:	dec00204 	addi	sp,sp,8
  155498:	f800283a 	ret

0015549c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  15549c:	defffd04 	addi	sp,sp,-12
  1554a0:	dfc00215 	stw	ra,8(sp)
  1554a4:	df000115 	stw	fp,4(sp)
  1554a8:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  1554ac:	00800574 	movhi	r2,21
  1554b0:	10977804 	addi	r2,r2,24032
  1554b4:	e0bfff15 	stw	r2,-4(fp)
  1554b8:	00000606 	br	1554d4 <_do_dtors+0x38>
        (*dtor) (); 
  1554bc:	e0bfff17 	ldw	r2,-4(fp)
  1554c0:	10800017 	ldw	r2,0(r2)
  1554c4:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  1554c8:	e0bfff17 	ldw	r2,-4(fp)
  1554cc:	10bfff04 	addi	r2,r2,-4
  1554d0:	e0bfff15 	stw	r2,-4(fp)
  1554d4:	e0ffff17 	ldw	r3,-4(fp)
  1554d8:	00800574 	movhi	r2,21
  1554dc:	10977904 	addi	r2,r2,24036
  1554e0:	18bff62e 	bgeu	r3,r2,1554bc <_do_dtors+0x20>
        (*dtor) (); 
}
  1554e4:	e037883a 	mov	sp,fp
  1554e8:	dfc00117 	ldw	ra,4(sp)
  1554ec:	df000017 	ldw	fp,0(sp)
  1554f0:	dec00204 	addi	sp,sp,8
  1554f4:	f800283a 	ret

001554f8 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
  1554f8:	defffc04 	addi	sp,sp,-16
  1554fc:	dfc00315 	stw	ra,12(sp)
  155500:	df000215 	stw	fp,8(sp)
  155504:	df000204 	addi	fp,sp,8
  155508:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
  15550c:	e13fff17 	ldw	r4,-4(fp)
  155510:	d1600704 	addi	r5,gp,-32740
  155514:	01558680 	call	155868 <alt_find_dev>
  155518:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
  15551c:	e0bffe17 	ldw	r2,-8(fp)
  155520:	10000926 	beq	r2,zero,155548 <alt_flash_open_dev+0x50>
  155524:	e0bffe17 	ldw	r2,-8(fp)
  155528:	10800317 	ldw	r2,12(r2)
  15552c:	10000626 	beq	r2,zero,155548 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
  155530:	e0bffe17 	ldw	r2,-8(fp)
  155534:	10800317 	ldw	r2,12(r2)
  155538:	e13ffe17 	ldw	r4,-8(fp)
  15553c:	e17fff17 	ldw	r5,-4(fp)
  155540:	103ee83a 	callr	r2
  155544:	00000106 	br	15554c <alt_flash_open_dev+0x54>
  }

  return dev;
  155548:	e0bffe17 	ldw	r2,-8(fp)
}
  15554c:	e037883a 	mov	sp,fp
  155550:	dfc00117 	ldw	ra,4(sp)
  155554:	df000017 	ldw	fp,0(sp)
  155558:	dec00204 	addi	sp,sp,8
  15555c:	f800283a 	ret

00155560 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
  155560:	defffd04 	addi	sp,sp,-12
  155564:	dfc00215 	stw	ra,8(sp)
  155568:	df000115 	stw	fp,4(sp)
  15556c:	df000104 	addi	fp,sp,4
  155570:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
  155574:	e0bfff17 	ldw	r2,-4(fp)
  155578:	10000726 	beq	r2,zero,155598 <alt_flash_close_dev+0x38>
  15557c:	e0bfff17 	ldw	r2,-4(fp)
  155580:	10800417 	ldw	r2,16(r2)
  155584:	10000426 	beq	r2,zero,155598 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
  155588:	e0bfff17 	ldw	r2,-4(fp)
  15558c:	10800417 	ldw	r2,16(r2)
  155590:	e13fff17 	ldw	r4,-4(fp)
  155594:	103ee83a 	callr	r2
  }
  return;
  155598:	0001883a 	nop
}
  15559c:	e037883a 	mov	sp,fp
  1555a0:	dfc00117 	ldw	ra,4(sp)
  1555a4:	df000017 	ldw	fp,0(sp)
  1555a8:	dec00204 	addi	sp,sp,8
  1555ac:	f800283a 	ret

001555b0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  1555b0:	defffe04 	addi	sp,sp,-8
  1555b4:	dfc00115 	stw	ra,4(sp)
  1555b8:	df000015 	stw	fp,0(sp)
  1555bc:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  1555c0:	0009883a 	mov	r4,zero
  1555c4:	01440004 	movi	r5,4096
  1555c8:	01558f80 	call	1558f8 <alt_icache_flush>
#endif
}
  1555cc:	e037883a 	mov	sp,fp
  1555d0:	dfc00117 	ldw	ra,4(sp)
  1555d4:	df000017 	ldw	fp,0(sp)
  1555d8:	dec00204 	addi	sp,sp,8
  1555dc:	f800283a 	ret

001555e0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  1555e0:	defffe04 	addi	sp,sp,-8
  1555e4:	df000115 	stw	fp,4(sp)
  1555e8:	df000104 	addi	fp,sp,4
  1555ec:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  1555f0:	e0bfff17 	ldw	r2,-4(fp)
  1555f4:	108000d0 	cmplti	r2,r2,3
  1555f8:	10000d1e 	bne	r2,zero,155630 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
  1555fc:	00c00574 	movhi	r3,21
  155600:	18db1604 	addi	r3,r3,27736
  155604:	e0bfff17 	ldw	r2,-4(fp)
  155608:	10800324 	muli	r2,r2,12
  15560c:	1885883a 	add	r2,r3,r2
  155610:	10800204 	addi	r2,r2,8
  155614:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  155618:	00c00574 	movhi	r3,21
  15561c:	18db1604 	addi	r3,r3,27736
  155620:	e0bfff17 	ldw	r2,-4(fp)
  155624:	10800324 	muli	r2,r2,12
  155628:	1885883a 	add	r2,r3,r2
  15562c:	10000015 	stw	zero,0(r2)
  }
}
  155630:	e037883a 	mov	sp,fp
  155634:	df000017 	ldw	fp,0(sp)
  155638:	dec00104 	addi	sp,sp,4
  15563c:	f800283a 	ret

00155640 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  155640:	deffff04 	addi	sp,sp,-4
  155644:	df000015 	stw	fp,0(sp)
  155648:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  15564c:	000170fa 	wrctl	ienable,zero
}
  155650:	e037883a 	mov	sp,fp
  155654:	df000017 	ldw	fp,0(sp)
  155658:	dec00104 	addi	sp,sp,4
  15565c:	f800283a 	ret

00155660 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  155660:	defff404 	addi	sp,sp,-48
  155664:	df000b15 	stw	fp,44(sp)
  155668:	df000b04 	addi	fp,sp,44
  15566c:	e13ffc15 	stw	r4,-16(fp)
  155670:	e17ffd15 	stw	r5,-12(fp)
  155674:	e1bffe15 	stw	r6,-8(fp)
  155678:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
  15567c:	e0ffff17 	ldw	r3,-4(fp)
  155680:	e0bffe17 	ldw	r2,-8(fp)
  155684:	1885883a 	add	r2,r3,r2
  155688:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
  15568c:	e0c00217 	ldw	r3,8(fp)
  155690:	e0800117 	ldw	r2,4(fp)
  155694:	1885883a 	add	r2,r3,r2
  155698:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
  15569c:	e0800117 	ldw	r2,4(fp)
  1556a0:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
  1556a4:	e0bffe17 	ldw	r2,-8(fp)
  1556a8:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
  1556ac:	00800044 	movi	r2,1
  1556b0:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  1556b4:	e0bffc17 	ldw	r2,-16(fp)
  1556b8:	10800504 	addi	r2,r2,20
  1556bc:	e0fffd17 	ldw	r3,-12(fp)
  1556c0:	01000044 	movi	r4,1
  1556c4:	20c6983a 	sll	r3,r4,r3
  1556c8:	10c00035 	stwio	r3,0(r2)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
  1556cc:	e0800317 	ldw	r2,12(fp)
  1556d0:	1080008c 	andi	r2,r2,2
  1556d4:	1000041e 	bne	r2,zero,1556e8 <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
  1556d8:	e0bffc17 	ldw	r2,-16(fp)
  1556dc:	10800304 	addi	r2,r2,12
  1556e0:	00c10004 	movi	r3,1024
  1556e4:	10c00035 	stwio	r3,0(r2)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
  1556e8:	e0bffc17 	ldw	r2,-16(fp)
  1556ec:	10800037 	ldwio	r2,0(r2)
  1556f0:	00000106 	br	1556f8 <alt_avalon_spi_command+0x98>

      if (read_ignore == 0 && read_data == read_end)
        break;
    }
    
  }
  1556f4:	0001883a 	nop
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  1556f8:	e0bffc17 	ldw	r2,-16(fp)
  1556fc:	10800204 	addi	r2,r2,8
  155700:	10800037 	ldwio	r2,0(r2)
  155704:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  155708:	e0bffa17 	ldw	r2,-24(fp)
  15570c:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  155710:	10000226 	beq	r2,zero,15571c <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  155714:	e0bff717 	ldw	r2,-36(fp)
  155718:	1000031e 	bne	r2,zero,155728 <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  15571c:	e0bffa17 	ldw	r2,-24(fp)
  155720:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  155724:	103ff426 	beq	r2,zero,1556f8 <alt_avalon_spi_command+0x98>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
  155728:	e0bffa17 	ldw	r2,-24(fp)
  15572c:	1080100c 	andi	r2,r2,64
  155730:	10001e26 	beq	r2,zero,1557ac <alt_avalon_spi_command+0x14c>
  155734:	e0bff717 	ldw	r2,-36(fp)
  155738:	00801c0e 	bge	zero,r2,1557ac <alt_avalon_spi_command+0x14c>
    {
      credits--;
  15573c:	e0bff717 	ldw	r2,-36(fp)
  155740:	10bfffc4 	addi	r2,r2,-1
  155744:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
  155748:	e0ffff17 	ldw	r3,-4(fp)
  15574c:	e0bff817 	ldw	r2,-32(fp)
  155750:	18800a2e 	bgeu	r3,r2,15577c <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
  155754:	e0bffc17 	ldw	r2,-16(fp)
  155758:	10800104 	addi	r2,r2,4
  15575c:	e0ffff17 	ldw	r3,-4(fp)
  155760:	18c00003 	ldbu	r3,0(r3)
  155764:	18c03fcc 	andi	r3,r3,255
  155768:	e13fff17 	ldw	r4,-4(fp)
  15576c:	21000044 	addi	r4,r4,1
  155770:	e13fff15 	stw	r4,-4(fp)
  155774:	10c00035 	stwio	r3,0(r2)
  155778:	00000c06 	br	1557ac <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
  15577c:	e0bff517 	ldw	r2,-44(fp)
  155780:	10000826 	beq	r2,zero,1557a4 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
  155784:	e0bff517 	ldw	r2,-44(fp)
  155788:	10bfffc4 	addi	r2,r2,-1
  15578c:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
  155790:	e0bffc17 	ldw	r2,-16(fp)
  155794:	10800104 	addi	r2,r2,4
  155798:	0007883a 	mov	r3,zero
  15579c:	10c00035 	stwio	r3,0(r2)
  1557a0:	00000206 	br	1557ac <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
  1557a4:	00bf0004 	movi	r2,-1024
  1557a8:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
  1557ac:	e0bffa17 	ldw	r2,-24(fp)
  1557b0:	1080200c 	andi	r2,r2,128
  1557b4:	103fcf26 	beq	r2,zero,1556f4 <alt_avalon_spi_command+0x94>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
  1557b8:	e0bffc17 	ldw	r2,-16(fp)
  1557bc:	10800037 	ldwio	r2,0(r2)
  1557c0:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
  1557c4:	e0bff617 	ldw	r2,-40(fp)
  1557c8:	10000426 	beq	r2,zero,1557dc <alt_avalon_spi_command+0x17c>
        read_ignore--;
  1557cc:	e0bff617 	ldw	r2,-40(fp)
  1557d0:	10bfffc4 	addi	r2,r2,-1
  1557d4:	e0bff615 	stw	r2,-40(fp)
  1557d8:	00000706 	br	1557f8 <alt_avalon_spi_command+0x198>
      else
        *read_data++ = (alt_u8)rxdata;
  1557dc:	e0bffb17 	ldw	r2,-20(fp)
  1557e0:	1007883a 	mov	r3,r2
  1557e4:	e0800217 	ldw	r2,8(fp)
  1557e8:	10c00005 	stb	r3,0(r2)
  1557ec:	e0800217 	ldw	r2,8(fp)
  1557f0:	10800044 	addi	r2,r2,1
  1557f4:	e0800215 	stw	r2,8(fp)
      credits++;
  1557f8:	e0bff717 	ldw	r2,-36(fp)
  1557fc:	10800044 	addi	r2,r2,1
  155800:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
  155804:	e0bff617 	ldw	r2,-40(fp)
  155808:	103fba1e 	bne	r2,zero,1556f4 <alt_avalon_spi_command+0x94>
  15580c:	e0c00217 	ldw	r3,8(fp)
  155810:	e0bff917 	ldw	r2,-28(fp)
  155814:	18bfb71e 	bne	r3,r2,1556f4 <alt_avalon_spi_command+0x94>
        break;
  155818:	0001883a 	nop
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  15581c:	e0bffc17 	ldw	r2,-16(fp)
  155820:	10800204 	addi	r2,r2,8
  155824:	10800037 	ldwio	r2,0(r2)
  155828:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
  15582c:	e0bffa17 	ldw	r2,-24(fp)
  155830:	1080080c 	andi	r2,r2,32
  155834:	103ff926 	beq	r2,zero,15581c <alt_avalon_spi_command+0x1bc>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
  155838:	e0800317 	ldw	r2,12(fp)
  15583c:	1080004c 	andi	r2,r2,1
  155840:	1000041e 	bne	r2,zero,155854 <alt_avalon_spi_command+0x1f4>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
  155844:	e0bffc17 	ldw	r2,-16(fp)
  155848:	10800304 	addi	r2,r2,12
  15584c:	0007883a 	mov	r3,zero
  155850:	10c00035 	stwio	r3,0(r2)

  return read_length;
  155854:	e0800117 	ldw	r2,4(fp)
}
  155858:	e037883a 	mov	sp,fp
  15585c:	df000017 	ldw	fp,0(sp)
  155860:	dec00104 	addi	sp,sp,4
  155864:	f800283a 	ret

00155868 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  155868:	defffa04 	addi	sp,sp,-24
  15586c:	dfc00515 	stw	ra,20(sp)
  155870:	df000415 	stw	fp,16(sp)
  155874:	df000404 	addi	fp,sp,16
  155878:	e13ffe15 	stw	r4,-8(fp)
  15587c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  155880:	e0bfff17 	ldw	r2,-4(fp)
  155884:	10800017 	ldw	r2,0(r2)
  155888:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  15588c:	e13ffe17 	ldw	r4,-8(fp)
  155890:	0155a4c0 	call	155a4c <strlen>
  155894:	10800044 	addi	r2,r2,1
  155898:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  15589c:	00000d06 	br	1558d4 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  1558a0:	e0bffc17 	ldw	r2,-16(fp)
  1558a4:	10c00217 	ldw	r3,8(r2)
  1558a8:	e0bffd17 	ldw	r2,-12(fp)
  1558ac:	1809883a 	mov	r4,r3
  1558b0:	e17ffe17 	ldw	r5,-8(fp)
  1558b4:	100d883a 	mov	r6,r2
  1558b8:	01559d00 	call	1559d0 <memcmp>
  1558bc:	1000021e 	bne	r2,zero,1558c8 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  1558c0:	e0bffc17 	ldw	r2,-16(fp)
  1558c4:	00000706 	br	1558e4 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  1558c8:	e0bffc17 	ldw	r2,-16(fp)
  1558cc:	10800017 	ldw	r2,0(r2)
  1558d0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1558d4:	e0fffc17 	ldw	r3,-16(fp)
  1558d8:	e0bfff17 	ldw	r2,-4(fp)
  1558dc:	18bff01e 	bne	r3,r2,1558a0 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  1558e0:	0005883a 	mov	r2,zero
}
  1558e4:	e037883a 	mov	sp,fp
  1558e8:	dfc00117 	ldw	ra,4(sp)
  1558ec:	df000017 	ldw	fp,0(sp)
  1558f0:	dec00204 	addi	sp,sp,8
  1558f4:	f800283a 	ret

001558f8 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  1558f8:	defffb04 	addi	sp,sp,-20
  1558fc:	df000415 	stw	fp,16(sp)
  155900:	df000404 	addi	fp,sp,16
  155904:	e13ffe15 	stw	r4,-8(fp)
  155908:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  15590c:	e0bfff17 	ldw	r2,-4(fp)
  155910:	10840070 	cmpltui	r2,r2,4097
  155914:	1000021e 	bne	r2,zero,155920 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  155918:	00840004 	movi	r2,4096
  15591c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  155920:	e0fffe17 	ldw	r3,-8(fp)
  155924:	e0bfff17 	ldw	r2,-4(fp)
  155928:	1885883a 	add	r2,r3,r2
  15592c:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  155930:	e0bffe17 	ldw	r2,-8(fp)
  155934:	e0bffc15 	stw	r2,-16(fp)
  155938:	00000506 	br	155950 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  15593c:	e0bffc17 	ldw	r2,-16(fp)
  155940:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  155944:	e0bffc17 	ldw	r2,-16(fp)
  155948:	10800804 	addi	r2,r2,32
  15594c:	e0bffc15 	stw	r2,-16(fp)
  155950:	e0fffc17 	ldw	r3,-16(fp)
  155954:	e0bffd17 	ldw	r2,-12(fp)
  155958:	18bff836 	bltu	r3,r2,15593c <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  15595c:	e0bffe17 	ldw	r2,-8(fp)
  155960:	108007cc 	andi	r2,r2,31
  155964:	10000226 	beq	r2,zero,155970 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  155968:	e0bffc17 	ldw	r2,-16(fp)
  15596c:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  155970:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  155974:	e037883a 	mov	sp,fp
  155978:	df000017 	ldw	fp,0(sp)
  15597c:	dec00104 	addi	sp,sp,4
  155980:	f800283a 	ret

00155984 <atexit>:
  155984:	200b883a 	mov	r5,r4
  155988:	000d883a 	mov	r6,zero
  15598c:	0009883a 	mov	r4,zero
  155990:	000f883a 	mov	r7,zero
  155994:	0155ad81 	jmpi	155ad8 <__register_exitproc>

00155998 <exit>:
  155998:	defffe04 	addi	sp,sp,-8
  15599c:	000b883a 	mov	r5,zero
  1559a0:	dc000015 	stw	r16,0(sp)
  1559a4:	dfc00115 	stw	ra,4(sp)
  1559a8:	2021883a 	mov	r16,r4
  1559ac:	0155c080 	call	155c08 <__call_exitprocs>
  1559b0:	00800574 	movhi	r2,21
  1559b4:	109c7f04 	addi	r2,r2,29180
  1559b8:	11000017 	ldw	r4,0(r2)
  1559bc:	20800f17 	ldw	r2,60(r4)
  1559c0:	10000126 	beq	r2,zero,1559c8 <exit+0x30>
  1559c4:	103ee83a 	callr	r2
  1559c8:	8009883a 	mov	r4,r16
  1559cc:	0155da80 	call	155da8 <_exit>

001559d0 <memcmp>:
  1559d0:	01c000c4 	movi	r7,3
  1559d4:	3980192e 	bgeu	r7,r6,155a3c <memcmp+0x6c>
  1559d8:	2904b03a 	or	r2,r5,r4
  1559dc:	11c4703a 	and	r2,r2,r7
  1559e0:	10000f26 	beq	r2,zero,155a20 <memcmp+0x50>
  1559e4:	20c00003 	ldbu	r3,0(r4)
  1559e8:	28800003 	ldbu	r2,0(r5)
  1559ec:	1880151e 	bne	r3,r2,155a44 <memcmp+0x74>
  1559f0:	31bfff84 	addi	r6,r6,-2
  1559f4:	01ffffc4 	movi	r7,-1
  1559f8:	00000406 	br	155a0c <memcmp+0x3c>
  1559fc:	20c00003 	ldbu	r3,0(r4)
  155a00:	28800003 	ldbu	r2,0(r5)
  155a04:	31bfffc4 	addi	r6,r6,-1
  155a08:	18800e1e 	bne	r3,r2,155a44 <memcmp+0x74>
  155a0c:	21000044 	addi	r4,r4,1
  155a10:	29400044 	addi	r5,r5,1
  155a14:	31fff91e 	bne	r6,r7,1559fc <memcmp+0x2c>
  155a18:	0005883a 	mov	r2,zero
  155a1c:	f800283a 	ret
  155a20:	20c00017 	ldw	r3,0(r4)
  155a24:	28800017 	ldw	r2,0(r5)
  155a28:	1880041e 	bne	r3,r2,155a3c <memcmp+0x6c>
  155a2c:	31bfff04 	addi	r6,r6,-4
  155a30:	21000104 	addi	r4,r4,4
  155a34:	29400104 	addi	r5,r5,4
  155a38:	39bff936 	bltu	r7,r6,155a20 <memcmp+0x50>
  155a3c:	303fe91e 	bne	r6,zero,1559e4 <memcmp+0x14>
  155a40:	003ff506 	br	155a18 <memcmp+0x48>
  155a44:	1885c83a 	sub	r2,r3,r2
  155a48:	f800283a 	ret

00155a4c <strlen>:
  155a4c:	208000cc 	andi	r2,r4,3
  155a50:	10001f1e 	bne	r2,zero,155ad0 <strlen+0x84>
  155a54:	20800017 	ldw	r2,0(r4)
  155a58:	01ffbff4 	movhi	r7,65279
  155a5c:	39ffbfc4 	addi	r7,r7,-257
  155a60:	01a02074 	movhi	r6,32897
  155a64:	31a02004 	addi	r6,r6,-32640
  155a68:	11c7883a 	add	r3,r2,r7
  155a6c:	0084303a 	nor	r2,zero,r2
  155a70:	1886703a 	and	r3,r3,r2
  155a74:	1986703a 	and	r3,r3,r6
  155a78:	2005883a 	mov	r2,r4
  155a7c:	1800101e 	bne	r3,zero,155ac0 <strlen+0x74>
  155a80:	10800104 	addi	r2,r2,4
  155a84:	10c00017 	ldw	r3,0(r2)
  155a88:	19cb883a 	add	r5,r3,r7
  155a8c:	00c6303a 	nor	r3,zero,r3
  155a90:	28c6703a 	and	r3,r5,r3
  155a94:	1986703a 	and	r3,r3,r6
  155a98:	1800091e 	bne	r3,zero,155ac0 <strlen+0x74>
  155a9c:	10800104 	addi	r2,r2,4
  155aa0:	10c00017 	ldw	r3,0(r2)
  155aa4:	19cb883a 	add	r5,r3,r7
  155aa8:	00c6303a 	nor	r3,zero,r3
  155aac:	28c6703a 	and	r3,r5,r3
  155ab0:	1986703a 	and	r3,r3,r6
  155ab4:	183ff226 	beq	r3,zero,155a80 <strlen+0x34>
  155ab8:	00000106 	br	155ac0 <strlen+0x74>
  155abc:	10800044 	addi	r2,r2,1
  155ac0:	10c00007 	ldb	r3,0(r2)
  155ac4:	183ffd1e 	bne	r3,zero,155abc <strlen+0x70>
  155ac8:	1105c83a 	sub	r2,r2,r4
  155acc:	f800283a 	ret
  155ad0:	2005883a 	mov	r2,r4
  155ad4:	003ffa06 	br	155ac0 <strlen+0x74>

00155ad8 <__register_exitproc>:
  155ad8:	defffa04 	addi	sp,sp,-24
  155adc:	00800574 	movhi	r2,21
  155ae0:	109c7f04 	addi	r2,r2,29180
  155ae4:	dc000315 	stw	r16,12(sp)
  155ae8:	14000017 	ldw	r16,0(r2)
  155aec:	dc400415 	stw	r17,16(sp)
  155af0:	dfc00515 	stw	ra,20(sp)
  155af4:	80805217 	ldw	r2,328(r16)
  155af8:	2023883a 	mov	r17,r4
  155afc:	10003e26 	beq	r2,zero,155bf8 <__register_exitproc+0x120>
  155b00:	10c00117 	ldw	r3,4(r2)
  155b04:	020007c4 	movi	r8,31
  155b08:	40c0180e 	bge	r8,r3,155b6c <__register_exitproc+0x94>
  155b0c:	00800034 	movhi	r2,0
  155b10:	10800004 	addi	r2,r2,0
  155b14:	1000061e 	bne	r2,zero,155b30 <__register_exitproc+0x58>
  155b18:	00bfffc4 	movi	r2,-1
  155b1c:	dfc00517 	ldw	ra,20(sp)
  155b20:	dc400417 	ldw	r17,16(sp)
  155b24:	dc000317 	ldw	r16,12(sp)
  155b28:	dec00604 	addi	sp,sp,24
  155b2c:	f800283a 	ret
  155b30:	01006404 	movi	r4,400
  155b34:	d9400015 	stw	r5,0(sp)
  155b38:	d9800115 	stw	r6,4(sp)
  155b3c:	d9c00215 	stw	r7,8(sp)
  155b40:	00000000 	call	0 <PIO_IRQ_MASK-0x8>
  155b44:	d9400017 	ldw	r5,0(sp)
  155b48:	d9800117 	ldw	r6,4(sp)
  155b4c:	d9c00217 	ldw	r7,8(sp)
  155b50:	103ff126 	beq	r2,zero,155b18 <__register_exitproc+0x40>
  155b54:	80c05217 	ldw	r3,328(r16)
  155b58:	10000115 	stw	zero,4(r2)
  155b5c:	10c00015 	stw	r3,0(r2)
  155b60:	80805215 	stw	r2,328(r16)
  155b64:	10006215 	stw	zero,392(r2)
  155b68:	10006315 	stw	zero,396(r2)
  155b6c:	10c00117 	ldw	r3,4(r2)
  155b70:	88000d1e 	bne	r17,zero,155ba8 <__register_exitproc+0xd0>
  155b74:	19000084 	addi	r4,r3,2
  155b78:	2109883a 	add	r4,r4,r4
  155b7c:	18c00044 	addi	r3,r3,1
  155b80:	2109883a 	add	r4,r4,r4
  155b84:	1109883a 	add	r4,r2,r4
  155b88:	10c00115 	stw	r3,4(r2)
  155b8c:	0005883a 	mov	r2,zero
  155b90:	21400015 	stw	r5,0(r4)
  155b94:	dfc00517 	ldw	ra,20(sp)
  155b98:	dc400417 	ldw	r17,16(sp)
  155b9c:	dc000317 	ldw	r16,12(sp)
  155ba0:	dec00604 	addi	sp,sp,24
  155ba4:	f800283a 	ret
  155ba8:	02400044 	movi	r9,1
  155bac:	12806217 	ldw	r10,392(r2)
  155bb0:	48d2983a 	sll	r9,r9,r3
  155bb4:	19000804 	addi	r4,r3,32
  155bb8:	18d1883a 	add	r8,r3,r3
  155bbc:	2109883a 	add	r4,r4,r4
  155bc0:	4211883a 	add	r8,r8,r8
  155bc4:	2109883a 	add	r4,r4,r4
  155bc8:	1109883a 	add	r4,r2,r4
  155bcc:	1211883a 	add	r8,r2,r8
  155bd0:	5254b03a 	or	r10,r10,r9
  155bd4:	21c02215 	stw	r7,136(r4)
  155bd8:	41802215 	stw	r6,136(r8)
  155bdc:	12806215 	stw	r10,392(r2)
  155be0:	01000084 	movi	r4,2
  155be4:	893fe31e 	bne	r17,r4,155b74 <__register_exitproc+0x9c>
  155be8:	11006317 	ldw	r4,396(r2)
  155bec:	2252b03a 	or	r9,r4,r9
  155bf0:	12406315 	stw	r9,396(r2)
  155bf4:	003fdf06 	br	155b74 <__register_exitproc+0x9c>
  155bf8:	008005b4 	movhi	r2,22
  155bfc:	10acbc04 	addi	r2,r2,-19728
  155c00:	80805215 	stw	r2,328(r16)
  155c04:	003fbe06 	br	155b00 <__register_exitproc+0x28>

00155c08 <__call_exitprocs>:
  155c08:	00800574 	movhi	r2,21
  155c0c:	109c7f04 	addi	r2,r2,29180
  155c10:	10800017 	ldw	r2,0(r2)
  155c14:	defff304 	addi	sp,sp,-52
  155c18:	df000b15 	stw	fp,44(sp)
  155c1c:	d8800015 	stw	r2,0(sp)
  155c20:	10805204 	addi	r2,r2,328
  155c24:	dd400815 	stw	r21,32(sp)
  155c28:	dfc00c15 	stw	ra,48(sp)
  155c2c:	ddc00a15 	stw	r23,40(sp)
  155c30:	dd800915 	stw	r22,36(sp)
  155c34:	dd000715 	stw	r20,28(sp)
  155c38:	dcc00615 	stw	r19,24(sp)
  155c3c:	dc800515 	stw	r18,20(sp)
  155c40:	dc400415 	stw	r17,16(sp)
  155c44:	dc000315 	stw	r16,12(sp)
  155c48:	d9000115 	stw	r4,4(sp)
  155c4c:	2839883a 	mov	fp,r5
  155c50:	d8800215 	stw	r2,8(sp)
  155c54:	057fffc4 	movi	r21,-1
  155c58:	d8800017 	ldw	r2,0(sp)
  155c5c:	ddc00217 	ldw	r23,8(sp)
  155c60:	14805217 	ldw	r18,328(r2)
  155c64:	90001726 	beq	r18,zero,155cc4 <__call_exitprocs+0xbc>
  155c68:	94400117 	ldw	r17,4(r18)
  155c6c:	8c3fffc4 	addi	r16,r17,-1
  155c70:	80001116 	blt	r16,zero,155cb8 <__call_exitprocs+0xb0>
  155c74:	8c400044 	addi	r17,r17,1
  155c78:	8427883a 	add	r19,r16,r16
  155c7c:	8c63883a 	add	r17,r17,r17
  155c80:	95802204 	addi	r22,r18,136
  155c84:	9ce7883a 	add	r19,r19,r19
  155c88:	8c63883a 	add	r17,r17,r17
  155c8c:	b4e7883a 	add	r19,r22,r19
  155c90:	9463883a 	add	r17,r18,r17
  155c94:	e0001726 	beq	fp,zero,155cf4 <__call_exitprocs+0xec>
  155c98:	8c87c83a 	sub	r3,r17,r18
  155c9c:	b0c7883a 	add	r3,r22,r3
  155ca0:	18c01e17 	ldw	r3,120(r3)
  155ca4:	1f001326 	beq	r3,fp,155cf4 <__call_exitprocs+0xec>
  155ca8:	843fffc4 	addi	r16,r16,-1
  155cac:	9cffff04 	addi	r19,r19,-4
  155cb0:	8c7fff04 	addi	r17,r17,-4
  155cb4:	857ff71e 	bne	r16,r21,155c94 <__call_exitprocs+0x8c>
  155cb8:	00800034 	movhi	r2,0
  155cbc:	10800004 	addi	r2,r2,0
  155cc0:	10002a1e 	bne	r2,zero,155d6c <__call_exitprocs+0x164>
  155cc4:	dfc00c17 	ldw	ra,48(sp)
  155cc8:	df000b17 	ldw	fp,44(sp)
  155ccc:	ddc00a17 	ldw	r23,40(sp)
  155cd0:	dd800917 	ldw	r22,36(sp)
  155cd4:	dd400817 	ldw	r21,32(sp)
  155cd8:	dd000717 	ldw	r20,28(sp)
  155cdc:	dcc00617 	ldw	r19,24(sp)
  155ce0:	dc800517 	ldw	r18,20(sp)
  155ce4:	dc400417 	ldw	r17,16(sp)
  155ce8:	dc000317 	ldw	r16,12(sp)
  155cec:	dec00d04 	addi	sp,sp,52
  155cf0:	f800283a 	ret
  155cf4:	91000117 	ldw	r4,4(r18)
  155cf8:	88c00017 	ldw	r3,0(r17)
  155cfc:	213fffc4 	addi	r4,r4,-1
  155d00:	24001526 	beq	r4,r16,155d58 <__call_exitprocs+0x150>
  155d04:	88000015 	stw	zero,0(r17)
  155d08:	183fe726 	beq	r3,zero,155ca8 <__call_exitprocs+0xa0>
  155d0c:	00800044 	movi	r2,1
  155d10:	1408983a 	sll	r4,r2,r16
  155d14:	91406217 	ldw	r5,392(r18)
  155d18:	95000117 	ldw	r20,4(r18)
  155d1c:	214a703a 	and	r5,r4,r5
  155d20:	28000b26 	beq	r5,zero,155d50 <__call_exitprocs+0x148>
  155d24:	91406317 	ldw	r5,396(r18)
  155d28:	2148703a 	and	r4,r4,r5
  155d2c:	20000c1e 	bne	r4,zero,155d60 <__call_exitprocs+0x158>
  155d30:	99400017 	ldw	r5,0(r19)
  155d34:	d9000117 	ldw	r4,4(sp)
  155d38:	183ee83a 	callr	r3
  155d3c:	90c00117 	ldw	r3,4(r18)
  155d40:	1d3fc51e 	bne	r3,r20,155c58 <__call_exitprocs+0x50>
  155d44:	b8c00017 	ldw	r3,0(r23)
  155d48:	1cbfd726 	beq	r3,r18,155ca8 <__call_exitprocs+0xa0>
  155d4c:	003fc206 	br	155c58 <__call_exitprocs+0x50>
  155d50:	183ee83a 	callr	r3
  155d54:	003ff906 	br	155d3c <__call_exitprocs+0x134>
  155d58:	94000115 	stw	r16,4(r18)
  155d5c:	003fea06 	br	155d08 <__call_exitprocs+0x100>
  155d60:	99000017 	ldw	r4,0(r19)
  155d64:	183ee83a 	callr	r3
  155d68:	003ff406 	br	155d3c <__call_exitprocs+0x134>
  155d6c:	90c00117 	ldw	r3,4(r18)
  155d70:	1800071e 	bne	r3,zero,155d90 <__call_exitprocs+0x188>
  155d74:	90c00017 	ldw	r3,0(r18)
  155d78:	18000926 	beq	r3,zero,155da0 <__call_exitprocs+0x198>
  155d7c:	9009883a 	mov	r4,r18
  155d80:	b8c00015 	stw	r3,0(r23)
  155d84:	00000000 	call	0 <PIO_IRQ_MASK-0x8>
  155d88:	bc800017 	ldw	r18,0(r23)
  155d8c:	003fb506 	br	155c64 <__call_exitprocs+0x5c>
  155d90:	90c00017 	ldw	r3,0(r18)
  155d94:	902f883a 	mov	r23,r18
  155d98:	1825883a 	mov	r18,r3
  155d9c:	003fb106 	br	155c64 <__call_exitprocs+0x5c>
  155da0:	0007883a 	mov	r3,zero
  155da4:	003ffb06 	br	155d94 <__call_exitprocs+0x18c>

00155da8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  155da8:	defffc04 	addi	sp,sp,-16
  155dac:	df000315 	stw	fp,12(sp)
  155db0:	df000304 	addi	fp,sp,12
  155db4:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  155db8:	0001883a 	nop
  155dbc:	e0bfff17 	ldw	r2,-4(fp)
  155dc0:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
  155dc4:	e0bffd17 	ldw	r2,-12(fp)
  155dc8:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  155dcc:	e0bffe17 	ldw	r2,-8(fp)
  155dd0:	10000226 	beq	r2,zero,155ddc <_exit+0x34>
    ALT_SIM_FAIL();
  155dd4:	002af070 	cmpltui	zero,zero,43969
  155dd8:	00000106 	br	155de0 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
  155ddc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  155de0:	003fff06 	br	155de0 <_exit+0x38>
